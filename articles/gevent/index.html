

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu Yang">
  <meta name="keywords" content="">
  
    <meta name="description" content="基本概念coroutineCoroutine 也就是 corporate routine，中文名就是协程，从它的英文可以看出是协同 的例程的意思,实际上这个概念和进程与线程有相似之处, 因为linux线程就是所谓的轻量级进程,所以我们来比较一下进程与协程的异同:  相同点:二者都是可以看做是一种执行流, 该执行流可以挂起,并且在将来又可以在 你挂起的地方恢复执行,这实际上都可以看做是continu">
<meta property="og:type" content="article">
<meta property="og:title" content="gevent笔记与源码分析">
<meta property="og:url" content="https://yuyang0.github.io/articles/gevent/index.html">
<meta property="og:site_name" content="yuyang&#39;s blog">
<meta property="og:description" content="基本概念coroutineCoroutine 也就是 corporate routine，中文名就是协程，从它的英文可以看出是协同 的例程的意思,实际上这个概念和进程与线程有相似之处, 因为linux线程就是所谓的轻量级进程,所以我们来比较一下进程与协程的异同:  相同点:二者都是可以看做是一种执行流, 该执行流可以挂起,并且在将来又可以在 你挂起的地方恢复执行,这实际上都可以看做是continu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuyang0.github.io/img/gevent-index-cover.webp">
<meta property="article:published_time" content="2018-02-11T03:54:17.000Z">
<meta property="article:modified_time" content="2023-02-05T07:43:49.370Z">
<meta property="article:author" content="Yu Yang">
<meta property="article:tag" content="gevent">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yuyang0.github.io/img/gevent-index-cover.webp">
  
  
  <title>gevent笔记与源码分析 - yuyang&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yuyang0.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0,"placement":"right"},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"LyT8mpSI2Jq9CRhOtNOgBXkE-9Nh9j0Va","app_key":"fUOlkXhD9wcmxOTed9NdlqPH","server_url":"https://lyt8mpsi.lc-cn-e1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>yuyang&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://rmt.dogedoge.com/fetch/fluid/storage/bg/dojm2h.png?w=1920&q=100&fmt=webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="gevent笔记与源码分析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-02-11 11:54" pubdate>
        2018年2月11日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      152 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">gevent笔记与源码分析</h1>
            
            <div class="markdown-body">
              <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h2><p>Coroutine 也就是 corporate routine，中文名就是协程，从它的英文可以看出是协同 的例程的意思,<br>实际上这个概念和进程与线程有相似之处, 因为linux线程就是所谓的<br>轻量级进程,所以我们来比较一下进程与协程的异同:</p>
<ul>
<li><strong>相同点</strong>:二者都是可以看做是一种执行流, 该执行流可以挂起,并且在将来又可以在 你挂起的地方恢复执行,<br>这实际上都可以看做是continuation, 我们来看看当我们挂<br>起一个执行流时我们要保存的东西<ol>
<li><strong>栈</strong>, 因为如果你不保存栈,那么局部变量你就无法恢复,同时函数的调用链你也无 法恢复,</li>
<li><strong>寄存器的状态</strong>: 这好理解, 比如说EIP,如果你不保存,那么你恢复执行流就不知道 到底执行哪一条指令,<br>在比如说ESP,EBP, 如果你不保存,那么你即便有完整的栈 你也不知道怎么用.<br>这二者实际就是所谓的上下文,也可以说是continuation. 在执行流切换时必须保存 这两个东西, 内核调度进程时也是一回事.</li>
</ol>
</li>
<li><strong>不同点</strong>:<ol>
<li>执行流的调度者不同, 进程是内核调度, 而协程是在用户态调度, 也就是说进程<br>的上下文是在内核态保存恢复的,而协程是在用户态保存恢复的.<br>很显然用户态的 代价更低</li>
<li>进程会被抢占,而协程不会,也就是说协程如果不主动让出CPU,那么其他的协程是不<br>可能得到执行机会,这实际和早期的操作系统类似,比如DOS,<br>它有一个yield原语, 一个进程调用yield,那么它就会让出CPU, 其他的进程也就有机会执行了, 如果一<br>个进程进入了死循环,那么整个系统也就挂起了,永远无法运行其他的进程了, 但<br>对协程而言,这不是问题</li>
<li>对内存的占用不同,实际上协程可以只需要4K的栈就够了, 而进程占用的内存要大 的多.</li>
<li>从操作系统的角度讲, 多协程的程序是单线程,单进程的</li>
</ol>
</li>
</ul>
<h1 id="gevent背景知识"><a href="#gevent背景知识" class="headerlink" title="gevent背景知识"></a>gevent背景知识</h1><p>gevent用到了了libev以及greenlet还有cares,下面简单的介绍这几个库.</p>
<h2 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h2><p>实际是一个协程库(官方叫micro-thread), 它只提供协程本身,要在协程间切 换调度必须你在程序中手动来进行,直接上代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">x, y</span>):<br>    z = gr2.switch(x+y)<br>    <span class="hljs-built_in">print</span> z<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-built_in">print</span> u<br>    gr1.switch(<span class="hljs-number">42</span>)<br><br>gr1 = greenlet(test1)<br>gr2 = greenlet(test2)<br>gr1.switch(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot; world&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>gr1, gr2以及运行该代码的解释器本身都是协程, 协程对象的switch方法用 来切换,比如 <code>gr2.switch</code> 就是切换到gr2.</p>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ol>
<li>greenlet(run&#x3D;None, parent&#x3D;None): 创建一个greenlet实例.</li>
<li>greenlet.getcurrent:</li>
</ol>
<p>实例方法与属性</p>
<ol>
<li>gr.parent:每一个协程都有一个父协程,当前协程结束后会回到父协程中执行,该 属性默认是创建该协程的协程.</li>
<li>gr.run: 该属性是协程实际运行的代码. run方法结束了,那么该协程也就结束了.</li>
<li>gr.switch(*args, **kwargs): 切换到gr协程.</li>
<li>gr.throw(): 切换到gr协程,接着抛出一个异常.</li>
</ol>
<h2 id="libev"><a href="#libev" class="headerlink" title="libev"></a>libev</h2><p>和libevent类似, libev是一个事件循环库,他可以监听各个file descriptor, 一旦发现 就绪就调用对应的回调函数,<br>gevent内部就是使用libev来监听socket的.为了后续理解 方便有必要对libev进行简单的了解.</p>
<ol>
<li>watcher: 实际上是用来封装各种类型的事件的,不同类型的事件会有不同类型的 watcher, 比如 <code>ev_io</code>,<br><code>ev_timer</code>, 该结构一般会有一个回调函数,当事件触发 使就会调用回调函数.<br>watcher会有两种函数(注意TYPE代表watcher类型,可以是 io, timer,<br>signal等等):<ul>
<li>ev_TYPE_init: 对watcher对象进行初始化, 对IO而言该函数是 <code>ev_io_init</code>,<br>对timer而言,该函数是 <code>ev_timer_init</code>.</li>
<li>ev_TYPE_set: 与init系列函数的区别是该函数一般不设置callback</li>
<li>ev_TYPE_start: 将watcher注册到事件循环中,这样就可以监听事件了.</li>
</ul>
</li>
<li>loop: 事件循环</li>
</ol>
<p>来看看示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a single header file is required</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ev.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// for puts</span></span><br><br><span class="hljs-comment">// every watcher type has its own typedef&#x27;d struct</span><br><span class="hljs-comment">// with the name ev_TYPE</span><br>ev_io stdin_watcher;<br>ev_timer timeout_watcher;<br><br><span class="hljs-comment">// all watcher callbacks have a similar signature</span><br><span class="hljs-comment">// this callback is called when data is readable on stdin</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">stdin_cb</span> <span class="hljs-params">(EV_P_ ev_io *w, <span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span> (<span class="hljs-string">&quot;stdin ready&quot;</span>);<br>    <span class="hljs-comment">// for one-shot events, one must manually stop the watcher</span><br>    <span class="hljs-comment">// with its corresponding stop function.</span><br>    ev_io_stop (EV_A_ w);<br><br>    <span class="hljs-comment">// this causes all nested ev_run&#x27;s to stop iterating</span><br>    ev_break (EV_A_ EVBREAK_ALL);<br>&#125;<br><br><span class="hljs-comment">// another callback, this time for a time-out</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">timeout_cb</span> <span class="hljs-params">(EV_P_ ev_timer *w, <span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span> (<span class="hljs-string">&quot;timeout&quot;</span>);<br>    <span class="hljs-comment">// this causes the innermost ev_run to stop iterating</span><br>    ev_break (EV_A_ EVBREAK_ONE);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// use the default event loop unless you have special needs</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span> *<span class="hljs-title">loop</span> =</span> EV_DEFAULT;<br><br>    <span class="hljs-comment">// initialise an io watcher, then start it</span><br>    <span class="hljs-comment">// this one will watch for stdin to become readable</span><br>    ev_io_init (&amp;stdin_watcher, stdin_cb, <span class="hljs-comment">/*STDIN_FILENO*/</span> <span class="hljs-number">0</span>, EV_READ);<br>    ev_io_start (loop, &amp;stdin_watcher);<br><br>    <span class="hljs-comment">// initialise a timer watcher, then start it</span><br>    <span class="hljs-comment">// simple non-repeating 5.5 second timeout</span><br>    ev_timer_init (&amp;timeout_watcher, timeout_cb, <span class="hljs-number">5.5</span>, <span class="hljs-number">0.</span>);<br>    ev_timer_start (loop, &amp;timeout_watcher);<br><br>    <span class="hljs-comment">// now wait for events to arrive</span><br>    ev_run (loop, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// break was called, so exit</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>获得loop对象, 创建一个io watcher,一个timer watcher, 分别初始化(调用init函<br>数),然后调用start注册回调函数到事件循环中, 接着调用ev_run启动事件循环.</p>
<h1 id="gevent源码分析"><a href="#gevent源码分析" class="headerlink" title="gevent源码分析"></a>gevent源码分析</h1><p>开始之前先申明: <strong>本文分析的是gevent1.0</strong>.</p>
<h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>core.ppyx文件实际上是用Cython写的代码，在Makefile中有这样一行代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs example">gevent/gevent.core.c: gevent/core.ppyx gevent/libev.pxd<br>        $(PYTHON) util/cythonpp.py -o gevent.core.c gevent/core.ppyx<br>        echo                          &gt;&gt; gevent.core.c<br>        echo &#x27;#include &quot;callbacks.c&quot;&#x27; &gt;&gt; gevent.core.c<br>        mv gevent.core.* gevent/<br><br></code></pre></td></tr></table></figure>

<p>上面的代码告诉我们core.ppyx会先转换为gevent.core.c这个C语言文件,然后在编译成 动态链接库，它的语法基本能看懂,<br>这个模块主要是实现loop这个类, hub对象中的<br>loop就是这个类的一个对象(注意名字虽然相同但一个是类,一个对象,不要弄混),这个<br>类将libev的事件循环机制封装了起来,我们先熟悉下这个类提供的API,熟悉这些API对<br>使用gevent很有帮助,我假设lp是loop类的对象(在gevent中就是get_hub().loop)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs example">def io(self, int fd, int events, ref=True, priority=None):<br>    return io(self, fd, events, ref, priority)<br><br>def timer(self, double after, double repeat=0.0, ref=True, priority=None):<br>    return timer(self, after, repeat, ref, priority)<br><br>def signal(self, int signum, ref=True, priority=None):<br>    return signal(self, signum, ref, priority)<br><br>def idle(self, ref=True, priority=None):<br>    return idle(self, ref, priority)<br><br>def prepare(self, ref=True, priority=None):<br>    return prepare(self, ref, priority)<br><br>def fork(self, ref=True, priority=None):<br>    return fork(self, ref, priority)<br><br>def async(self, ref=True, priority=None):<br>    return async(self, ref, priority)<br></code></pre></td></tr></table></figure>

<p>注意上面是Cython, 上面的一系列方法实际是libev中watcher的等价物.比如你调用 <code>lp.io(fd, 1)</code>,<br>就创建了一个监听fd的read事件的watcher对象,至于其它的api都是 类似,<br>每一个watcher对象都有一个 <code>start</code> 方法, 该方法接受一个回调函数以及一系 列传递给回调函数的参数,<br>调用该方法就会将watcher对象注册到libev的事件循环上, 看下面的示例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">read_watcher = lp.io(fd, <span class="hljs-number">1</span>)<br>read_watcher.start(cb, args)<br></code></pre></td></tr></table></figure>

<p>运行上面的两行代码,那么当fd上读就绪时,那么就会调用cb函数,并且会把args传递给<br>cb函数.在gevent中回调函数一般是协程的switch方法,<br>这样一旦调用,那么就切换到 另一个协程中去执行.</p>
<h3 id="core源码分析"><a href="#core源码分析" class="headerlink" title="core源码分析"></a>core源码分析</h3><p>这一节来分析core.ppyx的源码, 在一次提醒你注意,代码是Cython, 我对Cython也不 太熟,但是代码大致能看懂.<br>同时要明白该模块是对libev的封装, libev中loop,<br>watcher,callback在该模块中都有对应物, 所以你要注意当提到loop时,我们到底是<br>该模块的loop还是libev的loop.</p>
<ol>
<li><p>先看callback</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs example">cdef public class callback [object PyGeventCallbackObject, type PyGeventCallback_Type]:<br>    cdef public object callback<br>    cdef public tuple args<br><br>    def __init__(self, callback, args):<br>        self.callback = callback<br>        self.args = args<br><br>    def stop(self):<br>        self.callback = None<br>        self.args = None<br></code></pre></td></tr></table></figure>

<p>实际上就是把回调函数以及要提供给回调函数的参数封装了起来.</p>
</li>
<li><p>loop: 事件循环的封装.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs example">cdef public class loop [object PyGeventLoopObject, type PyGeventLoop_Type]:<br>    cdef libev.ev_loop* _ptr<br>    cdef public object error_handler<br>    cdef libev.ev_prepare _prepare<br>    cdef public list _callbacks<br>    cdef libev.ev_timer _timer0<br><br>    def __init__(self, object flags=None, object default=None, size_t ptr=0):<br>        cdef unsigned int c_flags<br>        cdef object old_handler = None<br>        libev.ev_prepare_init(&amp;self._prepare, &lt;void*&gt;gevent_run_callbacks)<br>        libev.ev_timer_init(&amp;self._timer0, &lt;void*&gt;gevent_noop, 0.0, 0.0)<br>        if ptr:<br>            self._ptr = &lt;libev.ev_loop*&gt;ptr<br>        else:<br>            ......<br><br>        self._callbacks = []<br></code></pre></td></tr></table></figure>

<ol>
<li>_ptr: libev的一个ev_loop对象.</li>
<li>_prepare: libev中的prepare watcher,该watcher注册的回调函数会在事件循环进 入阻塞时调用,<br>从代码中可以看到注册的回调函数是 <code>gevent_run_callbacks</code>, 该函数会运行 <code>_callbacks</code><br>列表中的每一个callback实例.</li>
<li>_callbacks: 一个列表,实际上当你使用gevent的spawn创建协程时, spawn会在<br>该列表中插入一个callback实例, 该实例的回调函数实际就是你创建的<br>greenlet的switch方法, 这样当 <code>_prepare</code> watcher就绪时,新的协程就有了 启动的机会.</li>
</ol>
</li>
<li><p>watcher: 这是libev的watcher对象的封装,作为例子,我只分析io这一个例 子,timer,signal等等都是相似的,<br>为了方便我使用cwatcher来指代libev中的 watcher.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>#define WATCHER_BASE(TYPE)                                            \<br>    cdef public loop loop                                             \<br>    cdef object _callback                                             \<br>    cdef public tuple args                                            \<br>    cdef readonly int _flags                                          \<br>    cdef libev.ev_##TYPE _watcher                                     \<br><br>cdef public class io(watcher) [object PyGeventIOObject, type PyGeventIO_Type]:<br><br>    WATCHER_BASE(io)<br><br>    def start(self, object callback, *args, pass_events=False):<br>        CHECK_LOOP2(self.loop)<br>        if callback is None:<br>            raise TypeError(&#x27;callback must be callable, not None&#x27;)<br>        self.callback = callback<br>        if pass_events:<br>            self.args = (GEVENT_CORE_EVENTS, ) + args<br>        else:<br>            self.args = args<br>        LIBEV_UNREF<br>        libev.ev_io_start(self.loop._ptr, &amp;self._watcher)<br><br>    def __init__(self, loop loop, int fd, int events, ref=True, priority=None):<br>        if fd &lt; 0:<br>            raise ValueError(&#x27;fd must be non-negative: %r&#x27; % fd)<br>        if events &amp; ~(libev.EV__IOFDSET | libev.EV_READ | libev.EV_WRITE):<br>            raise ValueError(&#x27;illegal event mask: %r&#x27; % events)<br>        libev.ev_io_init(&amp;self._watcher, &lt;void *&gt;gevent_callback_io, fd, events)<br>        self.loop = loop<br>        if ref:<br>            self._flags = 0<br>        else:<br>            self._flags = 4<br>        if priority is not None:<br>            libev.ev_set_priority(&amp;self._watcher, priority)<br></code></pre></td></tr></table></figure>

<ol>
<li><p>WATCH_BASE, 它实际上定义了一系列的属性:</p>
<ul>
<li>loop: 实际是上面分析的loop类的一个实例</li>
<li>_watcher: cwatcher对象,也就是一个libev的ev_io对象.</li>
<li>callback: 回调函数, 注意该回调函数是由上层传递进来,它不是由libev直接<br>调用,而是由libev的回调函数调用,具体到本例就是被<br><code>gevent_callback_io</code> 调用.</li>
<li>args: 一个元组,传递给回调函数的参数</li>
</ul>
</li>
<li><p><span class="underline"><span class="underline">init</span></span>:<br>该函数会设置loop属性,同时初始化libev的io watcher对象 <code>_watcher</code> (主要做两件事:<br>指定事件类型,指定回调函数), 注意它的回调函数 是 <code>gevent_callback_io</code></p>
</li>
<li><p>start: 该函数中 会设置回调函数以及参数, 这里设置的回调函数是上层传入的, 不要和libev的回调函数混淆, 同时调用<br><code>ev_io_start</code> 将该watcher注册到 libev的事件循环中. 为了弄明白libev事件循环的过程,我接下来分析<br><code>gevent_callback_io</code>.</p>
</li>
<li><p>gevent_callback_io</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_OBJECT(PY_TYPE, EV_PTR, MEMBER)                             \</span><br><span class="hljs-meta">    ((struct PY_TYPE *)(((char *)EV_PTR) - offsetof(struct PY_TYPE, MEMBER)))</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gevent_callback_io</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ev_loop *_loop, <span class="hljs-type">void</span> *c_watcher, <span class="hljs-type">int</span> revents)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PyGeventIOObject</span>* <span class="hljs-title">watcher</span> =</span> GET_OBJECT(PyGeventIOObject, c_watcher, _watcher);<br>    gevent_callback(watcher-&gt;loop, watcher-&gt;_callback, watcher-&gt;args, (PyObject*)watcher, c_watcher, revents);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>GET_OBJECT的作用是通过结构体中某一个域的指针来获得整个结构体的指针. 如果<br>你熟悉linux内核就会发现它和container_of的功能很相似.<br>所以这里实际就是根 据cwatcher对象_watcher来获得watcher的指针, 接着就调用<br><code>gevent_callback</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gevent_callback</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PyGeventLoopObject* loop, PyObject* callback,</span><br><span class="hljs-params">                            PyObject* args, PyObject* watcher, <span class="hljs-type">void</span> *c_watcher,</span><br><span class="hljs-params">                            <span class="hljs-type">int</span> revents)</span> &#123;<br>    ......<br>    result = PyObject_Call(callback, args, <span class="hljs-literal">NULL</span>);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以该函数就调用了上层传入的callback.</p>
</li>
</ol>
</li>
</ol>
<h3 id="core的api总结"><a href="#core的api总结" class="headerlink" title="core的api总结"></a>core的api总结</h3><p>假设Loop代表类, loop代表实例</p>
<ol>
<li>loop.run: 启动事件循环</li>
<li>loop.run_callback(fun, *args): 将fun注册给loop的_prepare watcher,这样<br>fun就会在事件循环要阻塞时运行, spawn以及rawlink都会使用该方法.</li>
<li>loop.io: 创建一个IO watcher实例, 调用该实例的start方法来注册回调函数,同 时将该watcher放入事件循环.</li>
<li>loop.timer: 创建Timer Watcher对象</li>
<li>loop.signal: 创建signal Watcher对象</li>
<li>loop.idle:</li>
<li>loop.prepare:</li>
<li>loop.fork:</li>
</ol>
<p><strong>注意使用io,timer, signal</strong> 等方法创建watcher对象后, 必须调用该对象start方法<br>才能将watcher注册到事件循环中</p>
<h2 id="HUB"><a href="#HUB" class="headerlink" title="HUB"></a>HUB</h2><p>这实际上是greenlet的子类,所以它的每一个实例实际上就代表一个协程,这个类创建的 协程是专门用来运行事件循环的.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hub</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    ...<br><br>    NOT_ERROR = (GreenletExit, SystemExit)<br>    loop_class = config(<span class="hljs-string">&#x27;gevent.core.loop&#x27;</span>, <span class="hljs-string">&#x27;GEVENT_LOOP&#x27;</span>)<br>    ...<br>    backend = config(<span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;GEVENT_BACKEND&#x27;</span>)<br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, loop=<span class="hljs-literal">None</span>, default=<span class="hljs-literal">None</span></span>):<br>        greenlet.__init__(self)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(loop, <span class="hljs-string">&#x27;run&#x27;</span>):<br>           ...<br>        <span class="hljs-keyword">else</span>:<br>            ...<br>            loop_class = _<span class="hljs-keyword">import</span>(self.loop_class)<br>            <span class="hljs-keyword">if</span> loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                loop = self.backend<br>            self.loop = loop_class(flags=loop, default=default)<br>        ...<br></code></pre></td></tr></table></figure>

<p>创建一个hub实例, 这个实例最重要的就是loop属性,这个实际就是core模块的loop类的 实例,也就是说是libev的事件循环的封装.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">assert</span> self <span class="hljs-keyword">is</span> getcurrent(), <span class="hljs-string">&#x27;Do not call Hub.run() directly&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        loop = self.loop<br>        loop.error_handler = self<br>        <span class="hljs-keyword">try</span>:<br>            loop.run()<br>        <span class="hljs-keyword">finally</span>:<br>            loop.error_handler = <span class="hljs-literal">None</span>  <span class="hljs-comment"># break the refcount cycle</span><br>        self.parent.throw(LoopExit(<span class="hljs-string">&#x27;This operation would block forever&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p>这个方法就是协程的入口函数,它内部实际是一个循环, 这个循环就是用来启动libev的 事件循环的. 该函数一般是在调用 <code>hub.switch</code><br>时开始运行的.</p>
<h3 id="Waiter"><a href="#Waiter" class="headerlink" title="Waiter"></a>Waiter</h3><p>协程间的通信机制.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Waiter</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, hub=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> hub <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.hub = get_hub()<br>        <span class="hljs-keyword">else</span>:<br>            self.hub = hub<br>        self.greenlet = <span class="hljs-literal">None</span><br>        self.value = <span class="hljs-literal">None</span><br>        self._exception = _NONE<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;If a value/an exception is stored, return/raise it. Otherwise until switch() or throw() is called.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _NONE:<br>            <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> self.value<br>            <span class="hljs-keyword">else</span>:<br>                getcurrent().throw(*self._exception)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> self.greenlet <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;This Waiter is already used by %r&#x27;</span> % (self.greenlet, )<br>            self.greenlet = getcurrent()<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">return</span> self.hub.switch()<br>            <span class="hljs-keyword">finally</span>:<br>                self.greenlet = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">switch</span>(<span class="hljs-params">self, value=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Switch to the greenlet if one&#x27;s available. Otherwise store the value.&quot;&quot;&quot;</span><br>        greenlet = self.greenlet<br>        <span class="hljs-keyword">if</span> greenlet <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.value = value<br>            self._exception = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> getcurrent() <span class="hljs-keyword">is</span> self.hub, <span class="hljs-string">&quot;Can only use Waiter.switch method from the Hub greenlet&quot;</span><br>            switch = greenlet.switch<br>            <span class="hljs-keyword">try</span>:<br>                switch(value)<br>            <span class="hljs-keyword">except</span>:<br>                self.hub.handle_error(switch, *sys.exc_info())<br><br></code></pre></td></tr></table></figure>

<p>该类的实例有一个value属性, 一个_expception属性, 一个get方法,一个switch方法,他 们的行为是这样的:</p>
<ol>
<li>get: 当你在一个协程中调用get方法时, 它会先检查_exception的值,如果不为默 认的_NONE,<br>那么它就会根据value属性的值来决定是返回value的值还是抛出异 常,<br>如果_exception为默认值, 它会设置greenlet属性为当前的协程对象,接着就 会切换到hub协程.</li>
<li>switch: 实际就是调用Waiter对象的greenlet属性的switch方法, 这样就切换到 了对应的协程.<br>一般会注册到某个watcher的回调函数. 如果greenlet属性为<br>None,那么意味着switch在get之前运行了,那么就简单的设置下value以<br>及_exception属性.</li>
</ol>
<p><strong>需要等待的协程调用get方法,这样该协程就会挂起, 其他的协程调用switch方法切换 到因等待而挂起的协程</strong>,<br>我们来看看Waiter的一个使用例子, Hub的wait方法的代 码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hub</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">self, watcher</span>):<br>        waiter = Waiter()<br>        unique = <span class="hljs-built_in">object</span>()<br>        watcher.start(waiter.switch, unique)<br>        <span class="hljs-keyword">try</span>:<br>            result = waiter.get()<br>            <span class="hljs-keyword">assert</span> result <span class="hljs-keyword">is</span> unique, <span class="hljs-string">&#x27;Invalid switch into %s: %r (expected %r)&#x27;</span> % (getcurrent(), result, unique)<br>        <span class="hljs-keyword">finally</span>:<br>            watcher.stop()<br>    ...<br></code></pre></td></tr></table></figure>

<p><strong>wait方法的作用是挂起当前的协程,直到watcher监听的事件就绪</strong>.它创建一个<br>Waiter实例waiter,接着将waiter的switch方法注册到wacher上,这样当watcher监听的<br>事件就绪后就会调用实例的switch方法,接着就调用waiter的get方法, 根据watcher监<br>听的事件就绪的快慢,这里有两种可能:</p>
<ol>
<li><strong>get在switch之前运行</strong>: get会设置waiter的greenlet属性为当前执行的协程, 接着 切换到hub,<br>当将来某个时候事件就绪,那么调用waiter的switch,switch会调用<br>greenlet属性的switch方法,这样就切换回了当前运行的协程.</li>
<li><strong>get在switch之后运行</strong>: 这种情况比较少见,可是也是存在的, 这种情况下运行<br>switch时,waiter对象的greenlet属性为None, 所以switch方法只是简单的设置<br>waiter的value属性, 接着调用get会直接返回value属性,而不阻塞.注意不要弄 混_NONE与None.</li>
</ol>
<h2 id="Greenlet"><a href="#Greenlet" class="headerlink" title="Greenlet"></a>Greenlet</h2><p>这也是一个greenlet的子类,它也是用来产生协程的, 我们先来看看我们创建协程时常 用的spawn函数的源码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greenlet</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run=<span class="hljs-literal">None</span>, *args, **kwargs</span>):<br>        hub = get_hub()<br>        greenlet.__init__(self, parent=hub)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return a new :class:`Greenlet` object, scheduled to start.</span><br><span class="hljs-string">        The arguments are passed to :meth:`Greenlet.__init__`.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        g = cls(*args, **kwargs)<br>        g.start()<br>        <span class="hljs-keyword">return</span> g<br></code></pre></td></tr></table></figure>

<p>gevent.spawn实际就是Greenlet类的spawn方法,该方法直接创建一个Greenlet实例,注<br>意该实例的parent是hub,而不是默认的主协程, 这样的用处是当协程完成退出时,程序<br>会继续执行hub的事件循环.然后调用实例的start方法, 下面看看start方法的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Schedule the greenlet to run in this loop iteration&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> self._start_event <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        self._start_event = self.parent.loop.run_callback(self.switch)<br></code></pre></td></tr></table></figure>

<p>start方法实际上就是把该实例丢到hub协程的循环当中,也就是说这个新建的协程就可 以被hub调度了.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_callback</span>(<span class="hljs-params">self, func, *args</span>):<br>    CHECK_LOOP2(self)<br>    cdef callback cb = callback(func, args)<br>    self._callbacks.append(cb)<br>    libev.ev_ref(self._ptr)<br>    <span class="hljs-keyword">return</span> cb<br></code></pre></td></tr></table></figure>

<p>上面的代码先创建一个callback实例cb,接着将这个实例放进_callbacks列表中, 在core<br>部分我们分析了_callbacks列表的所有callback实例都会被_prepare watcher的回调<br>函数 <code>gevent_run_callbacks</code> 运行, 这样实际就是启动了协程.</p>
<h2 id="socket模块"><a href="#socket模块" class="headerlink" title="socket模块"></a>socket模块</h2><p>我们知道为了发挥协程的威力, 我们不能使用标准socket库,必须使用gevent实现的 socket库,<br>现在我们来分析一下gevent的socket模块,看看该模块是如何使用协程的,<br>我这里以socket的recv方法为例. 假设调用recv方法的协程为gr.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">socket</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, family=AF_INET, <span class="hljs-built_in">type</span>=SOCK_STREAM, proto=<span class="hljs-number">0</span>, _sock=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> _sock <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._sock = _realsocket(family, <span class="hljs-built_in">type</span>, proto)<br>            self.timeout = _socket.getdefaulttimeout()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(_sock, <span class="hljs-string">&#x27;_sock&#x27;</span>):<br>                self._sock = _sock._sock<br>                self.timeout = <span class="hljs-built_in">getattr</span>(_sock, <span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-literal">False</span>)<br>                <span class="hljs-keyword">if</span> self.timeout <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                    self.timeout = _socket.getdefaulttimeout()<br>            <span class="hljs-keyword">else</span>:<br>                self._sock = _sock<br>                self.timeout = _socket.getdefaulttimeout()<br>        self._sock.setblocking(<span class="hljs-number">0</span>)<br>        fileno = self._sock.fileno()<br>        self.hub = get_hub()<br>        io = self.hub.loop.io<br>        self._read_event = io(fileno, <span class="hljs-number">1</span>)<br>        self._write_event = io(fileno, <span class="hljs-number">2</span>)<br><br></code></pre></td></tr></table></figure>

<p>__init__很简单,创建一个socket(self._sock),将该描述符设置为非阻塞,同时创建两个<br>watcher,分别监听读事件(self._read_event)以及写事件(self._write_event),下面<br>看看recv的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv</span>(<span class="hljs-params">self, *args</span>):<br>    sock = self._sock  <span class="hljs-comment"># keeping the reference so that fd is not closed during waiting</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> sock.recv(*args)<br>        <span class="hljs-keyword">except</span> error:<br>            ex = sys.exc_info()[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> ex.args[<span class="hljs-number">0</span>] != EWOULDBLOCK <span class="hljs-keyword">or</span> self.timeout == <span class="hljs-number">0.0</span>:<br>                <span class="hljs-keyword">raise</span><br>            <span class="hljs-comment"># QQQ without clearing exc_info test__refcount.test_clean_exit fails</span><br>            sys.exc_clear()<br>        self._wait(self._read_event)<br></code></pre></td></tr></table></figure>

<p>recv直接调用内置模块的recv方法,如果发现该调用会阻塞,那么就调用_wait方法, 该 方法也是代码的关键部分.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_wait</span>(<span class="hljs-params">self, watcher, timeout_exc=timeout(<span class="hljs-params"><span class="hljs-string">&#x27;timed out&#x27;</span></span>)</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Block the current greenlet until *watcher* has pending events.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If *timeout* is non-negative, then *timeout_exc* is raised after *timeout* second has passed.</span><br><span class="hljs-string">    By default *timeout_exc* is ``socket.timeout(&#x27;timed out&#x27;)``.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If :func:`cancel_wait` is called, raise ``socket.error(EBADF, &#x27;File descriptor was closed in another greenlet&#x27;)``.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">assert</span> watcher.callback <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;This socket is already used by another greenlet: %r&#x27;</span> % (watcher.callback, )<br>    <span class="hljs-keyword">if</span> self.timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        timeout = Timeout.start_new(self.timeout, timeout_exc, ref=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">else</span>:<br>        timeout = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">try</span>:<br>        self.hub.wait(watcher)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout.cancel()<br></code></pre></td></tr></table></figure>

<p>根据注释我们知道_wait方法会使当前的协程暂停,直到watcher监听的事件就绪. 代码的 关键部分是<br><code>self.hub.wait(watcher)</code>, 这个方法在上面已经分析过,只要明白它会阻 塞当前的协程切换到hub协程,<br>而如果watcher监听的事件就绪,它又会切换会当前协程,<br>在recv的例子中,一旦wacher监听的事件就绪也就意味着socket已经处于读就绪状态,所<br>以也就可以调用内置的socket模块的recv方法来获得数据了.</p>
<h2 id="timeout模块"><a href="#timeout模块" class="headerlink" title="timeout模块"></a>timeout模块</h2><p>该模块实现了一个超时机制, 它先挂起当前的协程, 当指定的时间到了之后,它会切换 到该协程,并且在该协程中抛出异常. 这样就实现了挂起协程的目的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timeout</span>(<span class="hljs-title class_ inherited__">BaseException</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, seconds=<span class="hljs-literal">None</span>, exception=<span class="hljs-literal">None</span>, ref=<span class="hljs-literal">True</span>, priority=-<span class="hljs-number">1</span></span>):<br>        self.seconds = seconds<br>        self.exception = exception<br>        self.timer = get_hub().loop.timer(seconds <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>, ref=ref, priority=priority)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Schedule the timeout.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self.pending, <span class="hljs-string">&#x27;%r is already started; to restart it, cancel it first&#x27;</span> % self<br>        <span class="hljs-keyword">if</span> self.seconds <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># &quot;fake&quot; timeout (never expires)</span><br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">elif</span> self.exception <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> self.exception <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(self.exception, string_types):<br>            <span class="hljs-comment"># timeout that raises self</span><br>            self.timer.start(getcurrent().throw, self)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># regular timeout with user-provided exception</span><br>            self.timer.start(getcurrent().throw, self.exception)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_new</span>(<span class="hljs-params">cls, timeout=<span class="hljs-literal">None</span>, exception=<span class="hljs-literal">None</span>, ref=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(timeout, Timeout):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> timeout.pending:<br>                timeout.start()<br>            <span class="hljs-keyword">return</span> timeout<br>        timeout = cls(timeout, exception, ref=ref)<br>        timeout.start()<br>        <span class="hljs-keyword">return</span> timeout<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pending</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return True if the timeout is scheduled to be raised.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.timer.pending <span class="hljs-keyword">or</span> self.timer.active<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cancel</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;If the timeout is pending, cancel it. Otherwise, do nothing.&quot;&quot;&quot;</span><br>        self.timer.stop()<br><br></code></pre></td></tr></table></figure>

<p>先看__init__, 它为实例创建了如下属性:</p>
<ol>
<li>seconds: 超时的秒数, 如果为None,那么永不超时</li>
<li>exception: 超时抛出的异常,如果为None,那么就抛出self本身</li>
<li>timer: 一个timer watcher</li>
</ol>
<p>在来看start, 它分为三种情况:</p>
<ol>
<li>self.second为None: 那么直接pass, 这就意味者timer没有注册到时间循环中,所 以也就永远不会超时</li>
<li>self.exception为None: 它会将 <code>getcurrent().throw</code> 注册为timer的回调函数,<br>我们知道协程对象的throw方法和switch是相似的,都会切换到对应协程,只是throw<br>在切换到对应协程后会立刻将它的参数作为异常抛出, 所以一旦超时,那么就会切 换到当前协程,然后抛出self</li>
<li>self.exception不为None, 和2相似,只是超时会抛出self.exception而不是self本 身.</li>
</ol>
<p>start_new是一个包装函数, 正常情况下你要先创建一个timeout实例,然后调用该实例 的start方法,<br>现在你只需要调用这个方法它就会把这两步一起搞定.</p>
<h3 id="timeout使用指南"><a href="#timeout使用指南" class="headerlink" title="timeout使用指南"></a>timeout使用指南</h3><p>一般情况下timeout都是这样使用的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">timeout = Timeout(seconds, exception)<br>timeout.start()<br><span class="hljs-keyword">try</span>:<br>    ...  <span class="hljs-comment"># exception will be raised here, after *seconds* passed since start() call</span><br><span class="hljs-keyword">finally</span>:<br>    timeout.cancel()<br></code></pre></td></tr></table></figure>

<p>最开始的两行可以用Timeout.start_new代替, 在try中间我们一般会切换到其它的协 程,<br>当超时后会自动切换回来,并且抛出异常,这样try就可以捕捉到了.来看看一个更<br>具体的例子,event.py中的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">timer = Timeout.start_new(timeout)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">try</span>:<br>        result = self.hub.switch()<br>        <span class="hljs-keyword">assert</span> result <span class="hljs-keyword">is</span> self, <span class="hljs-string">&#x27;Invalid switch into Event.wait(): %r&#x27;</span> % (result, )<br>    <span class="hljs-keyword">except</span> Timeout <span class="hljs-keyword">as</span> ex:<br>        <span class="hljs-keyword">if</span> ex <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> timer:<br>            <span class="hljs-keyword">raise</span><br><span class="hljs-keyword">finally</span>:<br>    timer.cancel()<br></code></pre></td></tr></table></figure>

<p>很显然的例子.</p>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>该模块的Event实现了协程间的通知机制, 也就是一个协程可以唤醒监听该event的所 有协程.</p>
<h3 id="Event使用指南"><a href="#Event使用指南" class="headerlink" title="Event使用指南"></a>Event使用指南</h3><p>在一个协程中创建event对象,并调用该对象的wait方法,这样该协程就会阻塞,直到另 外一个协程调用了该event对象的set方法,代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># greenlet1</span><br>evt = Event()<br>evt.wait()                <span class="hljs-comment"># block until other greenlets invoke evt.set()</span><br><br><span class="hljs-comment"># greenlet2</span><br>evt.<span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure>

<h2 id="AsycResult"><a href="#AsycResult" class="headerlink" title="AsycResult"></a>AsycResult</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h3 id="channel使用指南"><a href="#channel使用指南" class="headerlink" title="channel使用指南"></a>channel使用指南</h3><p>和go语言的channel类似,只是没有缓存也没有类型信息,如果要缓存,那么可能queue 更合适</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># greenlet1</span><br>chan = Channel()<br>val = chan.get()<br><br><span class="hljs-comment"># greenlet2</span><br>chan.put(val)<br></code></pre></td></tr></table></figure>

<p>使用方法也是两个协程配合, 一个读一个写,如果channel未就绪,那么相应的读或者 写就会阻塞执行该操作的的这个协程.</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>在Greenlet类的join函数中有如下代码：</p>
<figure class="highlight python"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">switch = getcurrent().switch<br>self.rawlink(switch)<br><br>result = self.parent.switch()<br></code></pre></td></tr></table></figure>

<p>rawlink的作用是注册一个函数，这个函数会在这个greenlet运行完成后调用</p>
<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><p>gevent不像go一样是官方内置的，所以有些时候和第三方库配合会有一些问题，总的来说 python写成的库可以直接monkey<br>patch，C写成的库可以直接用豆瓣开源的greenify来打 patch。</p>
<h2 id="greenify"><a href="#greenify" class="headerlink" title="greenify"></a>greenify</h2><p>这个库可以将C扩展打patch，这样可以让他们兼容gevent，它直接工作于二进制文件这一级，<br>不需要你修改C扩展代码，目前只支持ELF文件格式。他会自动的对网络相关的代码来patch。</p>
<h2 id="PyMongo"><a href="#PyMongo" class="headerlink" title="PyMongo"></a>PyMongo</h2><p>有几个注意事项。</p>
<ol>
<li>只初始化一个 <code>pymongo.Connection</code> 对象，最好把这个弄成一个模块级或者全局变量，<br>库的内部由pool，所以你不用操心。</li>
<li>至少要monkey patch掉socket和threading模块</li>
<li>要调用 <code>end_request</code> 来将连接归还到pool中。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/articles/">articles</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/gevent/">gevent</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/articles/mxnet-engine/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MXNET Dependency Engine</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/articles/defects-of-python/">
                        <span class="hidden-mobile">python的“缺点”</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://yuyang0.github.io/articles/gevent/';
          this.page.identifier = '/articles/gevent/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'yuyang' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>














  
<script src="/js/custom.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
