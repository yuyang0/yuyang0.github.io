<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>database</title>
    <link href="/2022/05/08/notes/database/"/>
    <url>/2022/05/08/notes/database/</url>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务有四个特性(ACID):</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>也就是说不能破坏数据库的某种约定，比如经典的银行转账问题中，从账户A转100元到账户<br>B，那么一致性要求两个账户的金额的和要是相同的，数据库不应该让用户看到事务执行的<br>中间状态, 也就是说不能让用户看到A账户减了100元，但是B账户还没有增加100元这样的中<br>间状态，一致性有些需要数据库保证，有些则需要应用保证。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>只是用来保证事务中的操作完全成功或者全部失败，不可能一部分成功一部分失败</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>一个事务如果已经提交成功，那么不管数据库出现什么问题，事务所做的修改都不应该丢失</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>实际上ACD就已经可以保证一个事务的正常执行，但是ACD可能使数据库非常的低效，所以就<br>引入了隔离级别，隔离性和一致性是一对矛盾的指标，在最低的隔离等级下，用户是有可能<br>读到脏数据的，也就是说读到事务的中间状态，这实际就是说在最低的隔离等级下，数据库 是不满足一致性的。数据库的隔离级别如下：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read committed</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable read</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>Snapshot</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Serializable</td><td>No</td><td>No</td><td>No</td></tr></tbody></table><ul><li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li><li>可重复读(Repeated<br>Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li><li>快照隔离(Snapshot):<br>在事务开始时获得一个快照，事务中的所有read都是读该快照，通常通过MVCC实现，所以它没有脏读，不可重复读以及幻读的问题，它能够处理写写冲突，它主要的问题是写偏斜（write<br>skew），<br>也就是说两个事务读取相同的数据项，但是更新不同的数据项，比如某人有两个账户，每个账户100元，银行要求两个账户的余额之和大于等于0，那么就会有这种情况出现：<br>T1，T2两个事务同时读取两个账户余额，接着都取出200元，T1更新第一个账户，T2更新第二个账户，这样就会出问题。</li><li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul><h3 id="快照隔离"><a href="#快照隔离" class="headerlink" title="快照隔离"></a>快照隔离</h3><p>快照隔离基本都是通过MVCC实现。</p><ol><li><p>正确性保证：</p><ol><li>Consistent Snapshot：所谓Consistent，即快照包含且仅包含Commit先于SnapshotTS的所有事务</li><li>Commit Total Order：所有事务提交构成一个全序关系，每次提交都会生成一个快照，由<code>CommitTS</code>标识</li><li>Write-Write Conflict: 事务Ti和Tj有冲突，即它们WriteSet有交集，且<code>[SnapshotTS, CommitTS]</code>有交集</li></ol></li><li><p>单机实现</p><p>一个简单的KV单机存储上实现快照隔离的方法：</p><ol><li>事务开始时生成一个唯一的事务号，数据的版本号就是事务号</li><li>数据Key都带上版本号，一般直接把版本号放到key的末尾，encode的时候要保证顺序一致</li><li>事务开始时要记录当前活跃的事务号</li><li>快照读取就是在key(包括当前的版本号）上从后往前scan，忽略掉第三步记录的活跃的事务号（这样可以避免脏读）</li><li>写入时要检测有没有写写冲突，可以从活跃的最小事务号开始，从前往后scan，看有没有事务对相同的key有写入，有的话就返回错误</li><li>每个update都需要记录，用于回滚。</li></ol></li></ol><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>percolator和Omid比较常见，它们都实现了SI(快照隔离)，上述事务的实现会有两个版本号：startTS和commitTS，有如下规则</p><ol><li>startTS一般就是事务开始时分配的事务号</li><li>有了startTS之后，客户端就可以获得snapshot(Snapshot必须要能读到所有commitTS&lt;startTS的数据)，这样客户端可以从snapshot读数据，<br>并且可以计算出哪些数据需要写入(writeSet)，也就是说主要的计算在客户端完成</li><li>客户端完成计算后接着获得commitTS, 然后进入提交流程，此时要检测写写冲突</li></ol><p>写写冲突检测，符合下面两个条件意味着冲突：</p><ol><li>T1和T2的[startTS, commitTS]有重叠</li><li>T1和T2的writeSet有重叠</li></ol><h3 id="percolator"><a href="#percolator" class="headerlink" title="percolator"></a>percolator</h3><p>tikv中的实现，将rocksdb分成3个column family：</p><ol><li>CF_DEFAULT: (key, start_ts) -&gt; value</li><li>CF_LOCK: key -&gt; lock_info</li><li>CF_WRITE: (key, commit_ts) -&gt;<br>write_info</li></ol><p>详细流程如下</p><ol><li>客户端从TSO获得startTS，然后进行本地计算得到要写入的rows，快照读取的流程如下:<ul><li>读取key的lock_info,<br>如果存在并且lock_info中startts小于当前的startts,<br>这时候需要重试，因为可能存在write too late的情况，<br>也就是说一个事务已经获得了commit_ts,<br>并且<code>commit_ts&lt; start_ts</code>,<br>但是因为种种原因它目前还没有提交，所以目前读不到该事务的数据，但是<br>快照读要求读到所有commit_ts&lt;start_ts的事务的数据，所以这种情况只能等待该事务commit后，也就是重试。</li><li>从CF_WRITE中读取committs&lt;start_ts的writeinfo</li><li>从 write_info 中拿到 start_ts</li><li>从CF_DEFAULT中读取上一步的startts为版本的数据。</li></ul></li><li>Prewrite阶段：从要写入的rows中选一个primaryRow，剩下的都是secondary row<ol><li>primaryRow加锁：在CF_LOCK中为primaryRow的key写入lockinfo(内容为startTS)，并且要做冲突检测，一方面是是否有其它事务已加锁该row，<br>同时要检测<code>[startTS, +inf]</code>范围有没有数据,<br>如果没有冲突就在CF_DEFAULT中把数据写入（数据的版本是startTS）</li><li>secondary<br>row加锁，lock_info的内容是startTS以及primaryRow的信息。冲突检测是一样的，加锁成功就把数据写入</li></ol></li><li>Commit阶段<ol><li>从TSO获得commit_ts</li><li>删掉primaryRow的锁，同时在CF_WRITE中为primaryRow的key写入writeinfo(版本号为commit_ts,<br>内容为start_ts).</li><li>为secondary rows重复第2步</li></ol></li></ol><p>crash 恢复 如果某个事务T1读一行数据发现有锁，那么意味着存在事务T0，T0的状态如下：</p><ol><li>根据lock_info的内容查找primaryRow，如果primaryRow的对应版本无锁，并且write_info内容正常，那么T0事务已提交，所以去掉锁，更新write_info</li><li>如果primaryRow的锁消失，并且没有write_info,或者primaryRow干脆不存在，那么T0事务回滚了，那么直接删掉这一行就好</li><li>如果primaryRow的锁的过去很久了，那么该事务在commit或者rollback之前就crash了，那么直接回滚事务T0</li><li>其它情况都认为T0事务正在执行，所以等待T0 commit或者rollback， 然后重启T1</li></ol><h3 id="Omid"><a href="#Omid" class="headerlink" title="Omid"></a>Omid</h3><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC协议主要是用于分布式事务，用于保证作用于多节点的的操作的原子性</p><h1 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h1><p>分布式一致性算法是用于保证多副本的一致性。主要用于多节点复制数据</p><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2><p>主要拆解成4个问题：</p><h3 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h3><p>3个角色：leader, follower, canidate follower一段时间没收到心跳就会进入选主：</p><ol><li>Term+1变为candidate， 并且给自己投一票，接着给集群其它节点发送RequestVote RPC.</li><li>其它节点收到RequestVote，如果Term高于自身的Term，那么修改自身的Term，并且投一票，记住一个Node的一个Term只允许投一票</li><li>如果收到半数节点同意RequestVote，那么成为leader</li></ol><p>边界问题：</p><ol><li>网络分裂，如果follower处在leader的不同的一边，为了避免一定无法成功的选主，可以在follower的心跳超时时先试着联系集群半数的节点，只有连接成功才进入选主流程</li><li>为了避免选主票数分裂，这里需要对选主超时做一下随机化。</li></ol><!-- end list --><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>要保证日志一致性，需要满足下面两点：</p><ol><li>日志只能从leader流向follower</li><li>选主时必须保证新leader有最新的日志</li></ol><!-- end list --><h3 id="日志安全性"><a href="#日志安全性" class="headerlink" title="日志安全性"></a>日志安全性</h3><h3 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h3><p>一定要用两阶段变更，因为如果直接变更可能选出两个leader，比如从3个节点变成5个节点，某个时间点1 2是旧配置(认为集群只有三个节点)，3<br>4 5时新配置(认为集群有5个节点)， 那么1 2可以选出一个leader，3 4 5也可以选出一个leader。</p><h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><ol><li>读放大：每一次读需要多少磁盘IO（disk read)</li><li>写放大：当只需要写入1byte时，存储系统实际写入了n byte,那么写入放大就是n</li><li>空间放大：实际占用的磁盘空间与实际数据空间的比值，主要时一些过期数据的影响</li></ol><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><h2 id="Append-only-BTree"><a href="#Append-only-BTree" class="headerlink" title="Append-only BTree"></a>Append-only BTree</h2><h2 id="LSM"><a href="#LSM" class="headerlink" title="LSM"></a>LSM</h2><h3 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h3><ol><li><p>log file</p><p>Log file format</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs example">      +-----+-------------+--+----+----------+------+-- ... ----+<br>File  | r0  |        r1   |P | r2 |    r3    |  r4  |           |<br>      +-----+-------------+--+----+----------+------+-- ... ----+<br>      &lt;--- kBlockSize ------&gt;|&lt;-- kBlockSize ------&gt;|<br><br> rn = variable size records<br> P = Padding<br> kBlolckSize = 32kb<br></code></pre></td></tr></table></figure><p>Record format</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs example">+---------+-----------+-----------+----------------+--- ... ---+<br>|CRC (4B) | Size (2B) | Type (1B) | Log number (4B)| Payload   |<br>+---------+-----------+-----------+----------------+--- ... ---+<br>Same as above, with the addition of<br>Log number = 32bit log file number, so that we can distinguish between<br>records written by the most recent log writer vs a previous one.<br></code></pre></td></tr></table></figure></li><li><p>table file</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs example">&lt;beginning_of_file&gt;<br>[data block 1]<br>[data block 2]<br>...<br>[data block N]<br>[meta block 1]<br>...<br>[meta block K]<br>[metaindex block]<br>[index block]<br>[Footer]        (fixed size; starts at file_size - sizeof(Footer))<br>&lt;end_of_file&gt;<br></code></pre></td></tr></table></figure><ol><li>data block: 存储key，value数据，以key排序存储</li><li>meta block：一些元数据，比如filter，stat等等</li><li>metaindex block: 存储meta block的(offset, size), 每一个meta<br>block都有一条记录</li><li>index block： 存储data block的（offset，size），每一个data block都有一条记录</li></ol></li></ol><h2 id="Merge-Tree"><a href="#Merge-Tree" class="headerlink" title="Merge Tree"></a>Merge Tree</h2><p>这是clickhouse中所使用的列存储引擎</p>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>raft</tag>
      
      <tag>paxos</tag>
      
      <tag>leveldb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MXNET Dependency Engine</title>
    <link href="/2018/03/11/articles/mxnet-engine/"/>
    <url>/2018/03/11/articles/mxnet-engine/</url>
    
    <content type="html"><![CDATA[<h1 id="基本背景知识"><a href="#基本背景知识" class="headerlink" title="基本背景知识"></a>基本背景知识</h1><p>MXNET中有一个依赖引擎，这个引擎是用来分析计算过程的依赖关系，把不依赖的计算并行<br>化，以达到提高性能的目的。它的基本原理可以看官方的<a href="https://mxnet-bing.readthedocs.io/en/latest/system/note_engine.html">文档</a>。<br>简单的说就是给每一个对 象打上一个tag，这个tag叫做Var，每一个计算(op)都会依赖一个或者多个Var，依赖有两种<br>类型：写依赖和读依赖。依赖引擎为每一个Var都维护一个队列，然后根据op的依赖关系向<br>队列中添加ReadDependency和WriteDependency，当各个依赖完成后要更新队列的状态。</p><h1 id="Op"><a href="#Op" class="headerlink" title="Op"></a>Op</h1><p>Op实际上是用来代表计算过程以及它依赖的var，先来看看它的uml类图。</p><p><img src="/2018/03/11/articles/mxnet-engine/static/img/opr-class-uml.png"></p><p>上面一些比较重要的属性如下：</p><ol><li>fn： op实际要执行的函数</li><li>const_vars, mutable_vars: 依赖的var列表（读和写）。</li><li>wait: 当前还没有就绪的var的个数，它的初始值是 <code>len(const_vars)+len(mutable_vars)</code>,<br>每一个依赖就绪那么就会调用 <code>dec_wait</code> 将<br>该值减一，如果该值为0，那么所有的依赖都已就绪，那么可以丢到执行引擎执行了。</li></ol><h1 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h1><p>var可以看做是一个tag，用来标示每一个对象的，这样Op对对象的依赖可以简化成对var的<br>依赖，这样就可以构建出一个不依赖于具体的对象的通用的依赖引擎。Var是依赖引擎的关键。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2018/03/11/articles/mxnet-engine/static/img/threaded-var-class-uml.png"></p><p><strong>声明：下文说到执行时，意思是Op的当前var的依赖已经就绪，因为一个op可以依赖多个<br>var，如果其他的Var没有就绪，那么这时op可能并没有实际运行</strong></p><p>Var只是一个基类，用来统一类型系统的，主要的工作在 <code>ThreadedVar</code> 中，每一个对象都 会有一个由<br><code>VersionedVarBlock</code> 所组成的链表，这个链表就是一个FIFO队列。 <code>head_</code> 指向的是队列的尾部,<br>实际是一个哨兵(空对象)， <code>head_</code> 这个命名有误导性, <code>pending_write_</code><br>指向的是最”老”的写依赖，如果没有写依赖，那么就指向 <code>nullptr</code>, 根据依赖引擎的特点，它实际上指向的是队列的头部，<br><code>ThreadedVar</code> 的那四个方法就是 来操作这个队列的。</p><ol><li>num_pending_reads_: 代表当前正在执行(还没有执行完)的读依赖的个数</li><li>pending_write_: 代表队列中最“老”的写依赖, 它一直指向队列的头部。</li><li>head_: 队列的尾部。</li></ol><p>需要注意的是，正在执行的读依赖是不在队列中的，但是正在执行的写依赖是在队列中的。</p><h2 id="理解Var的队列"><a href="#理解Var的队列" class="headerlink" title="理解Var的队列"></a>理解Var的队列</h2><p>var的队列是依赖引擎的核心，下面我们来分析下各种情况下，如何修改队列的状态。</p><ol><li>添加读依赖: 如果前面没有写依赖，那么直接运行, 否则就插入队列的尾部(head_那一端)</li><li>添加写依赖： 直接将依赖插入队列的尾部，并检查是不是写就绪(既没有读依赖也没有 写依赖在运行),如果是写就绪，那么就运行该依赖。</li><li>读依赖完成</li><li>写依赖完成</li></ol><p><img src="/2018/03/11/articles/mxnet-engine/static/img/threaded-var-queue1.png"></p><p>上图中w1写依赖正在执行。</p><p><img src="/2018/03/11/articles/mxnet-engine/static/img/threaded-var-queue2.png"> 写依赖w1完成将自己移出队列，并执行写依赖w2</p><p><img src="/2018/03/11/articles/mxnet-engine/static/img/threaded-var-queue3.png"></p><p>写依赖w2完成后将自己移出队列，接着并行的执行读依赖r1，r2，记住正在执行的读依赖是被移出队列的， 它们的数目使用<br><code>num_pending_reads_</code> 跟踪的</p><p><img src="/2018/03/11/articles/mxnet-engine/static/img/threaded-var-queue4.png"></p><p>每一个读依赖完成都会将 <code>num_pending_reads_</code> 减一，如果减为了0，那么就意味着所有<br>的读依赖都完成了，当r1，r2都完成后，接着执行w3写依赖。</p><h2 id="添加读依赖"><a href="#添加读依赖" class="headerlink" title="添加读依赖"></a>添加读依赖</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>AppendReadDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedVar::AppendReadDependency</span><span class="hljs-params">(OprBlock* opr_block)</span> </span>&#123;<br>    std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>    <span class="hljs-keyword">if</span> (pending_write_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// invariant: is_ready_to_read()</span><br>        <span class="hljs-built_in">CHECK_GE</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// STATE CHANGE</span><br>        ++num_pending_reads_;<br>        <span class="hljs-comment">// decrease wait counter</span><br>        opr_block-&gt;<span class="hljs-built_in">decr_wait</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">auto</span>&amp;&amp; new_var_block = VersionedVarBlock::<span class="hljs-built_in">New</span>();<br>        <span class="hljs-built_in">assert</span>(head_-&gt;next == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">assert</span>(head_-&gt;trigger == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">assert</span>(head_-&gt;write == <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// append things to next.</span><br>        head_-&gt;next = new_var_block;<br>        head_-&gt;trigger = opr_block;<br>        head_ = new_var_block;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的基本思路是这样的：检查队列中有没有写依赖，这分两种情况：</p><ol><li>如果没有写依赖，那么意味着，目前该Var没有依赖在执行，或者说只有读依赖在执行，<br>所以这个新的读依赖可以直接执行，那么它没有必要添加到队列中，只需要更新<br><code>num_pending_reads_</code> 就好，当然因为该op可能还依赖别的var，所以你只能调用 <code>decr_wait</code><br>，只有当wait减为0的时候，才能开始运行。这部分代码在engine的push中。</li><li>如果有写依赖，那么读依赖必须在写依赖的后面执行，所以需要把读依赖添加到队列的 尾部。记住 <code>head_</code> 永远指向一个空的哨兵对象。</li></ol><h2 id="添加写依赖"><a href="#添加写依赖" class="headerlink" title="添加写依赖"></a>添加写依赖</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>AppendWriteDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedVar::AppendWriteDependency</span><span class="hljs-params">(OprBlock* opr_block)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span>&amp;&amp; new_var_block = VersionedVarBlock::<span class="hljs-built_in">New</span>();<br>    std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>    <span class="hljs-comment">// invariant.</span><br>    <span class="hljs-built_in">assert</span>(head_-&gt;next == <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">assert</span>(head_-&gt;trigger == <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">assert</span>(head_-&gt;write == <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// attach to head.</span><br>    head_-&gt;next = new_var_block;<br>    head_-&gt;trigger = opr_block;<br>    head_-&gt;write = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// check if it is ready to write</span><br>    <span class="hljs-keyword">if</span> (pending_write_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// invariant: is_ready_to_read()</span><br>        pending_write_ = head_;<br>        <span class="hljs-built_in">CHECK_GE</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (num_pending_reads_ == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// STATE CHANGE</span><br>            opr_block-&gt;<span class="hljs-built_in">decr_wait</span>();<br>            num_pending_reads_ = kWriteTriggered;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">CHECK_NE</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br>    &#125;<br>    head_ = new_var_block;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码的基本思路是这样的： 将该Op放入队列的尾部，接着检查该Op的依赖有没有就绪，这<br>要检查Var有没有写依赖(pending_read_&#x3D;&#x3D;nullptr)和读依赖(num_pending_read_&#x3D;&#x3D;0)的Op<br>正在执行，只有二者都没有时，才能开始运行，当然你依然要检查该Op对其他的Var的依赖<br>有没有就绪。需要注意的一点是，即便Op的Var写依赖就绪，该Op也不会从队列中移除，只<br>有该Op执行完成后才会被移除，这在CompleteWriteDependency中实现。</p><h2 id="读依赖完成"><a href="#读依赖完成" class="headerlink" title="读依赖完成"></a>读依赖完成</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>CompleteReadDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Dispatcher&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedVar::CompleteReadDependency</span><span class="hljs-params">(Dispatcher dispatcher)</span> </span>&#123;<br>    OprBlock *trigger = <span class="hljs-literal">nullptr</span>;<br>    &#123;<br>        <span class="hljs-comment">// this is lock scope</span><br>        std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>        <span class="hljs-built_in">CHECK_GT</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (--num_pending_reads_ == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pending_write_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-comment">// STATE CHANGE</span><br>                trigger = pending_write_-&gt;trigger;<br>                num_pending_reads_ = kWriteTriggered;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (trigger != <span class="hljs-literal">nullptr</span> &amp;&amp; trigger-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">dispatcher</span>(trigger);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该部分代码会在一个op运算完成后调用，代码逻辑是比较简单的，先更新 <code>num_pending_read_</code>,<br>更新后如果该值为0，那么就意味着，所有的读依赖都已经执行完成,<br>这样就检查队列，若是存在写依赖，那么该写依赖就就绪了，那么Op就可以执行了(前提是 依赖的其他var也都就绪了,<br>wait为0)。上面的dispatcher实际就是用来将Op丢入执行引擎 的，它一般是PushToExecute，这个后文会看到。</p><h2 id="写依赖完成"><a href="#写依赖完成" class="headerlink" title="写依赖完成"></a>写依赖完成</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>CompleteWriteDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Dispatcher&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ThreadedVar::CompleteWriteDependency</span><span class="hljs-params">(Dispatcher dispatcher)</span> </span>&#123;<br>  <span class="hljs-comment">// this is lock scope</span><br>  VersionedVarBlock *old_pending_write, *end_of_read_chain;<br>  OprBlock* trigger_write = <span class="hljs-literal">nullptr</span>;<br>  &#123;<br>    std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>    <span class="hljs-comment">// invariants</span><br>    <span class="hljs-built_in">assert</span>(head_-&gt;next == <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">assert</span>(pending_write_ != <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">CHECK_EQ</span>(num_pending_reads_, kWriteTriggered);<br><br>    <span class="hljs-comment">// really delete</span><br>    <span class="hljs-keyword">if</span> (to_delete_) &#123;<br>      VersionedVarBlock *head = pending_write_-&gt;next;<br>      VersionedVarBlock::<span class="hljs-built_in">Delete</span>(pending_write_);<br>      <span class="hljs-built_in">assert</span>(head_ == head);<br>      VersionedVarBlock::<span class="hljs-built_in">Delete</span>(head);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// detach pending write</span><br>    old_pending_write = pending_write_;<br>    <span class="hljs-comment">// search for chains to trigger</span><br>    end_of_read_chain = old_pending_write-&gt;next;<br>    <span class="hljs-comment">// reset to 0 pending reads</span><br>    num_pending_reads_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (end_of_read_chain != head_ &amp;&amp;<br>           end_of_read_chain-&gt;write == <span class="hljs-literal">false</span>) &#123;<br>      ++num_pending_reads_;<br>      end_of_read_chain = end_of_read_chain-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (end_of_read_chain == head_) &#123;<br>      pending_write_ = <span class="hljs-literal">nullptr</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// check if there is pending reads, if not trigger write</span><br>      <span class="hljs-built_in">assert</span>(end_of_read_chain-&gt;write == <span class="hljs-literal">true</span>);<br>      pending_write_ = end_of_read_chain;<br>      <span class="hljs-keyword">if</span> (num_pending_reads_ == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// mark write as already actived in this var</span><br>        num_pending_reads_ = kWriteTriggered;<br>        trigger_write = end_of_read_chain-&gt;trigger;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// This is outside of lock scope</span><br>  <span class="hljs-comment">// Be very carful, pending_write_ and num_pending_reads_</span><br>  <span class="hljs-comment">// can change now, do not reply ont the two variables.</span><br>  <span class="hljs-comment">// The linked list \in [old_pending_write, end_of_read_chain)</span><br>  <span class="hljs-comment">// is already detached from this Var.</span><br>  <span class="hljs-comment">// So it is safe to modify these</span><br>  VersionedVarBlock *cur_head = old_pending_write-&gt;next;<br>  VersionedVarBlock::<span class="hljs-built_in">Delete</span>(old_pending_write);<br>  <span class="hljs-comment">// dispatch all the events</span><br>  <span class="hljs-keyword">while</span> (cur_head != end_of_read_chain) &#123;<br>    <span class="hljs-keyword">if</span> (cur_head-&gt;trigger-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">dispatcher</span>(cur_head-&gt;trigger);<br>    &#125;<br>    <span class="hljs-keyword">auto</span> prev = cur_head;<br>    cur_head = cur_head-&gt;next;<br>    <span class="hljs-built_in">assert</span>(cur_head != <span class="hljs-literal">nullptr</span>);<br>    VersionedVarBlock::<span class="hljs-built_in">Delete</span>(prev);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (trigger_write != <span class="hljs-literal">nullptr</span> &amp;&amp; trigger_write-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">dispatcher</span>(trigger_write);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和读依赖完成类似，只是写依赖的后面可能跟着多个读依赖，所以需要遍历链表直到发现下 一个写依赖, 这个写依赖由<br><code>end_of_read_chain</code> 指针来表示，如果没发现写依赖，那么 该指针指向 <code>head_</code>,遍历的过程中每发现一个读依赖就将<br><code>num_pending_reads_</code> 加一， 这样当遍历结束后， <code>old_pending_write</code> 指向已经完成的写依赖，而<br><code>end_of_read_chain</code> 指向下一个写依赖或者 <code>head_</code>, 这时候有两种情况：</p><ol><li>这两个指针的中间有多个元素，很显然这是多个读依赖，第二个 <code>while</code> 循环就是用来 并行的执行这两个指针中间的读依赖的。</li><li>这两个指针之间没有元素，那么意味着没有读依赖，那么就直接执行 <code>end_of_read_chian</code> 指向的写依赖，如果该指针指向<br><code>head_</code> 那么意味着队列为空， 什么也不用做。 最后 一部分的 <code>if</code> 就是用来处理这个情况的。</li></ol><h1 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h1><p>Engine是总的调用接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadedEngine::Push</span><span class="hljs-params">(OprHandle op, Context exec_ctx, <span class="hljs-type">int</span> priority)</span> </span>&#123;<br>    ThreadedOpr* threaded_opr = ThreadedOpr::<span class="hljs-built_in">CastFromBase</span>(op);<br>    OprBlock* opr_block = OprBlock::<span class="hljs-built_in">New</span>();<br>    opr_block-&gt;opr = threaded_opr;<br><br>    opr_block-&gt;wait.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<br>                              threaded_opr-&gt;const_vars.<span class="hljs-built_in">size</span>() +<br>                              threaded_opr-&gt;mutable_vars.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>    opr_block-&gt;ctx = exec_ctx;<br>    opr_block-&gt;priority = priority;<br>    ++pending_;<br>    <span class="hljs-comment">// Add read dependencies.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;const_vars) &#123;<br>        i-&gt;<span class="hljs-built_in">AppendReadDependency</span>(opr_block);<br>    &#125;<br>    <span class="hljs-comment">// Add write dependencies.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;mutable_vars) &#123;<br>        i-&gt;<span class="hljs-built_in">AppendWriteDependency</span>(opr_block);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (opr_block-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">PushToExecute</span>(opr_block, <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码是比较清楚的，主要是 <code>AppendReadDependency</code> 和 <code>AppendWriteDependency</code> 的部<br>分，实际上就是把op加到它所依赖的Var的队列中, 最后检查wait是不是为0，如果为0，那<br>么意味着所有依赖都已经就绪，可以直接扔到执行引擎上执行了(PushToExecute),对于不同<br>的执行引擎, <code>PushToExecute</code> 的实现是不一样的。最终都会执行 <code>ExecuteOprBlock</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ExecuteOprBlock</span><span class="hljs-params">(RunContext run_ctx, OprBlock *opr_block)</span> </span>&#123;<br>    ThreadedOpr* threaded_opr = opr_block-&gt;opr;<br>    CallbackOnComplete callback = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">CreateCallback</span>(<br>        ThreadedEngine::OnCompleteStatic, threaded_opr);<br>    <span class="hljs-type">bool</span> debug_info = (engine_info_ &amp;&amp; debug_push_opr_ == opr_block);<br>    <span class="hljs-keyword">if</span> (!shutdown_phase_) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        threaded_opr-&gt;<span class="hljs-built_in">fn</span>(run_ctx, callback);<br>      &#125; <span class="hljs-built_in">catch</span>(dmlc::Error &amp;e) &#123;<br>        std::string what = e.<span class="hljs-built_in">what</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">callback</span>();<br>    &#125;<br><br>    OprBlock::<span class="hljs-built_in">Delete</span>(opr_block);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>上述代码实际就是执行op中的函数，同时在结束的时候运行 <code>OnCompleteStatic</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadedEngine::OnCompleteStatic</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    Engine *engine, <span class="hljs-type">void</span> *threaded_opr)</span> </span>&#123;<br>  <span class="hljs-built_in">static_cast</span>&lt;ThreadedEngine*&gt;(engine)-&gt;<span class="hljs-built_in">OnComplete</span>(<br>      <span class="hljs-built_in">static_cast</span>&lt;ThreadedOpr*&gt;(threaded_opr));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>显然， <code>OnCompleteStatic</code> 就是执行 OnComplete。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedEngine::OnComplete</span><span class="hljs-params">(ThreadedOpr* threaded_opr)</span> </span>&#123;<br>  <span class="hljs-comment">// Mark complete for read variables</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;const_vars) &#123;<br>    i-&gt;<span class="hljs-built_in">CompleteReadDependency</span>([<span class="hljs-keyword">this</span>](OprBlock* opr) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">PushToExecute</span>(opr, <span class="hljs-literal">false</span>);<br>      &#125;);<br>  &#125;<br>  <span class="hljs-comment">// Mark complete for write variables.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;mutable_vars) &#123;<br>    <span class="hljs-type">bool</span> debug_info = (engine_info_ &amp;&amp; debug_wait_var_ == i);<br>    <span class="hljs-keyword">if</span> (debug_info) &#123;<br>      <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Complete write dep for &quot;</span> &lt;&lt; i;<br>    &#125;<br>    <span class="hljs-type">bool</span> to_delete = i-&gt;<span class="hljs-built_in">CompleteWriteDependency</span>(<br>        [<span class="hljs-keyword">this</span>, debug_info](OprBlock* opr) &#123;<br>          <span class="hljs-keyword">if</span> (debug_info) &#123;<br>            <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;PushToExecute &quot;</span> &lt;&lt; opr;<br>            debug_push_opr_ = opr;<br>          &#125;<br>          <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">PushToExecute</span>(opr, <span class="hljs-literal">false</span>);<br>          <span class="hljs-keyword">if</span> (debug_info) &#123;<br>            <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Fin PushToExecute &quot;</span> &lt;&lt; opr;<br>          &#125;<br>        &#125;);<br>    <span class="hljs-keyword">if</span> (to_delete) &#123;<br>      ThreadedVar::<span class="hljs-built_in">Delete</span>(i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> npending;<br>  &#123;<br>    std::unique_lock&lt;std::mutex&gt; lock&#123;finished_m_&#125;;<br>    npending = --pending_;<br>  &#125;<br>  <span class="hljs-built_in">CHECK_GE</span>(npending, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (npending == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no need to grab lock when notify.</span><br>    finished_cv_.<span class="hljs-built_in">notify_all</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// delte operator if it is temperory</span><br>  <span class="hljs-keyword">if</span> (threaded_opr-&gt;temporary) &#123;<br>    ThreadedOpr::<span class="hljs-built_in">Delete</span>(threaded_opr);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个函数实际上就是Op完成后用来更新Var的队列的，在内部会调用每一个读依赖的 <code>CompleteReadDependency</code> 以及写依赖的<br><code>CompleteWriteDependency</code>, 注意上面传递给 <code>CompleteReadDependency</code> 和<br><code>CompleteWriteDependency</code> 的匿名函数(dispatcher)中主 要是调用了 <code>PushToExecute</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 <code>Push</code> 将Op的各种依赖加入相应的Var的队列，并且当依赖都满足的时候将op丢入执 行引擎执行，当执行引擎完成后，调用<br><code>Complete</code> 系列的函数来更新Var的队列,在更新队 列的过程中，它又会将依赖就绪的Op丢入执行引擎执行，这样一直循环，直到所有的计算过<br>程都完成。</p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mxnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gevent笔记与源码分析</title>
    <link href="/2018/02/11/articles/gevent/"/>
    <url>/2018/02/11/articles/gevent/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h2><p>Coroutine 也就是 corporate routine，中文名就是协程，从它的英文可以看出是协同 的例程的意思,<br>实际上这个概念和进程与线程有相似之处, 因为linux线程就是所谓的<br>轻量级进程,所以我们来比较一下进程与协程的异同:</p><ul><li><strong>相同点</strong>:二者都是可以看做是一种执行流, 该执行流可以挂起,并且在将来又可以在 你挂起的地方恢复执行,<br>这实际上都可以看做是continuation, 我们来看看当我们挂<br>起一个执行流时我们要保存的东西<ol><li><strong>栈</strong>, 因为如果你不保存栈,那么局部变量你就无法恢复,同时函数的调用链你也无 法恢复,</li><li><strong>寄存器的状态</strong>: 这好理解, 比如说EIP,如果你不保存,那么你恢复执行流就不知道 到底执行哪一条指令,<br>在比如说ESP,EBP, 如果你不保存,那么你即便有完整的栈 你也不知道怎么用.<br>这二者实际就是所谓的上下文,也可以说是continuation. 在执行流切换时必须保存 这两个东西, 内核调度进程时也是一回事.</li></ol></li><li><strong>不同点</strong>:<ol><li>执行流的调度者不同, 进程是内核调度, 而协程是在用户态调度, 也就是说进程<br>的上下文是在内核态保存恢复的,而协程是在用户态保存恢复的.<br>很显然用户态的 代价更低</li><li>进程会被抢占,而协程不会,也就是说协程如果不主动让出CPU,那么其他的协程是不<br>可能得到执行机会,这实际和早期的操作系统类似,比如DOS,<br>它有一个yield原语, 一个进程调用yield,那么它就会让出CPU, 其他的进程也就有机会执行了, 如果一<br>个进程进入了死循环,那么整个系统也就挂起了,永远无法运行其他的进程了, 但<br>对协程而言,这不是问题</li><li>对内存的占用不同,实际上协程可以只需要4K的栈就够了, 而进程占用的内存要大 的多.</li><li>从操作系统的角度讲, 多协程的程序是单线程,单进程的</li></ol></li></ul><h1 id="gevent背景知识"><a href="#gevent背景知识" class="headerlink" title="gevent背景知识"></a>gevent背景知识</h1><p>gevent用到了了libev以及greenlet还有cares,下面简单的介绍这几个库.</p><h2 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h2><p>实际是一个协程库(官方叫micro-thread), 它只提供协程本身,要在协程间切 换调度必须你在程序中手动来进行,直接上代码:</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">x, y</span>):<br>    z = gr2.switch(x+y)<br>    <span class="hljs-built_in">print</span> z<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-built_in">print</span> u<br>    gr1.switch(<span class="hljs-number">42</span>)<br><br>gr1 = greenlet(test1)<br>gr2 = greenlet(test2)<br>gr1.switch(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot; world&quot;</span>)<br></code></pre></td></tr></table></figure><p>gr1, gr2以及运行该代码的解释器本身都是协程, 协程对象的switch方法用 来切换,比如 <code>gr2.switch</code> 就是切换到gr2.</p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ol><li>greenlet(run&#x3D;None, parent&#x3D;None): 创建一个greenlet实例.</li><li>greenlet.getcurrent:</li></ol><p>实例方法与属性</p><ol><li>gr.parent:每一个协程都有一个父协程,当前协程结束后会回到父协程中执行,该 属性默认是创建该协程的协程.</li><li>gr.run: 该属性是协程实际运行的代码. run方法结束了,那么该协程也就结束了.</li><li>gr.switch(*args, **kwargs): 切换到gr协程.</li><li>gr.throw(): 切换到gr协程,接着抛出一个异常.</li></ol><h2 id="libev"><a href="#libev" class="headerlink" title="libev"></a>libev</h2><p>和libevent类似, libev是一个事件循环库,他可以监听各个file descriptor, 一旦发现 就绪就调用对应的回调函数,<br>gevent内部就是使用libev来监听socket的.为了后续理解 方便有必要对libev进行简单的了解.</p><ol><li>watcher: 实际上是用来封装各种类型的事件的,不同类型的事件会有不同类型的 watcher, 比如 <code>ev_io</code>,<br><code>ev_timer</code>, 该结构一般会有一个回调函数,当事件触发 使就会调用回调函数.<br>watcher会有两种函数(注意TYPE代表watcher类型,可以是 io, timer,<br>signal等等):<ul><li>ev_TYPE_init: 对watcher对象进行初始化, 对IO而言该函数是 <code>ev_io_init</code>,<br>对timer而言,该函数是 <code>ev_timer_init</code>.</li><li>ev_TYPE_set: 与init系列函数的区别是该函数一般不设置callback</li><li>ev_TYPE_start: 将watcher注册到事件循环中,这样就可以监听事件了.</li></ul></li><li>loop: 事件循环</li></ol><p>来看看示例代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a single header file is required</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ev.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// for puts</span></span><br><br><span class="hljs-comment">// every watcher type has its own typedef&#x27;d struct</span><br><span class="hljs-comment">// with the name ev_TYPE</span><br>ev_io stdin_watcher;<br>ev_timer timeout_watcher;<br><br><span class="hljs-comment">// all watcher callbacks have a similar signature</span><br><span class="hljs-comment">// this callback is called when data is readable on stdin</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">stdin_cb</span> <span class="hljs-params">(EV_P_ ev_io *w, <span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span> (<span class="hljs-string">&quot;stdin ready&quot;</span>);<br>    <span class="hljs-comment">// for one-shot events, one must manually stop the watcher</span><br>    <span class="hljs-comment">// with its corresponding stop function.</span><br>    ev_io_stop (EV_A_ w);<br><br>    <span class="hljs-comment">// this causes all nested ev_run&#x27;s to stop iterating</span><br>    ev_break (EV_A_ EVBREAK_ALL);<br>&#125;<br><br><span class="hljs-comment">// another callback, this time for a time-out</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">timeout_cb</span> <span class="hljs-params">(EV_P_ ev_timer *w, <span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span> (<span class="hljs-string">&quot;timeout&quot;</span>);<br>    <span class="hljs-comment">// this causes the innermost ev_run to stop iterating</span><br>    ev_break (EV_A_ EVBREAK_ONE);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// use the default event loop unless you have special needs</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span> *<span class="hljs-title">loop</span> =</span> EV_DEFAULT;<br><br>    <span class="hljs-comment">// initialise an io watcher, then start it</span><br>    <span class="hljs-comment">// this one will watch for stdin to become readable</span><br>    ev_io_init (&amp;stdin_watcher, stdin_cb, <span class="hljs-comment">/*STDIN_FILENO*/</span> <span class="hljs-number">0</span>, EV_READ);<br>    ev_io_start (loop, &amp;stdin_watcher);<br><br>    <span class="hljs-comment">// initialise a timer watcher, then start it</span><br>    <span class="hljs-comment">// simple non-repeating 5.5 second timeout</span><br>    ev_timer_init (&amp;timeout_watcher, timeout_cb, <span class="hljs-number">5.5</span>, <span class="hljs-number">0.</span>);<br>    ev_timer_start (loop, &amp;timeout_watcher);<br><br>    <span class="hljs-comment">// now wait for events to arrive</span><br>    ev_run (loop, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// break was called, so exit</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获得loop对象, 创建一个io watcher,一个timer watcher, 分别初始化(调用init函<br>数),然后调用start注册回调函数到事件循环中, 接着调用ev_run启动事件循环.</p><h1 id="gevent源码分析"><a href="#gevent源码分析" class="headerlink" title="gevent源码分析"></a>gevent源码分析</h1><p>开始之前先申明: <strong>本文分析的是gevent1.0</strong>.</p><h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>core.ppyx文件实际上是用Cython写的代码，在Makefile中有这样一行代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs example">gevent/gevent.core.c: gevent/core.ppyx gevent/libev.pxd<br>        $(PYTHON) util/cythonpp.py -o gevent.core.c gevent/core.ppyx<br>        echo                          &gt;&gt; gevent.core.c<br>        echo &#x27;#include &quot;callbacks.c&quot;&#x27; &gt;&gt; gevent.core.c<br>        mv gevent.core.* gevent/<br><br></code></pre></td></tr></table></figure><p>上面的代码告诉我们core.ppyx会先转换为gevent.core.c这个C语言文件,然后在编译成 动态链接库，它的语法基本能看懂,<br>这个模块主要是实现loop这个类, hub对象中的<br>loop就是这个类的一个对象(注意名字虽然相同但一个是类,一个对象,不要弄混),这个<br>类将libev的事件循环机制封装了起来,我们先熟悉下这个类提供的API,熟悉这些API对<br>使用gevent很有帮助,我假设lp是loop类的对象(在gevent中就是get_hub().loop)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs example">def io(self, int fd, int events, ref=True, priority=None):<br>    return io(self, fd, events, ref, priority)<br><br>def timer(self, double after, double repeat=0.0, ref=True, priority=None):<br>    return timer(self, after, repeat, ref, priority)<br><br>def signal(self, int signum, ref=True, priority=None):<br>    return signal(self, signum, ref, priority)<br><br>def idle(self, ref=True, priority=None):<br>    return idle(self, ref, priority)<br><br>def prepare(self, ref=True, priority=None):<br>    return prepare(self, ref, priority)<br><br>def fork(self, ref=True, priority=None):<br>    return fork(self, ref, priority)<br><br>def async(self, ref=True, priority=None):<br>    return async(self, ref, priority)<br></code></pre></td></tr></table></figure><p>注意上面是Cython, 上面的一系列方法实际是libev中watcher的等价物.比如你调用 <code>lp.io(fd, 1)</code>,<br>就创建了一个监听fd的read事件的watcher对象,至于其它的api都是 类似,<br>每一个watcher对象都有一个 <code>start</code> 方法, 该方法接受一个回调函数以及一系 列传递给回调函数的参数,<br>调用该方法就会将watcher对象注册到libev的事件循环上, 看下面的示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">read_watcher = lp.io(fd, <span class="hljs-number">1</span>)<br>read_watcher.start(cb, args)<br></code></pre></td></tr></table></figure><p>运行上面的两行代码,那么当fd上读就绪时,那么就会调用cb函数,并且会把args传递给<br>cb函数.在gevent中回调函数一般是协程的switch方法,<br>这样一旦调用,那么就切换到 另一个协程中去执行.</p><h3 id="core源码分析"><a href="#core源码分析" class="headerlink" title="core源码分析"></a>core源码分析</h3><p>这一节来分析core.ppyx的源码, 在一次提醒你注意,代码是Cython, 我对Cython也不 太熟,但是代码大致能看懂.<br>同时要明白该模块是对libev的封装, libev中loop,<br>watcher,callback在该模块中都有对应物, 所以你要注意当提到loop时,我们到底是<br>该模块的loop还是libev的loop.</p><ol><li><p>先看callback</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs example">cdef public class callback [object PyGeventCallbackObject, type PyGeventCallback_Type]:<br>    cdef public object callback<br>    cdef public tuple args<br><br>    def __init__(self, callback, args):<br>        self.callback = callback<br>        self.args = args<br><br>    def stop(self):<br>        self.callback = None<br>        self.args = None<br></code></pre></td></tr></table></figure><p>实际上就是把回调函数以及要提供给回调函数的参数封装了起来.</p></li><li><p>loop: 事件循环的封装.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs example">cdef public class loop [object PyGeventLoopObject, type PyGeventLoop_Type]:<br>    cdef libev.ev_loop* _ptr<br>    cdef public object error_handler<br>    cdef libev.ev_prepare _prepare<br>    cdef public list _callbacks<br>    cdef libev.ev_timer _timer0<br><br>    def __init__(self, object flags=None, object default=None, size_t ptr=0):<br>        cdef unsigned int c_flags<br>        cdef object old_handler = None<br>        libev.ev_prepare_init(&amp;self._prepare, &lt;void*&gt;gevent_run_callbacks)<br>        libev.ev_timer_init(&amp;self._timer0, &lt;void*&gt;gevent_noop, 0.0, 0.0)<br>        if ptr:<br>            self._ptr = &lt;libev.ev_loop*&gt;ptr<br>        else:<br>            ......<br><br>        self._callbacks = []<br></code></pre></td></tr></table></figure><ol><li>_ptr: libev的一个ev_loop对象.</li><li>_prepare: libev中的prepare watcher,该watcher注册的回调函数会在事件循环进 入阻塞时调用,<br>从代码中可以看到注册的回调函数是 <code>gevent_run_callbacks</code>, 该函数会运行 <code>_callbacks</code><br>列表中的每一个callback实例.</li><li>_callbacks: 一个列表,实际上当你使用gevent的spawn创建协程时, spawn会在<br>该列表中插入一个callback实例, 该实例的回调函数实际就是你创建的<br>greenlet的switch方法, 这样当 <code>_prepare</code> watcher就绪时,新的协程就有了 启动的机会.</li></ol></li><li><p>watcher: 这是libev的watcher对象的封装,作为例子,我只分析io这一个例 子,timer,signal等等都是相似的,<br>为了方便我使用cwatcher来指代libev中的 watcher.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>#define WATCHER_BASE(TYPE)                                            \<br>    cdef public loop loop                                             \<br>    cdef object _callback                                             \<br>    cdef public tuple args                                            \<br>    cdef readonly int _flags                                          \<br>    cdef libev.ev_##TYPE _watcher                                     \<br><br>cdef public class io(watcher) [object PyGeventIOObject, type PyGeventIO_Type]:<br><br>    WATCHER_BASE(io)<br><br>    def start(self, object callback, *args, pass_events=False):<br>        CHECK_LOOP2(self.loop)<br>        if callback is None:<br>            raise TypeError(&#x27;callback must be callable, not None&#x27;)<br>        self.callback = callback<br>        if pass_events:<br>            self.args = (GEVENT_CORE_EVENTS, ) + args<br>        else:<br>            self.args = args<br>        LIBEV_UNREF<br>        libev.ev_io_start(self.loop._ptr, &amp;self._watcher)<br><br>    def __init__(self, loop loop, int fd, int events, ref=True, priority=None):<br>        if fd &lt; 0:<br>            raise ValueError(&#x27;fd must be non-negative: %r&#x27; % fd)<br>        if events &amp; ~(libev.EV__IOFDSET | libev.EV_READ | libev.EV_WRITE):<br>            raise ValueError(&#x27;illegal event mask: %r&#x27; % events)<br>        libev.ev_io_init(&amp;self._watcher, &lt;void *&gt;gevent_callback_io, fd, events)<br>        self.loop = loop<br>        if ref:<br>            self._flags = 0<br>        else:<br>            self._flags = 4<br>        if priority is not None:<br>            libev.ev_set_priority(&amp;self._watcher, priority)<br></code></pre></td></tr></table></figure><ol><li><p>WATCH_BASE, 它实际上定义了一系列的属性:</p><ul><li>loop: 实际是上面分析的loop类的一个实例</li><li>_watcher: cwatcher对象,也就是一个libev的ev_io对象.</li><li>callback: 回调函数, 注意该回调函数是由上层传递进来,它不是由libev直接<br>调用,而是由libev的回调函数调用,具体到本例就是被<br><code>gevent_callback_io</code> 调用.</li><li>args: 一个元组,传递给回调函数的参数</li></ul></li><li><p><span class="underline"><span class="underline">init</span></span>:<br>该函数会设置loop属性,同时初始化libev的io watcher对象 <code>_watcher</code> (主要做两件事:<br>指定事件类型,指定回调函数), 注意它的回调函数 是 <code>gevent_callback_io</code></p></li><li><p>start: 该函数中 会设置回调函数以及参数, 这里设置的回调函数是上层传入的, 不要和libev的回调函数混淆, 同时调用<br><code>ev_io_start</code> 将该watcher注册到 libev的事件循环中. 为了弄明白libev事件循环的过程,我接下来分析<br><code>gevent_callback_io</code>.</p></li><li><p>gevent_callback_io</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_OBJECT(PY_TYPE, EV_PTR, MEMBER)                             \</span><br><span class="hljs-meta">    ((struct PY_TYPE *)(((char *)EV_PTR) - offsetof(struct PY_TYPE, MEMBER)))</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gevent_callback_io</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ev_loop *_loop, <span class="hljs-type">void</span> *c_watcher, <span class="hljs-type">int</span> revents)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PyGeventIOObject</span>* <span class="hljs-title">watcher</span> =</span> GET_OBJECT(PyGeventIOObject, c_watcher, _watcher);<br>    gevent_callback(watcher-&gt;loop, watcher-&gt;_callback, watcher-&gt;args, (PyObject*)watcher, c_watcher, revents);<br>&#125;<br></code></pre></td></tr></table></figure><p>GET_OBJECT的作用是通过结构体中某一个域的指针来获得整个结构体的指针. 如果<br>你熟悉linux内核就会发现它和container_of的功能很相似.<br>所以这里实际就是根 据cwatcher对象_watcher来获得watcher的指针, 接着就调用<br><code>gevent_callback</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gevent_callback</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PyGeventLoopObject* loop, PyObject* callback,</span><br><span class="hljs-params">                            PyObject* args, PyObject* watcher, <span class="hljs-type">void</span> *c_watcher,</span><br><span class="hljs-params">                            <span class="hljs-type">int</span> revents)</span> &#123;<br>    ......<br>    result = PyObject_Call(callback, args, <span class="hljs-literal">NULL</span>);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>所以该函数就调用了上层传入的callback.</p></li></ol></li></ol><h3 id="core的api总结"><a href="#core的api总结" class="headerlink" title="core的api总结"></a>core的api总结</h3><p>假设Loop代表类, loop代表实例</p><ol><li>loop.run: 启动事件循环</li><li>loop.run_callback(fun, *args): 将fun注册给loop的_prepare watcher,这样<br>fun就会在事件循环要阻塞时运行, spawn以及rawlink都会使用该方法.</li><li>loop.io: 创建一个IO watcher实例, 调用该实例的start方法来注册回调函数,同 时将该watcher放入事件循环.</li><li>loop.timer: 创建Timer Watcher对象</li><li>loop.signal: 创建signal Watcher对象</li><li>loop.idle:</li><li>loop.prepare:</li><li>loop.fork:</li></ol><p><strong>注意使用io,timer, signal</strong> 等方法创建watcher对象后, 必须调用该对象start方法<br>才能将watcher注册到事件循环中</p><h2 id="HUB"><a href="#HUB" class="headerlink" title="HUB"></a>HUB</h2><p>这实际上是greenlet的子类,所以它的每一个实例实际上就代表一个协程,这个类创建的 协程是专门用来运行事件循环的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hub</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    ...<br><br>    NOT_ERROR = (GreenletExit, SystemExit)<br>    loop_class = config(<span class="hljs-string">&#x27;gevent.core.loop&#x27;</span>, <span class="hljs-string">&#x27;GEVENT_LOOP&#x27;</span>)<br>    ...<br>    backend = config(<span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;GEVENT_BACKEND&#x27;</span>)<br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, loop=<span class="hljs-literal">None</span>, default=<span class="hljs-literal">None</span></span>):<br>        greenlet.__init__(self)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(loop, <span class="hljs-string">&#x27;run&#x27;</span>):<br>           ...<br>        <span class="hljs-keyword">else</span>:<br>            ...<br>            loop_class = _<span class="hljs-keyword">import</span>(self.loop_class)<br>            <span class="hljs-keyword">if</span> loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                loop = self.backend<br>            self.loop = loop_class(flags=loop, default=default)<br>        ...<br></code></pre></td></tr></table></figure><p>创建一个hub实例, 这个实例最重要的就是loop属性,这个实际就是core模块的loop类的 实例,也就是说是libev的事件循环的封装.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">assert</span> self <span class="hljs-keyword">is</span> getcurrent(), <span class="hljs-string">&#x27;Do not call Hub.run() directly&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        loop = self.loop<br>        loop.error_handler = self<br>        <span class="hljs-keyword">try</span>:<br>            loop.run()<br>        <span class="hljs-keyword">finally</span>:<br>            loop.error_handler = <span class="hljs-literal">None</span>  <span class="hljs-comment"># break the refcount cycle</span><br>        self.parent.throw(LoopExit(<span class="hljs-string">&#x27;This operation would block forever&#x27;</span>))<br></code></pre></td></tr></table></figure><p>这个方法就是协程的入口函数,它内部实际是一个循环, 这个循环就是用来启动libev的 事件循环的. 该函数一般是在调用 <code>hub.switch</code><br>时开始运行的.</p><h3 id="Waiter"><a href="#Waiter" class="headerlink" title="Waiter"></a>Waiter</h3><p>协程间的通信机制.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Waiter</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, hub=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> hub <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.hub = get_hub()<br>        <span class="hljs-keyword">else</span>:<br>            self.hub = hub<br>        self.greenlet = <span class="hljs-literal">None</span><br>        self.value = <span class="hljs-literal">None</span><br>        self._exception = _NONE<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;If a value/an exception is stored, return/raise it. Otherwise until switch() or throw() is called.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _NONE:<br>            <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> self.value<br>            <span class="hljs-keyword">else</span>:<br>                getcurrent().throw(*self._exception)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> self.greenlet <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;This Waiter is already used by %r&#x27;</span> % (self.greenlet, )<br>            self.greenlet = getcurrent()<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">return</span> self.hub.switch()<br>            <span class="hljs-keyword">finally</span>:<br>                self.greenlet = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">switch</span>(<span class="hljs-params">self, value=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Switch to the greenlet if one&#x27;s available. Otherwise store the value.&quot;&quot;&quot;</span><br>        greenlet = self.greenlet<br>        <span class="hljs-keyword">if</span> greenlet <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.value = value<br>            self._exception = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> getcurrent() <span class="hljs-keyword">is</span> self.hub, <span class="hljs-string">&quot;Can only use Waiter.switch method from the Hub greenlet&quot;</span><br>            switch = greenlet.switch<br>            <span class="hljs-keyword">try</span>:<br>                switch(value)<br>            <span class="hljs-keyword">except</span>:<br>                self.hub.handle_error(switch, *sys.exc_info())<br><br></code></pre></td></tr></table></figure><p>该类的实例有一个value属性, 一个_expception属性, 一个get方法,一个switch方法,他 们的行为是这样的:</p><ol><li>get: 当你在一个协程中调用get方法时, 它会先检查_exception的值,如果不为默 认的_NONE,<br>那么它就会根据value属性的值来决定是返回value的值还是抛出异 常,<br>如果_exception为默认值, 它会设置greenlet属性为当前的协程对象,接着就 会切换到hub协程.</li><li>switch: 实际就是调用Waiter对象的greenlet属性的switch方法, 这样就切换到 了对应的协程.<br>一般会注册到某个watcher的回调函数. 如果greenlet属性为<br>None,那么意味着switch在get之前运行了,那么就简单的设置下value以<br>及_exception属性.</li></ol><p><strong>需要等待的协程调用get方法,这样该协程就会挂起, 其他的协程调用switch方法切换 到因等待而挂起的协程</strong>,<br>我们来看看Waiter的一个使用例子, Hub的wait方法的代 码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hub</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">self, watcher</span>):<br>        waiter = Waiter()<br>        unique = <span class="hljs-built_in">object</span>()<br>        watcher.start(waiter.switch, unique)<br>        <span class="hljs-keyword">try</span>:<br>            result = waiter.get()<br>            <span class="hljs-keyword">assert</span> result <span class="hljs-keyword">is</span> unique, <span class="hljs-string">&#x27;Invalid switch into %s: %r (expected %r)&#x27;</span> % (getcurrent(), result, unique)<br>        <span class="hljs-keyword">finally</span>:<br>            watcher.stop()<br>    ...<br></code></pre></td></tr></table></figure><p><strong>wait方法的作用是挂起当前的协程,直到watcher监听的事件就绪</strong>.它创建一个<br>Waiter实例waiter,接着将waiter的switch方法注册到wacher上,这样当watcher监听的<br>事件就绪后就会调用实例的switch方法,接着就调用waiter的get方法, 根据watcher监<br>听的事件就绪的快慢,这里有两种可能:</p><ol><li><strong>get在switch之前运行</strong>: get会设置waiter的greenlet属性为当前执行的协程, 接着 切换到hub,<br>当将来某个时候事件就绪,那么调用waiter的switch,switch会调用<br>greenlet属性的switch方法,这样就切换回了当前运行的协程.</li><li><strong>get在switch之后运行</strong>: 这种情况比较少见,可是也是存在的, 这种情况下运行<br>switch时,waiter对象的greenlet属性为None, 所以switch方法只是简单的设置<br>waiter的value属性, 接着调用get会直接返回value属性,而不阻塞.注意不要弄 混_NONE与None.</li></ol><h2 id="Greenlet"><a href="#Greenlet" class="headerlink" title="Greenlet"></a>Greenlet</h2><p>这也是一个greenlet的子类,它也是用来产生协程的, 我们先来看看我们创建协程时常 用的spawn函数的源码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greenlet</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run=<span class="hljs-literal">None</span>, *args, **kwargs</span>):<br>        hub = get_hub()<br>        greenlet.__init__(self, parent=hub)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return a new :class:`Greenlet` object, scheduled to start.</span><br><span class="hljs-string">        The arguments are passed to :meth:`Greenlet.__init__`.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        g = cls(*args, **kwargs)<br>        g.start()<br>        <span class="hljs-keyword">return</span> g<br></code></pre></td></tr></table></figure><p>gevent.spawn实际就是Greenlet类的spawn方法,该方法直接创建一个Greenlet实例,注<br>意该实例的parent是hub,而不是默认的主协程, 这样的用处是当协程完成退出时,程序<br>会继续执行hub的事件循环.然后调用实例的start方法, 下面看看start方法的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Schedule the greenlet to run in this loop iteration&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> self._start_event <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        self._start_event = self.parent.loop.run_callback(self.switch)<br></code></pre></td></tr></table></figure><p>start方法实际上就是把该实例丢到hub协程的循环当中,也就是说这个新建的协程就可 以被hub调度了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_callback</span>(<span class="hljs-params">self, func, *args</span>):<br>    CHECK_LOOP2(self)<br>    cdef callback cb = callback(func, args)<br>    self._callbacks.append(cb)<br>    libev.ev_ref(self._ptr)<br>    <span class="hljs-keyword">return</span> cb<br></code></pre></td></tr></table></figure><p>上面的代码先创建一个callback实例cb,接着将这个实例放进_callbacks列表中, 在core<br>部分我们分析了_callbacks列表的所有callback实例都会被_prepare watcher的回调<br>函数 <code>gevent_run_callbacks</code> 运行, 这样实际就是启动了协程.</p><h2 id="socket模块"><a href="#socket模块" class="headerlink" title="socket模块"></a>socket模块</h2><p>我们知道为了发挥协程的威力, 我们不能使用标准socket库,必须使用gevent实现的 socket库,<br>现在我们来分析一下gevent的socket模块,看看该模块是如何使用协程的,<br>我这里以socket的recv方法为例. 假设调用recv方法的协程为gr.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">socket</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, family=AF_INET, <span class="hljs-built_in">type</span>=SOCK_STREAM, proto=<span class="hljs-number">0</span>, _sock=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> _sock <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._sock = _realsocket(family, <span class="hljs-built_in">type</span>, proto)<br>            self.timeout = _socket.getdefaulttimeout()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(_sock, <span class="hljs-string">&#x27;_sock&#x27;</span>):<br>                self._sock = _sock._sock<br>                self.timeout = <span class="hljs-built_in">getattr</span>(_sock, <span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-literal">False</span>)<br>                <span class="hljs-keyword">if</span> self.timeout <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                    self.timeout = _socket.getdefaulttimeout()<br>            <span class="hljs-keyword">else</span>:<br>                self._sock = _sock<br>                self.timeout = _socket.getdefaulttimeout()<br>        self._sock.setblocking(<span class="hljs-number">0</span>)<br>        fileno = self._sock.fileno()<br>        self.hub = get_hub()<br>        io = self.hub.loop.io<br>        self._read_event = io(fileno, <span class="hljs-number">1</span>)<br>        self._write_event = io(fileno, <span class="hljs-number">2</span>)<br><br></code></pre></td></tr></table></figure><p>__init__很简单,创建一个socket(self._sock),将该描述符设置为非阻塞,同时创建两个<br>watcher,分别监听读事件(self._read_event)以及写事件(self._write_event),下面<br>看看recv的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv</span>(<span class="hljs-params">self, *args</span>):<br>    sock = self._sock  <span class="hljs-comment"># keeping the reference so that fd is not closed during waiting</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> sock.recv(*args)<br>        <span class="hljs-keyword">except</span> error:<br>            ex = sys.exc_info()[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> ex.args[<span class="hljs-number">0</span>] != EWOULDBLOCK <span class="hljs-keyword">or</span> self.timeout == <span class="hljs-number">0.0</span>:<br>                <span class="hljs-keyword">raise</span><br>            <span class="hljs-comment"># QQQ without clearing exc_info test__refcount.test_clean_exit fails</span><br>            sys.exc_clear()<br>        self._wait(self._read_event)<br></code></pre></td></tr></table></figure><p>recv直接调用内置模块的recv方法,如果发现该调用会阻塞,那么就调用_wait方法, 该 方法也是代码的关键部分.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_wait</span>(<span class="hljs-params">self, watcher, timeout_exc=timeout(<span class="hljs-params"><span class="hljs-string">&#x27;timed out&#x27;</span></span>)</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Block the current greenlet until *watcher* has pending events.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If *timeout* is non-negative, then *timeout_exc* is raised after *timeout* second has passed.</span><br><span class="hljs-string">    By default *timeout_exc* is ``socket.timeout(&#x27;timed out&#x27;)``.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If :func:`cancel_wait` is called, raise ``socket.error(EBADF, &#x27;File descriptor was closed in another greenlet&#x27;)``.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">assert</span> watcher.callback <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;This socket is already used by another greenlet: %r&#x27;</span> % (watcher.callback, )<br>    <span class="hljs-keyword">if</span> self.timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        timeout = Timeout.start_new(self.timeout, timeout_exc, ref=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">else</span>:<br>        timeout = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">try</span>:<br>        self.hub.wait(watcher)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout.cancel()<br></code></pre></td></tr></table></figure><p>根据注释我们知道_wait方法会使当前的协程暂停,直到watcher监听的事件就绪. 代码的 关键部分是<br><code>self.hub.wait(watcher)</code>, 这个方法在上面已经分析过,只要明白它会阻 塞当前的协程切换到hub协程,<br>而如果watcher监听的事件就绪,它又会切换会当前协程,<br>在recv的例子中,一旦wacher监听的事件就绪也就意味着socket已经处于读就绪状态,所<br>以也就可以调用内置的socket模块的recv方法来获得数据了.</p><h2 id="timeout模块"><a href="#timeout模块" class="headerlink" title="timeout模块"></a>timeout模块</h2><p>该模块实现了一个超时机制, 它先挂起当前的协程, 当指定的时间到了之后,它会切换 到该协程,并且在该协程中抛出异常. 这样就实现了挂起协程的目的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timeout</span>(<span class="hljs-title class_ inherited__">BaseException</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, seconds=<span class="hljs-literal">None</span>, exception=<span class="hljs-literal">None</span>, ref=<span class="hljs-literal">True</span>, priority=-<span class="hljs-number">1</span></span>):<br>        self.seconds = seconds<br>        self.exception = exception<br>        self.timer = get_hub().loop.timer(seconds <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>, ref=ref, priority=priority)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Schedule the timeout.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self.pending, <span class="hljs-string">&#x27;%r is already started; to restart it, cancel it first&#x27;</span> % self<br>        <span class="hljs-keyword">if</span> self.seconds <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># &quot;fake&quot; timeout (never expires)</span><br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">elif</span> self.exception <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> self.exception <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(self.exception, string_types):<br>            <span class="hljs-comment"># timeout that raises self</span><br>            self.timer.start(getcurrent().throw, self)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># regular timeout with user-provided exception</span><br>            self.timer.start(getcurrent().throw, self.exception)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_new</span>(<span class="hljs-params">cls, timeout=<span class="hljs-literal">None</span>, exception=<span class="hljs-literal">None</span>, ref=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(timeout, Timeout):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> timeout.pending:<br>                timeout.start()<br>            <span class="hljs-keyword">return</span> timeout<br>        timeout = cls(timeout, exception, ref=ref)<br>        timeout.start()<br>        <span class="hljs-keyword">return</span> timeout<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pending</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return True if the timeout is scheduled to be raised.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.timer.pending <span class="hljs-keyword">or</span> self.timer.active<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cancel</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;If the timeout is pending, cancel it. Otherwise, do nothing.&quot;&quot;&quot;</span><br>        self.timer.stop()<br><br></code></pre></td></tr></table></figure><p>先看__init__, 它为实例创建了如下属性:</p><ol><li>seconds: 超时的秒数, 如果为None,那么永不超时</li><li>exception: 超时抛出的异常,如果为None,那么就抛出self本身</li><li>timer: 一个timer watcher</li></ol><p>在来看start, 它分为三种情况:</p><ol><li>self.second为None: 那么直接pass, 这就意味者timer没有注册到时间循环中,所 以也就永远不会超时</li><li>self.exception为None: 它会将 <code>getcurrent().throw</code> 注册为timer的回调函数,<br>我们知道协程对象的throw方法和switch是相似的,都会切换到对应协程,只是throw<br>在切换到对应协程后会立刻将它的参数作为异常抛出, 所以一旦超时,那么就会切 换到当前协程,然后抛出self</li><li>self.exception不为None, 和2相似,只是超时会抛出self.exception而不是self本 身.</li></ol><p>start_new是一个包装函数, 正常情况下你要先创建一个timeout实例,然后调用该实例 的start方法,<br>现在你只需要调用这个方法它就会把这两步一起搞定.</p><h3 id="timeout使用指南"><a href="#timeout使用指南" class="headerlink" title="timeout使用指南"></a>timeout使用指南</h3><p>一般情况下timeout都是这样使用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">timeout = Timeout(seconds, exception)<br>timeout.start()<br><span class="hljs-keyword">try</span>:<br>    ...  <span class="hljs-comment"># exception will be raised here, after *seconds* passed since start() call</span><br><span class="hljs-keyword">finally</span>:<br>    timeout.cancel()<br></code></pre></td></tr></table></figure><p>最开始的两行可以用Timeout.start_new代替, 在try中间我们一般会切换到其它的协 程,<br>当超时后会自动切换回来,并且抛出异常,这样try就可以捕捉到了.来看看一个更<br>具体的例子,event.py中的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">timer = Timeout.start_new(timeout)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">try</span>:<br>        result = self.hub.switch()<br>        <span class="hljs-keyword">assert</span> result <span class="hljs-keyword">is</span> self, <span class="hljs-string">&#x27;Invalid switch into Event.wait(): %r&#x27;</span> % (result, )<br>    <span class="hljs-keyword">except</span> Timeout <span class="hljs-keyword">as</span> ex:<br>        <span class="hljs-keyword">if</span> ex <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> timer:<br>            <span class="hljs-keyword">raise</span><br><span class="hljs-keyword">finally</span>:<br>    timer.cancel()<br></code></pre></td></tr></table></figure><p>很显然的例子.</p><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>该模块的Event实现了协程间的通知机制, 也就是一个协程可以唤醒监听该event的所 有协程.</p><h3 id="Event使用指南"><a href="#Event使用指南" class="headerlink" title="Event使用指南"></a>Event使用指南</h3><p>在一个协程中创建event对象,并调用该对象的wait方法,这样该协程就会阻塞,直到另 外一个协程调用了该event对象的set方法,代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># greenlet1</span><br>evt = Event()<br>evt.wait()                <span class="hljs-comment"># block until other greenlets invoke evt.set()</span><br><br><span class="hljs-comment"># greenlet2</span><br>evt.<span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><h2 id="AsycResult"><a href="#AsycResult" class="headerlink" title="AsycResult"></a>AsycResult</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h3 id="channel使用指南"><a href="#channel使用指南" class="headerlink" title="channel使用指南"></a>channel使用指南</h3><p>和go语言的channel类似,只是没有缓存也没有类型信息,如果要缓存,那么可能queue 更合适</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># greenlet1</span><br>chan = Channel()<br>val = chan.get()<br><br><span class="hljs-comment"># greenlet2</span><br>chan.put(val)<br></code></pre></td></tr></table></figure><p>使用方法也是两个协程配合, 一个读一个写,如果channel未就绪,那么相应的读或者 写就会阻塞执行该操作的的这个协程.</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>在Greenlet类的join函数中有如下代码：</p><figure class="highlight python"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">switch = getcurrent().switch<br>self.rawlink(switch)<br><br>result = self.parent.switch()<br></code></pre></td></tr></table></figure><p>rawlink的作用是注册一个函数，这个函数会在这个greenlet运行完成后调用</p><h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><p>gevent不像go一样是官方内置的，所以有些时候和第三方库配合会有一些问题，总的来说 python写成的库可以直接monkey<br>patch，C写成的库可以直接用豆瓣开源的greenify来打 patch。</p><h2 id="greenify"><a href="#greenify" class="headerlink" title="greenify"></a>greenify</h2><p>这个库可以将C扩展打patch，这样可以让他们兼容gevent，它直接工作于二进制文件这一级，<br>不需要你修改C扩展代码，目前只支持ELF文件格式。他会自动的对网络相关的代码来patch。</p><h2 id="PyMongo"><a href="#PyMongo" class="headerlink" title="PyMongo"></a>PyMongo</h2><p>有几个注意事项。</p><ol><li>只初始化一个 <code>pymongo.Connection</code> 对象，最好把这个弄成一个模块级或者全局变量，<br>库的内部由pool，所以你不用操心。</li><li>至少要monkey patch掉socket和threading模块</li><li>要调用 <code>end_request</code> 来将连接归还到pool中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gevent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的“缺点”</title>
    <link href="/2017/02/10/articles/defects-of-python/"/>
    <url>/2017/02/10/articles/defects-of-python/</url>
    
    <content type="html"><![CDATA[<h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>python是一个动态类型的语言，它只能进行动态类型检查，所谓动态类型检查，实际就<br>是说，python只有在运行时会进行类型检查,比如说这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><br>a = <span class="hljs-string">&quot;hello&quot;</span><br>add1(a)<br></code></pre></td></tr></table></figure><p>运行时python会报错，因为integer类型与string类型是不能相加的，但是这种类型错误<br>只能在运行到这条代码时才能检查出来，事实上还有一种静态类型检查，它可以不运行<br>程序就检查出程序的类型错误，这种语言大概可以分为两类：</p><ol><li>C&#x2F;C++，java等，它们的静态检查是在编译源码时完成的，在这种语言中你要对每一<br>个变量的类型进行标识，非常的繁琐，这也是为什么很多人觉得python比C&#x2F;C++这类<br>语言用起来更舒服的原因之一。</li><li>haskell，ML等，在这种语言中，每一次你运行一个程序时，它会先将程序送入一个<br>typechecker中，只有程序通过了typechecker的检查，才能让它运行。这类语言一般<br>内部会有一个推导系统，比如说著名的HM类型系统，所以在这种语言中你不需要做特<br>别多的类型标识，类型系统本身可以推导出绝大多数类型，所以你可以直接用<br><code>x=1</code>, 而不是 <code>int x=1</code>,因为类型系统可以根据1来推导出x的类型。</li></ol><p>静态类型系统的优点主要有以下几点：</p><ol><li>更好的发现错误：静态类型系统可以帮程序员检测出绝大多数低级错误，所以一些<br>Haskell程序员说，只要我的代码通过了类型检查，那么它90%的可能是正确的。</li><li>类型本身可以作为文档的一部分，比如说一个函数如果你知道了它的参数类型以及返 回值类型，那么你很可能就可以猜出它的功能。</li><li>IDE更好用，一般来说能够进行静态类型检查的语言，它的IDE都更好用，代码跳转，<br>重构等功能都非常准确，而python做不到这一点，即便是pyhon所谓最好的IDE<br>pycharm我也可以很轻松的让它出错。</li></ol><p>静态类型系统配合类型推是个好东西，既能享受静态类型检查带来的好处，又不用做过<br>多的类型标注，很可惜python中是无法实现这样的类型系统，也就是说无法进行完备的<br>静态类型检查，因为它太“灵活”， 实际上它的很多灵活性是多余的，因为好的编程风格，<br>是不推荐你使用这部分特性的。这部分灵活性也使得python的很多语义都与类型系统是<br>矛盾的。比如说列表，类型系统要求列表必须同质，也就说列表的元素必须是同一类型，<br>这是符合逻辑的，可是“灵活”的python却允许不同类型的元素放在同一个列表。在比如<br>说python允许一个变量绑定到不同类型的值，比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">aa = <span class="hljs-number">1</span><br>aa = <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>但是这种做法静态类型系统是不允许的（当然这是所有动态语言的问题 ）。还有很多这<br>样的例子。静态类型系统实际上是限制了程序语言的灵活性以及表达力，但这是值得的，<br>因为它去掉的基本都是一些不必要的灵活性，而且去掉这些灵活性之后可以让程序更严<br>谨，实际上现在已经有人在着手向python中添加静态类型，各位可以看看这篇<a href="https://quip.com/r69HA9GhGa7J">文章</a><br>。 有意了解更多类型知识的童鞋可以看看types and programming languages这本书。</p><h1 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h1><p>python强制缩进是一个明智的选择，它使得代码的可读性有了质的飞跃，但是它使用空<br>格这样的不可见字符来标示一个块的结束，我认为不是什么很好的选择。ruby社区有一<br>种说法：ruby使用end终结一个块是比python使用空格缩进更高级的做法。过去有一段时 间我对这种说法也是嗤之以鼻。但是我现在改变了看法,<br>使用空格这样的不可见字符来 标示一个块的结束有以下几个问题:</p><ol><li><p><strong>更容易出错</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">ls</span>):<br>    ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ls:<br>        ret += i<br>    <span class="hljs-keyword">return</span> ret<br><br><span class="hljs-comment"># incorrect</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">ls</span>):<br>    ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ls:<br>        ret += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><p>第二个函数仅仅因为多按了一个tab就产生了一个致命的bug，这种简单的例子可能还<br>好检查，可是对于复杂的函数这种bug很不好排查。如果有明确的块界定符，比如说<br>end，}，那么就根本不会有这种低级的问题.</p></li><li><p><strong>无法使用编辑器来自动格式化代码</strong>, 这是一个很大的问题,当你从网上拷贝一段别人 的代码后,你必须小心翼翼的来确保代码的缩进正确,<br>编辑器是无法自动格式化像 python这类语言的代码的, 这不是因为编辑器不够强大，而是本质上不可能实现，所<br>以python的代码我们必须手动来格式化，这是很机械的工作，可是因为python的设计<br>失误，我们无法把它交给机器来做，曾经我因为写其他语言代码的习惯, 所以在emacs<br>中写python代码时总是喜欢运行代码自动格式化的命令，可是每一次都弄得一团糟，<br>最后不得不在配置中把python的格式化命令去掉了,<br>所以对于python的这种语法虽然 看上去很简洁，但是我不认为是一个好的设计。</p></li><li><p><strong>无法实现一个完备的匿名函数</strong>,python的缩进方式除了导致第三方工具无法自动格<br>式化代码这个问题外，还有一个很大的问题，那就是python无法实现一个功能完备的<br>匿名函数。如果你有函数式编程经验，应该能体会匿名函数的重要性，举一个很简单 的例子，比如python的列表解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> i: i+<span class="hljs-number">1</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>二者实际是等价的，很多人对列表解析推崇有加，可是实际上它不过是个可有可无的<br>语法糖，而且还是一个表达能力并不强大的语法糖（我个人并不排斥语法糖，但是你<br>要明白语法糖背后隐藏的东西），这应该也是从haskell学来的，缩进语法应该也是，<br>我的印象中，python似乎从haskell学了很多蹩脚的东西。如果python能把匿名函数<br>做对，和map搭配会比列表解析强大的多。很可惜python的匿名函数就是一个“残废”<br>的东西，它内部只能有一个表达式，而不能像正常的函数那样包含多个语句，事实上<br>造成这一困境的原因就是python的缩进语法，因为匿名函数一般是作为参数传递给一<br>个函数，这样匿名函数的内部就不能换行，一旦换行缩进就乱了，所以python无法实<br>现一个完全正确的匿名函数。</p></li></ol><h1 id="变量的定义与赋值"><a href="#变量的定义与赋值" class="headerlink" title="变量的定义与赋值"></a>变量的定义与赋值</h1><p>python中不区分变量的定义与赋值，这也是一个设计失误</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="环境（environment）"><a href="#环境（environment）" class="headerlink" title="环境（environment）"></a>环境（environment）</h3><p>如果你写过解释器，那么你一定遇到过这个东西，简单的说环境就是用来跟踪在程序 的执行过程中，每一个标识符都绑定到什么值，所以从逻辑上它就是一个<br>map(identifier &lt;–&gt; value)，和python的dict类似。环境要和作用域规则结合起来, 下面来看一个简单的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scope</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):<br>        self.table = &#123;&#125;<br>        self.parent = parent<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">self, var, val</span>):<br>        <span class="hljs-keyword">if</span> var <span class="hljs-keyword">in</span> self.table:<br>            error(<span class="hljs-string">&quot;var(%s) have been binded in this environment&quot;</span> % var)<br>        <span class="hljs-keyword">else</span>:<br>            self.table[var] = val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, var</span>):<br>        val = self.table.get(var, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> self.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> self.parent.get(var)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, var, val</span>):<br>        <span class="hljs-keyword">if</span> var <span class="hljs-keyword">in</span> self.table:<br>            self.table[var] = val<br>        <span class="hljs-keyword">elif</span> self.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.parent.<span class="hljs-built_in">set</span>(var, val)<br>        <span class="hljs-keyword">else</span>:<br>            error(<span class="hljs-string">&quot;var(%s) is not binded in this environment&quot;</span> % var)<br></code></pre></td></tr></table></figure><p>上面的实现可以看出作用域实际上可以看做是一个dict,只是它有一个parent, 这样 就构成了一个链式的dict,可以从下往上搜索.</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>实际就是在当前变量所在作用域创建一个key&#x2F;value对, 注意实际上是调用 <code>bind</code> 方 法. 前提是该变量没有在当前作用域中绑定.</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>改变作用域中变量的值,如果当前作用域中没有该变量,那么就父作用域中找, 如果该变量不存在那么出错. 实际上该动作就是 <code>set</code> 方法.</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>每当进入一个新的作用域，那么解释器就会创建一个scope对象，该对象的 parent指针会指向当前的scope对象，从而构成一个链式的作用域。</p><h3 id="python的作用域规则"><a href="#python的作用域规则" class="headerlink" title="python的作用域规则"></a>python的作用域规则</h3><p>python有一个内置作用域，这个作用域的所有绑定是在任何地方都可见的。python的内 置函数以及内置异常都是在内置作用域中.<br>可以使用如下代码来查看内置作用域有哪些 绑定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> __builtin__<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">dir</span>(__builtin__)<br></code></pre></td></tr></table></figure><p>除了内置作用域，python在两个地方会创建新的作用域，一个是模块，另一个是函数 （包括方法）</p><h2 id="python的设计失误"><a href="#python的设计失误" class="headerlink" title="python的设计失误"></a>python的设计失误</h2><p>python有一个巨大的设计失误就是没有明确的区分变量的 <strong>声明</strong> 与 <strong>赋值</strong>,也就是说<br>python的”&#x3D;”有两种语义：当前作用域不存在该变量时，它会在作用域中创建该绑定，如果<br>已存在，那么它就会修改该绑定的值，这种混淆的行为严重的损伤了语言的表达能力，同时 也让程序更容易出错，因为变量会自动创建,<br>一个打字错误可能就会造成bug，而在需要明<br>确声明变量的语言中，这种错误是可以被编译器或者解释器检测出来的。同时python的这种<br>设计也让程序不可能自然的修改父作用域，父父作用域..的变量，因为你一旦使用“&#x3D;”那<br>么就会在当前作用域创建新变量，所以python不得不引入global这样丑陋的关键词，然而这<br>只能访问到最外层的全局作用域，处于中间的作用域它仍然无能为力。下面举个例子,比如<br>我们要实现这样一个函数，该函数第一次调用返回1,第二次调用返回2,第n次调用返回n。如<br>果用C语言实现我们可以使用静态变量，如果我们使用javascript实现呢？可能需要像下面 这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> succ = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> inner = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        i++;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> inner;<br>&#125;)()<br></code></pre></td></tr></table></figure><p>那我们如何用python来实现呢？你可能会很自然的写出这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">temp</span>():<br>    i = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        i = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> inner<br><br>succ = temp()<br></code></pre></td></tr></table></figure><p>这个代码和上面的代码逻辑是一样的，但是却达不到我们预期的效果，如果你运行的话 就会发现，它会出错(UnboundLocalError:<br>local variable ‘i’ referenced before assignment). 这其中有一些很细微的区别.<br>在inner中i&#x3D;i+1会在当前作用域创建一个 绑定，这个绑定在该语句之前也是可见的， 所以在求值 <code>i+1</code><br>这个表达式时，python 不会去外层作用域中查找， 它引用local作用域中的i，而你又是在赋值之前引用，所<br>以会报错。</p><h1 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h1><p>这是python被广为诟病的一个东西，与其说它是语言本身的问题，还不如说它是官方的C<br>语言实现的问题，JPython以及pypy都没有这个问题。简单的说GIL是一个全局锁，GIL的<br>存在简化了解释器的实现，但是代价是python的多线程变成了“伪多线程”，也就是说<br>python的多线程程序任一时刻只能运行一个单一的线程，它无法有效的运用多核CPU的优<br>势。因此对于使用python编写的CPU密集型的程序，你不要指望通过多线程来提高性能，<br>多线程只会让这类程序的性能变得更糟。IO密集型的程序影响应该是不大的，这也是为什<br>么tornado这样的库能够工作的很好的原因。所以很多时候为了利用多核，你必须使用多<br>进程，而多进程之间共享数据的代价是比多线程高的多的，也麻烦的多。而且对于分布式<br>系统GIL已经变成了一个比较大的问题,只是因为python语言的特点，所以大多数时候都不<br>会将其作为分布式系统的实现语言，所以在分布式系统领域还不是什么大问题。</p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Concurrency</title>
    <link href="/2015/03/15/articles/concurrency/"/>
    <url>/2015/03/15/articles/concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>CSP的执行实体是一个一个的process，这些process之间通过channel通信，代表语言是go，<br>go语言中的goroutine就是执行实体，goroutine之间通过channel通信，注意go语言中<br>channel是可以有缓冲区.</p><p>CSP模型有这几个特点:</p><ol><li>process之间通过channel来通信, 注意channel是匿名的，任何process都可以向channel中 读或者写，</li><li>channel的读或者写都是同步的，也就是说，如果一个process向channel中写的时候没有<br>process在读该channel那么该process就会阻塞，同理读的时候也一样</li></ol><p>下面是一个CSP模型的示意图：<img src="/2015/03/15/articles/concurrency/static/img/csp_illustration2.png"></p><h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><p>Actor模型的执行实体是actor，每一个actor都有一个关联的mailbox，每个actor都可以读<br>取自己的mailbox中的消息，任一actor都可以向其它actor的mailbox发送消息，这样不同的<br>actor之间就可以通信了。Actor模型的代表语言是erlang。</p><p>Actor模型的特点:</p><ol><li>actor通过mailbox通信，这种通信是点对点的，也就是说一个actor发送消息时必须指定<br>要把消息发给哪一个actor的mailbox，这和CSP的channel的区别很大</li><li>actor发送消息时是异步的，也就是说它不会阻塞，当然如果一个actor读它的mailbox,<br>而这个时候mailbox中没有消息，那么该actor也是会阻塞的。</li></ol><p>下面是一个Actor模型的示意图：<img src="/2015/03/15/articles/concurrency/static/img/actor_illustration2.png"></p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSP</tag>
      
      <tag>Actor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Continuation</title>
    <link href="/2015/03/11/articles/continuation/"/>
    <url>/2015/03/11/articles/continuation/</url>
    
    <content type="html"><![CDATA[<h1 id="continuation"><a href="#continuation" class="headerlink" title="continuation"></a>continuation</h1><p>这是一份关于continuation的<a href="http://www.cs.unm.edu/~williams/cs491/appcont.pdf">文档</a>,<br>将continuation讲的非常清楚,我简要的总结下我的理解: 先说几个概念与符号:</p><ol><li><p>escape procedure: 它和普通的procedure是一样的,而且也有相同的行为,会返回相<br>同的值,唯一的不同的是这个函数它返回后就会替换调用栈,也就是说它会返回解释器<br>的最顶层或者解释器的REPL循环, 一个普通的procedure对应的escape procedure通 过在符号后添加^ 来表示,比如<br><code>k</code> 是一个普通的procedure, 那么它对应的escape procedure就是 <code>k^</code> , 还有 <code>lambda</code><br>是用来构建普通的procedure, 那么 <code>lambda^</code> 就是用来构建 <code>escape procedure</code>.(注意 <code>lambda^</code> 不是scheme的一 部分)下面举个例子:</p><figure class="highlight scheme"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> k<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x y)<br>    (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x y)))<br></code></pre></td></tr></table></figure><p>现在假设你使用 <code>(+ 3 (k 1 2))</code> 那么结果是6, 但是如果你使用 <code>(+ 3 (k^ 1     2))</code> 它就会返回 <code>3</code>, 原因是 <code>k^</code> 与 <code>k</code> 虽然有相同的返回值,但是它会替换 调用栈,所以也就不会执行后面的<br><code>(+ 3)</code>,而是直接返回 <code>k^</code> 的值</p></li><li><p>continuation: 通俗点说 <code>continuation</code> 实际就是代表接下来要做的事或要进行的 操作, 也就是所谓的 <code>the rest of computation</code>, 所以当你要找一个函数来代表<br>某一点的continuation时,你只要弄清楚该点接下来要进行的操作,把这些操作封装<br>进一个函数就好 有了 <code>escape procedure</code> 的概念后,那么continuation实际就是 一个escape<br>procedure.</p></li><li><p>scheme的 call&#x2F;cc</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>      (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>        (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">k^</span> <span class="hljs-number">4</span>)))))<br></code></pre></td></tr></table></figure><p>从上例可以看出 <code>call/cc</code> 的参数是一个lambda函数, 该函数也有一个参数(<code>k^</code>), 很显然 <code>k^</code><br>是一个escape procedure, 当然 <code>k^</code> 也代表当前的<br><code>continuation</code>,在上例中,它的定义可以大致认为是这样的:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">lambda^</span> (v)<br>         (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span> v))<br></code></pre></td></tr></table></figure><p>因为上例直接返回最顶层,所以可以直接这样</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v)<br>  (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span> v))<br></code></pre></td></tr></table></figure><p>所以当你使用 <code>(k^ 4)</code> 时, 它就返回 <code>6</code>, 同时替换调用栈,返回解释器的最上层,同<br>时从这个例子你也可以体会continuation的含义,<br>continuation就是接下来要做的 事或者操作, 那么上例中 <code>call/cc</code> 之后接下来要做的事显然就是 (+<br>2 ret-of-call&#x2F;cc),也就是加2</p></li><li><p>continuation 本质上对应于栈, 是一种control context, 而environment是一种 data<br>context.</p></li><li><p>continuation 内部是静态作用域的, 这个性质有时会产生一些很难捕捉的bug.</p></li><li><p>tail call(尾调用): 如果在函数p内调用了q, 而且q的返回值也是p的返回值, 那么 我们就说q是一个尾调用,<br>尾调用是不会增加栈的, 因为它本质上就是一个goto语句.</p></li></ol><h2 id="call-x2F-cc-let-x2F-cc"><a href="#call-x2F-cc-let-x2F-cc" class="headerlink" title="call&#x2F;cc, let&#x2F;cc"></a>call&#x2F;cc, let&#x2F;cc</h2><p><code>call/cc</code> [1]是 <code>call-with-current-continuation</code> 的缩写. 它的基本形式是这样的:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)                           <span class="hljs-comment">;k is the continuation</span><br>    (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">k</span> <span class="hljs-number">4</span>))))<br><span class="hljs-comment">;;; the result is 4</span><br></code></pre></td></tr></table></figure><p><code>let/cc</code> 可以看做是 <code>call/cc</code> 的一种简写:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">let/cc</span> k                               <span class="hljs-comment">;k is the continuation</span><br>        body)<br><span class="hljs-comment">;;; identical</span><br>(<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)                    <span class="hljs-comment">;k is the continuation</span><br>           body))<br></code></pre></td></tr></table></figure><p><code>call/cc</code> 的参数是一个函数, 这个函数有一个参数, 这个参数会绑定到当前的 <code>continuation</code>, 具体到这个例子就是:<br><code>k</code> 代表当前的continuation(也就是 <code>call/cc</code> 调用时的 <code>continuation</code>), 现在当你应用该<br><code>continuation</code> 也就是使 用 <code>(k 4)</code> 时代码会立即从 <code>call/cc</code> 中返回, 并且返回值是 <code>4</code>, 注意它不会执行<br>前面的 (* 5), 所以不要以为是返回 20. 下面在举几个例子:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)<br>    (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>)))                           <span class="hljs-comment">;return 20</span><br><br>(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span><br>   (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>    (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)<br>      (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">k</span> <span class="hljs-number">4</span>)))))                    <span class="hljs-comment">;return 6</span><br><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> return <span class="hljs-literal">#f</span>)<br>(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>      (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (cont)<br>        (<span class="hljs-name"><span class="hljs-built_in">set!</span></span> return cont)<br>        <span class="hljs-number">1</span>)))                            <span class="hljs-comment">;return 2</span><br>(<span class="hljs-name">return</span> <span class="hljs-number">22</span>)                             <span class="hljs-comment">;return 23</span><br></code></pre></td></tr></table></figure><p>再来看一个比较不好懂的例子</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(((<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k) k))<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) x)) <span class="hljs-string">&quot;HEY!&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>(call/cc (lambda(k) k))</code> 返回当前的 <code>continuation</code>, 我假设该continuation为<br><code>cont</code>, 那么 <code>cont</code> 必然是一个escape procedure,而且可以看做是如下定义的:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (val)<br>  ((<span class="hljs-name">val</span><br>    (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) x)) <span class="hljs-string">&quot;HEY!&quot;</span>))<br></code></pre></td></tr></table></figure><p>所以原来的表达式也就等价于 <code>((cont (lambda(x) x)) &quot;HEY!&quot;)</code>,又因为cont是一个 escape<br>procedure,所以上面的表达式又等价于 <code>(cont (lambda(x) x))</code>,而该式很显 然返回 “HEY!“.</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>BREAK与RESUME, 通过BREAK来暂停, 通过RESUME来从暂停的位置启动.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> BREAK<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (message)<br>    (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>               (<span class="hljs-name"><span class="hljs-built_in">set!</span></span> RESUME K^)<br>               ((<span class="hljs-name">lambda^</span> (x) x) message)))))<br></code></pre></td></tr></table></figure></li><li><p>exceptions 比如racket的异常处理设施, with-handlers以及raise</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(with-handlers ([predicate-expr handler-expr] ...)<br>  body ...+)<br></code></pre></td></tr></table></figure><p>下面是一个示例代码:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">always-fail</span> n)<br>    (<span class="hljs-name">with-handlers</span> ([<span class="hljs-name"><span class="hljs-built_in">even?</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v) <span class="hljs-symbol">&#x27;even</span>)]<br>                    [<span class="hljs-name"><span class="hljs-built_in">positive?</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v) <span class="hljs-symbol">&#x27;positive</span>)])<br>      (<span class="hljs-name">raise</span> n)))<br></code></pre></td></tr></table></figure><p>这种异常处理设施可以使用continuation来创建, 实际上就是将 body 部分放入 let&#x2F;cc中,<br>调用raise实际就是调用continuation</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> convert<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (exp)<br>    (<span class="hljs-name">match</span> exp<br>           [`(with-handlers ([,preds ,handlers] ...)<br>                            ,body ...)<br>            `(let ([ret (let/cc k^<br>                                ,@(map convert body))])<br>               (cond<br>                ,@(map (lambda (p h) `[(,p ret) (,h ret)]) preds handlers)<br>                ))]<br>           [`(raise ,val) `(k^ ,val)]<br>           [`(lambda (,uvar ...) ,body ...)<br>            `(lambda (,@uvar)<br>               ,@(map convert body))]<br>           [`(,f ,v ...)<br>            `(,(convert f)<br>              ,@(map convert v))]<br>           [`(if ,test ,conseq ,alt)<br>            `(if ,(convert test) ,(convert conseq) ,(convert alt))]<br>           [<span class="hljs-name">x</span> x])))<br></code></pre></td></tr></table></figure><p>上面这个函数就是将表达式中的with-handlers以及raise转换为continuation, 比 如下面的代码:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">convert</span> &#x27;(with-handlers ([even? (lambda (v) <span class="hljs-symbol">&#x27;even</span>)]<br>                          [positive? (lambda (v) <span class="hljs-symbol">&#x27;positive</span>)])<br>                         <span class="hljs-number">1</span><br>                         (raise <span class="hljs-number">11</span>)<br>                         <span class="hljs-number">2</span>))<br><span class="hljs-comment">;; =&gt;</span><br><span class="hljs-comment">;; &#x27;(let ((ret (let/cc k^ 1 (k^ 11) 2)))</span><br><span class="hljs-comment">;;    (cond</span><br><span class="hljs-comment">;;     ((even? ret) ((lambda (v) &#x27;even) ret))</span><br><span class="hljs-comment">;;     ((positive? ret) ((lambda (v) &#x27;positive) ret))))</span><br><br></code></pre></td></tr></table></figure><p>当然这个函数还有一些问题,但是我只是想演示一下异常处理设施的实现原理.</p></li><li><p>generators</p></li><li><p>coroutine</p></li></ol><h1 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h1><p><a href="http://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a>(continuation<br>passing style). 核心就是每一个函数都会带一个额外的参数<br>(continuation),前面说了continuation代表的是the rest of<br>computation, 因此这 个参数(continuation)代表了调用者需要对该函数的返回值进行的处理, 因此一个CPS<br>方式编写的函数最后都会使用函数的计算结果来调用你传递的那个continuation.</p><h2 id="自动CPS转换"><a href="#自动CPS转换" class="headerlink" title="自动CPS转换"></a>自动CPS转换</h2><p>一个自动进行CPS转换的宏</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> CPS<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> e1 e2))          <span class="hljs-comment">; other binary operators(- * / etc) are similar to +</span><br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> e1)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v1)<br>          ((<span class="hljs-name">CPS</span> e2)<br>           (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v2)<br>             (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> v1 v2)))))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> exp))        <span class="hljs-comment">;other unary operators(number?, string? etc) are similar to zero?</span><br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> exp)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (val)<br>          (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> val)))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">if</span></span> test conseq alt))<br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> test)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v)<br>          (<span class="hljs-name"><span class="hljs-built_in">if</span></span> v<br>              ((<span class="hljs-name">CPS</span> conseq) k^)<br>              ((<span class="hljs-name">CPS</span> alt) k^)))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) body))<br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x)<br>             (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)<br>               ((<span class="hljs-name">CPS</span> body) k)))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name">app</span> arg))<br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> app)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (f-val)<br>          ((<span class="hljs-name">CPS</span> arg)<br>           (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (arg-val)<br>             ((<span class="hljs-name">f-val</span> arg-val) k^))))))]<br>    [(<span class="hljs-name">_</span> v) (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^ ) (<span class="hljs-name">k^</span> v))]          <span class="hljs-comment">; basic values(number, string etc) must stay at last</span><br>    ))<br></code></pre></td></tr></table></figure><p>自动的CPS转换的要点</p><ol><li><p>首先任何表达式都要转换为 (lambda(k^) …) 的形式, 比如对一个常数表达式2, 你应该转换为 (lambda(k^) (k^<br>2))的形式, 这样做这是因为正在转换的表达式可 能是一个大的表达式中的子表达式, 所以应该把转换后的表达式传递给一个<br>continuation</p></li><li><p>对于lambda表达式, 以(lambda(x) x)为例, 因为它实际和常量一样, 所以应该这样 转换:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>  (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) x)))<br></code></pre></td></tr></table></figure><p>但是cps转换后lambda表达式是要接受两个参数, 也就是x与一个continuation, 所 以:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>  (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x dyn-k)<br>        ((<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k) (<span class="hljs-name">k</span> x))<br>         dyn-k))))<br><span class="hljs-comment">;;; a simple veraion</span><br>(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>  (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x dyn-k)<br>        (<span class="hljs-name">dyn-k</span> x))))<br></code></pre></td></tr></table></figure><p>注意上面的k^是lambda表达式定义时的continuation, 而dyn-k是lambda表达式应用<br>时的continuation,因为应用时continuation可以不同所以它也就是动态的.</p></li></ol><h2 id="CPS的应用"><a href="#CPS的应用" class="headerlink" title="CPS的应用"></a>CPS的应用</h2><p>如果将一个解释器转换为CPS形式, 那么就可以很容易的实现像 scheme中call&#x2F;cc,<br>let&#x2F;cc这样可以获得当前continuation的结构, 因为解释器的continuation代表的解<br>释器接下来要进行的计算, 而解释器是用来模拟用户程序的, 所以实际上这个<br>continuation也可以看作是用户程序接下来要完成的计算,也就是用户程序当前的<br>continuation.</p><h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><ol><li><a href="https://www.wikiwand.com/en/Call-with-current-continuation">wikipedia:<br>Call-with-current-continuation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lisp</tag>
      
      <tag>PL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux平台C语言乱码</title>
    <link href="/2015/02/11/articles/linux-c-messy-code/"/>
    <url>/2015/02/11/articles/linux-c-messy-code/</url>
    
    <content type="html"><![CDATA[<h2 id="文件加载到显示的过程"><a href="#文件加载到显示的过程" class="headerlink" title="文件加载到显示的过程"></a>文件加载到显示的过程</h2><p>只要是用过linux的人都应该遇到过乱码的问题，众所周知，乱码的产生的主要原因是编<br>码的问题，以B编码方式去读取以A编码方式编码的文件时就会产生乱码，文件读取到显示<br>的过程可以简单的用下图表表示：</p><p><img src="/2015/02/11/articles/linux-c-messy-code/static/img/how-to-show-file.png"></p><ul><li>第一步是将文件读入内存，这一步可以看作是直接将文件的二进制形式的表示直接复制 进内存，就是将你用十六进制工具看到的那些东西复制进内存，</li><li>第二步是显示终端将内存中的数据以某种编码方式解码显示出来</li></ul><h2 id="linux乱码产生的原因"><a href="#linux乱码产生的原因" class="headerlink" title="linux乱码产生的原因"></a>linux乱码产生的原因</h2><p>在linux下显示终端的默认编码方式一般是utf8，而中文windows产生的文件默认编码则<br>是gb2312，linux首先读取文件到内存,这时内存中的数据是对原始消息使用gb2312编码<br>得到的,然后显示终端使用utf8解码这些信息,所以自然就无法得到正确的原始信息,也 就是产生了乱码.</p><h2 id="如何避免乱码"><a href="#如何避免乱码" class="headerlink" title="如何避免乱码"></a>如何避免乱码</h2><p>从上面的讨论可以看出，在linux下要不产生乱码，必须让内存中的二进制数据是对原<br>始信息通过utf8编码得到的，那么如何保证这一点呢，有两种方式，一种是让文件本身<br>是utf8编码的，这样读入内存后在以utf8解码后得到的信息肯定一样，也就是不会有乱<br>码，第二种是直接在内存中转换，假设我读一个以gb2312编码的文件，在内存中得到一<br>个缓冲区buf，如果你直接将buf传送给显示终端的话，那么显示终端就会以utf8对buf<br>的二进制数据解码，那么就会产生乱码，因为buf的二进制数据是以gb2312对原始信息<br>编码得到的，那么我要正常显示，则必须将buf中的二进制数据转换为将原始信息以 utf8编码得到的二进制信息，这里分两种情况讨论:</p><ol><li><p>文本文件的编码格式是utf8，这种情况可以直接用c语言读取显示，不会产生乱码， 所以不过多赘述</p></li><li><p>文本文件的编码是gb2312，那么直接用C语言操作时就会产生乱码，这种情况的解决方<br>式主要有两种，第一种就是运行程序之前将要操作的文本文件转换为utf8，打开shell，<br>输入以下命令:</p><p><code>iconv -f gb2312 -t utf8 youfile -c -o newfile</code></p></li></ol><p>其中youfile是要转换的文件，newfile就是得到的utf8编码的文件，其中c这个参数建议加上，<br>它可以忽略无效的字符，比如可以忽略utf8文件里的BOM，下面贴一段转换歌词编码的脚本给大<br>家参考:</p><figure class="highlight bash"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> *.lrc<br><span class="hljs-keyword">do</span><br>    is_utf8=$(file <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> | grep <span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$is_utf8</span>&quot;</span> ]<br>    <span class="hljs-keyword">then</span><br>        iconv -f gb2312 -t utf8 <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> -c -o tmp_lrc &amp;&amp; <span class="hljs-built_in">rm</span> -f <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br>        <span class="hljs-built_in">mv</span> tmp_lrc <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">continue</span>;<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>功能就是将一个目录里扩展名为lrc的文件编码转换为utf8</p><p>这种方式有个弊端就是文件必须提前转换编码，如果程序是给别人使用，我们不可能要求别<br>人先将文件的编码转换好在运行程序，那么有没有什么办法可以直接在C程序里进行转换呢？<br>下面就看看如何在程序中进行转换，先看代码:</p><figure class="highlight c"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iconv.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 1024</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    FILE *fp = fopen(<span class="hljs-string">&quot;she.lrc&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">char</span> dest[MAXLINE];<br>    <span class="hljs-type">char</span> *in = buf;<br>    <span class="hljs-type">char</span> *out = dest;<br>    fgets(buf,MAXLINE,fp);<br><br>    <span class="hljs-type">iconv_t</span> cd = iconv_open(<span class="hljs-string">&quot;UTF-8&quot;</span>,<span class="hljs-string">&quot;GBK&quot;</span>);<br>    <span class="hljs-type">int</span> lenght = MAXLINE;<br>    iconv(cd,&amp;in,&amp;lenght,&amp;out,&amp;lenght)<br>    iconv_close(cd);<br>    <span class="hljs-built_in">fputs</span>(dest,<span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序只是为了测试，所以有些错误处理代码去掉了，其中she.lrc是一个以gb2312编码<br>的歌词文件，用到了3个函数，icon_open,iconv,icon_close,这三个函数是libiconv库的接<br>口，这三个函数的详细介绍清参考:</p><ul><li><a href="http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv_open.3.html">ICONV_OPEN</a></li><li><a href="http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv.3.html">ICONV</a></li><li><a href="http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv_close.3.html">ICONV_CLOSE</a></li></ul><p>这三个函数的帮助文档也可以直接man，很详细，使用的顺序也是先调<br>用iconv_open创建描述符，然后调用iconv转换，最后调用iconv_close<br>关闭描述符，函数原型为：</p><figure class="highlight c"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">iconv_t</span> <span class="hljs-title function_">iconv_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *tocode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fromcode)</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">iconv</span><span class="hljs-params">(<span class="hljs-type">iconv_t</span> cd,</span><br><span class="hljs-params">                    <span class="hljs-type">char</span> **inbuf, <span class="hljs-type">size_t</span> *inbytesleft,</span><br><span class="hljs-params">                    <span class="hljs-type">char</span> **outbuf, <span class="hljs-type">size_t</span> *outbytesleft)</span>;<br> <span class="hljs-type">int</span> <span class="hljs-title function_">iconv_close</span><span class="hljs-params">(<span class="hljs-type">iconv_t</span> cd)</span>;<br></code></pre></td></tr></table></figure><p>其中fromcode和tocode是编码方式，shell下输入iconv –list会列出支持的编码方式。</p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
