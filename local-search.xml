<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Database</title>
    <link href="/notes/database/"/>
    <url>/notes/database/</url>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务有四个特性(ACID):</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>也就是说不能破坏数据库的某种约定，比如经典的银行转账问题中，从账户A转100元到账户B，那么一致性要求两个账户的金额的和要是相同的，数据库不应该让用户看到事务执行的中间状态, 也就是说不能让用户看到A账户减了100元，但是B账户还没有增加100元这样的中间状态，一致性有些需要数据库保证，有些则需要应用保证。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>只是用来保证事务中的操作完全成功或者全部失败，不可能一部分成功一部分失败</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>一个事务如果已经提交成功，那么不管数据库出现什么问题，事务所做的修改都不应该丢失</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>隔离性是指让每一个执行的事务认为只有它自己在执行，主要通过并发控制来保证。<br>实际上ACD就已经可以保证一个事务的正常执行，但是ACD可能使数据库非常的低效，所以就引入了隔离级别，隔离性和一致性是一对矛盾的指标，在最低的隔离等级下，用户是有可能读到脏数据的，也就是说读到事务的中间状态，这实际就是说在最低的隔离等级下，数据库 是不满足一致性的。数据库的隔离级别如下：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read committed</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable read</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>Snapshot</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Serializable</td><td>No</td><td>No</td><td>No</td></tr></tbody></table><ul><li><p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</p></li><li><p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</p></li><li><p>可重复读(Repeated<br>Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</p></li><li><p>快照隔离(Snapshot):<br>在事务开始时获得一个快照，事务中的所有read都是读该快照，通常通过MVCC实现，所以它没有脏读，不可重复读以及幻读的问题，它能够处理写写冲突，它主要的问题是写偏斜（write skew）</p><p><strong>write skew</strong>: 也就是说两个事务读取相同的数据项，但是更新不同的数据项，比如某人有两个账户，每个账户100元，银行要求两个账户的余额之和大于等于0，那么就会有这种情况出现：<br>T1，T2两个事务同时读取两个账户余额，接着都取出200元，T1更新第一个账户，T2更新第二个账户，这样就会出问题。</p></li><li><p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</p></li></ul><h3 id="快照隔离"><a href="#快照隔离" class="headerlink" title="快照隔离"></a>快照隔离</h3><p>快照隔离基本都是通过MVCC实现。</p><ol><li><p>正确性保证：</p><ol><li>Consistent Snapshot：所谓Consistent，即快照包含且仅包含Commit先于SnapshotTS的所有事务</li><li>Commit Total Order：所有事务提交构成一个全序关系，每次提交都会生成一个快照，由<code>CommitTS</code>标识</li><li>Write-Write Conflict: 事务Ti和Tj有冲突，即它们WriteSet有交集，且<code>[SnapshotTS, CommitTS]</code>有交集</li></ol></li><li><p>单机实现</p><p>一个简单的KV单机存储上实现快照隔离的方法：</p><ol><li>事务开始时生成一个唯一的事务号，数据的版本号就是事务号</li><li>数据Key都带上版本号，一般直接把版本号放到key的末尾，encode的时候要保证顺序一致</li><li>事务开始时要记录当前活跃的事务号</li><li>快照读取就是在key(包括当前的版本号）上从后往前scan，忽略掉第三步记录的活跃的事务号（这样可以避免脏读）</li><li>写入时要检测有没有写写冲突，可以从活跃的最小事务号开始，从前往后scan，看有没有事务对相同的key有写入，有的话就返回错误</li><li>每个update都需要记录，用于回滚。</li></ol></li></ol><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>percolator和Omid比较常见，它们都实现了SI(快照隔离)，上述事务的实现会有两个版本号：startTS和commitTS，有如下规则</p><ol><li>startTS一般就是事务开始时分配的事务号</li><li>有了startTS之后，客户端就可以获得snapshot(Snapshot必须要能读到所有commitTS&lt;startTS的数据)，这样客户端可以从snapshot读数据，<br>并且可以计算出哪些数据需要写入(writeSet)，也就是说主要的计算在客户端完成</li><li>客户端完成计算后接着获得commitTS, 然后进入提交流程，此时要检测写写冲突</li></ol><p>写写冲突检测，符合下面两个条件意味着冲突：</p><ol><li>T1和T2的[startTS, commitTS]有重叠</li><li>T1和T2的writeSet有重叠</li></ol><h3 id="percolator"><a href="#percolator" class="headerlink" title="percolator"></a>percolator</h3><p>tikv中的实现，将rocksdb分成3个column family：</p><ol><li>CF_DEFAULT: (key, start_ts) -&gt; value</li><li>CF_LOCK: key -&gt; lock_info</li><li>CF_WRITE: (key, commit_ts) -&gt;<br>write_info</li></ol><p>详细流程如下</p><ol><li>客户端从TSO获得startTS，然后进行本地计算得到要写入的rows，快照读取的流程如下:<ul><li>读取key的lock_info,<br>如果存在并且lock_info中startts小于当前的startts,<br>这时候需要重试，因为可能存在write too late的情况，<br>也就是说一个事务已经获得了commit_ts,<br>并且<code>commit_ts&lt; start_ts</code>,<br>但是因为种种原因它目前还没有提交，所以目前读不到该事务的数据，但是<br>快照读要求读到所有commit_ts&lt;start_ts的事务的数据，所以这种情况只能等待该事务commit后，也就是重试。</li><li>从CF_WRITE中读取committs&lt;start_ts的writeinfo</li><li>从 write_info 中拿到 start_ts</li><li>从CF_DEFAULT中读取上一步的startts为版本的数据。</li></ul></li><li>Prewrite阶段：从要写入的rows中选一个primaryRow，剩下的都是secondary row<ol><li>primaryRow加锁：在CF_LOCK中为primaryRow的key写入lockinfo(内容为startTS)，并且要做冲突检测，一方面是是否有其它事务已加锁该row，<br>同时要检测<code>[startTS, +inf]</code>范围有没有数据,<br>如果没有冲突就在CF_DEFAULT中把数据写入（数据的版本是startTS）</li><li>secondary<br>row加锁，lock_info的内容是startTS以及primaryRow的信息。冲突检测是一样的，加锁成功就把数据写入</li></ol></li><li>Commit阶段<ol><li>从TSO获得commit_ts</li><li>删掉primaryRow的锁，同时在CF_WRITE中为primaryRow的key写入writeinfo(版本号为commit_ts,<br>内容为start_ts).</li><li>为secondary rows重复第2步</li></ol></li></ol><p>crash 恢复 如果某个事务T1读一行数据发现有锁，那么意味着存在事务T0，T0的状态如下：</p><ol><li>根据lock_info的内容查找primaryRow，如果primaryRow的对应版本无锁，并且write_info内容正常，那么T0事务已提交，所以去掉锁，更新write_info</li><li>如果primaryRow的锁消失，并且没有write_info,或者primaryRow干脆不存在，那么T0事务回滚了，那么直接删掉这一行就好</li><li>如果primaryRow的锁的过去很久了，那么该事务在commit或者rollback之前就crash了，那么直接回滚事务T0</li><li>其它情况都认为T0事务正在执行，所以等待T0 commit或者rollback， 然后重启T1</li></ol><h3 id="Omid"><a href="#Omid" class="headerlink" title="Omid"></a>Omid</h3><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>2PC协议主要是用于分布式事务，用于保证作用于多节点的的操作的原子性</p><h1 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h1><p>分布式一致性算法是用于保证多副本的一致性。主要用于多节点复制数据</p><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2><p>主要拆解成4个问题：</p><h3 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h3><p>3个角色：leader, follower, canidate follower一段时间没收到心跳就会进入选主：</p><ol><li>Term+1变为candidate， 并且给自己投一票，接着给集群其它节点发送RequestVote RPC.</li><li>其它节点收到RequestVote，如果Term高于自身的Term，那么修改自身的Term，并且投一票，记住一个Node的一个Term只允许投一票</li><li>如果收到半数节点同意RequestVote，那么成为leader</li></ol><p>边界问题：</p><ol><li>网络分裂，如果follower处在leader的不同的一边，为了避免一定无法成功的选主，可以在follower的心跳超时时先试着联系集群半数的节点，只有连接成功才进入选主流程</li><li>为了避免选主票数分裂，这里需要对选主超时做一下随机化。</li></ol><!-- end list --><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>要保证日志一致性，需要满足下面两点：</p><ol><li>日志只能从leader流向follower</li><li>选主时必须保证新leader有最新的日志</li></ol><!-- end list --><h3 id="日志安全性"><a href="#日志安全性" class="headerlink" title="日志安全性"></a>日志安全性</h3><h3 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h3><p>一定要用两阶段变更，因为如果直接变更可能选出两个leader，比如从3个节点变成5个节点，某个时间点1 2是旧配置(认为集群只有三个节点)，3<br>4 5时新配置(认为集群有5个节点)， 那么1 2可以选出一个leader，3 4 5也可以选出一个leader。</p><h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><ol><li>读放大：每一次读需要多少磁盘IO（disk read)</li><li>写放大：当只需要写入1byte时，存储系统实际写入了n byte,那么写入放大就是n</li><li>空间放大：实际占用的磁盘空间与实际数据空间的比值，主要时一些过期数据的影响</li></ol><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><h2 id="Append-only-BTree"><a href="#Append-only-BTree" class="headerlink" title="Append-only BTree"></a>Append-only BTree</h2><h2 id="LSM"><a href="#LSM" class="headerlink" title="LSM"></a>LSM</h2><h3 id="LevelDB"><a href="#LevelDB" class="headerlink" title="LevelDB"></a>LevelDB</h3><ol><li><p>log file</p><p>Log file format</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs example">      +-----+-------------+--+----+----------+------+-- ... ----+<br>File  | r0  |        r1   |P | r2 |    r3    |  r4  |           |<br>      +-----+-------------+--+----+----------+------+-- ... ----+<br>      &lt;--- kBlockSize ------&gt;|&lt;-- kBlockSize ------&gt;|<br><br> rn = variable size records<br> P = Padding<br> kBlolckSize = 32kb<br></code></pre></td></tr></table></figure><p>Record format</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs example">+---------+-----------+-----------+----------------+--- ... ---+<br>|CRC (4B) | Size (2B) | Type (1B) | Log number (4B)| Payload   |<br>+---------+-----------+-----------+----------------+--- ... ---+<br>Same as above, with the addition of<br>Log number = 32bit log file number, so that we can distinguish between<br>records written by the most recent log writer vs a previous one.<br></code></pre></td></tr></table></figure></li><li><p>table file</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs example">&lt;beginning_of_file&gt;<br>[data block 1]<br>[data block 2]<br>...<br>[data block N]<br>[meta block 1]<br>...<br>[meta block K]<br>[metaindex block]<br>[index block]<br>[Footer]        (fixed size; starts at file_size - sizeof(Footer))<br>&lt;end_of_file&gt;<br></code></pre></td></tr></table></figure><ol><li>data block: 存储key，value数据，以key排序存储</li><li>meta block：一些元数据，比如filter，stat等等</li><li>metaindex block: 存储meta block的(offset, size), 每一个meta<br>block都有一条记录</li><li>index block： 存储data block的（offset，size），每一个data block都有一条记录</li></ol></li></ol><h2 id="Merge-Tree"><a href="#Merge-Tree" class="headerlink" title="Merge Tree"></a>Merge Tree</h2><p>这是clickhouse中所使用的列存储引擎</p><h1 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">As expected from the common wisdom, objects smaller than 256K are best stored in a database while objects larger than 1M are best stored in the filesystem. Between 256K and 1M, the read:write ratio and rate of object overwrite or replacement are important factors. We used the notion of “storage age” or number of object overwrites as way of normalizing wall clock time. Storage age allows our results or similar such results to be applied across a number of read:write ratios and object replacement rates.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
      <tag>raft</tag>
      
      <tag>paxos</tag>
      
      <tag>leveldb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MXNET Dependency Engine</title>
    <link href="/articles/mxnet-engine/"/>
    <url>/articles/mxnet-engine/</url>
    
    <content type="html"><![CDATA[<h1 id="基本背景知识"><a href="#基本背景知识" class="headerlink" title="基本背景知识"></a>基本背景知识</h1><p>MXNET中有一个依赖引擎，这个引擎是用来分析计算过程的依赖关系，把不依赖的计算并行<br>化，以达到提高性能的目的。它的基本原理可以看官方的<a href="https://mxnet-bing.readthedocs.io/en/latest/system/note_engine.html">文档</a>。<br>简单的说就是给每一个对 象打上一个tag，这个tag叫做Var，每一个计算(op)都会依赖一个或者多个Var，依赖有两种<br>类型：写依赖和读依赖。依赖引擎为每一个Var都维护一个队列，然后根据op的依赖关系向<br>队列中添加ReadDependency和WriteDependency，当各个依赖完成后要更新队列的状态。</p><h1 id="Op"><a href="#Op" class="headerlink" title="Op"></a>Op</h1><p>Op实际上是用来代表计算过程以及它依赖的var，先来看看它的uml类图。</p><p><img src="/articles/mxnet-engine/static/img/opr-class-uml.png"></p><p>上面一些比较重要的属性如下：</p><ol><li>fn： op实际要执行的函数</li><li><code>const_vars</code>, <code>mutable_vars</code>: 依赖的var列表（读和写）。</li><li>wait: 当前还没有就绪的var的个数，它的初始值是 <code>len(const_vars)+len(mutable_vars)</code>,<br>每一个依赖就绪那么就会调用 <code>dec_wait</code> 将<br>该值减一，如果该值为0，那么所有的依赖都已就绪，那么可以丢到执行引擎执行了。</li></ol><h1 id="Var"><a href="#Var" class="headerlink" title="Var"></a>Var</h1><p>var可以看做是一个tag，用来标示每一个对象的，这样Op对对象的依赖可以简化成对var的<br>依赖，这样就可以构建出一个不依赖于具体的对象的通用的依赖引擎。Var是依赖引擎的关键。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/articles/mxnet-engine/static/img/threaded-var-class-uml.png"></p><p><strong>声明：下文说到执行时，意思是Op的当前var的依赖已经就绪，因为一个op可以依赖多个<br>var，如果其他的Var没有就绪，那么这时op可能并没有实际运行</strong></p><p>Var只是一个基类，用来统一类型系统的，主要的工作在 <code>ThreadedVar</code> 中，每一个对象都 会有一个由<br><code>VersionedVarBlock</code> 所组成的链表，这个链表就是一个FIFO队列。 <code>head_</code> 指向的是队列的尾部,<br>实际是一个哨兵(空对象)， <code>head_</code> 这个命名有误导性, <code>pending_write_</code><br>指向的是最”老”的写依赖，如果没有写依赖，那么就指向 <code>nullptr</code>, 根据依赖引擎的特点，它实际上指向的是队列的头部，<br><code>ThreadedVar</code> 的那四个方法就是 来操作这个队列的。</p><ol><li><code>num_pending_reads_</code>: 代表当前正在执行(还没有执行完)的读依赖的个数</li><li><code>pending_write_</code>: 代表队列中最“老”的写依赖, 它一直指向队列的头部。</li><li><code>head_</code>: 队列的尾部。</li></ol><p>需要注意的是，正在执行的读依赖是不在队列中的，但是正在执行的写依赖是在队列中的。</p><h2 id="理解Var的队列"><a href="#理解Var的队列" class="headerlink" title="理解Var的队列"></a>理解Var的队列</h2><p>var的队列是依赖引擎的核心，下面我们来分析下各种情况下，如何修改队列的状态。</p><ol><li>添加读依赖: 如果前面没有写依赖，那么直接运行, 否则就插入队列的尾部(<code>head_</code>那一端)</li><li>添加写依赖： 直接将依赖插入队列的尾部，并检查是不是写就绪(既没有读依赖也没有 写依赖在运行),如果是写就绪，那么就运行该依赖。</li><li>读依赖完成</li><li>写依赖完成</li></ol><p><img src="/articles/mxnet-engine/static/img/threaded-var-queue1.png"></p><p>上图中w1写依赖正在执行。</p><p><img src="/articles/mxnet-engine/static/img/threaded-var-queue2.png"> 写依赖w1完成将自己移出队列，并执行写依赖w2</p><p><img src="/articles/mxnet-engine/static/img/threaded-var-queue3.png"></p><p>写依赖w2完成后将自己移出队列，接着并行的执行读依赖r1，r2，记住正在执行的读依赖是被移出队列的， 它们的数目使用<br><code>num_pending_reads_</code> 跟踪的</p><p><img src="/articles/mxnet-engine/static/img/threaded-var-queue4.png"></p><p>每一个读依赖完成都会将 <code>num_pending_reads_</code> 减一，如果减为了0，那么就意味着所有<br>的读依赖都完成了，当r1，r2都完成后，接着执行w3写依赖。</p><h2 id="添加读依赖"><a href="#添加读依赖" class="headerlink" title="添加读依赖"></a>添加读依赖</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>AppendReadDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedVar::AppendReadDependency</span><span class="hljs-params">(OprBlock* opr_block)</span> </span>&#123;<br>    std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>    <span class="hljs-keyword">if</span> (pending_write_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// invariant: is_ready_to_read()</span><br>        <span class="hljs-built_in">CHECK_GE</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// STATE CHANGE</span><br>        ++num_pending_reads_;<br>        <span class="hljs-comment">// decrease wait counter</span><br>        opr_block-&gt;<span class="hljs-built_in">decr_wait</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">auto</span>&amp;&amp; new_var_block = VersionedVarBlock::<span class="hljs-built_in">New</span>();<br>        <span class="hljs-built_in">assert</span>(head_-&gt;next == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">assert</span>(head_-&gt;trigger == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">assert</span>(head_-&gt;write == <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// append things to next.</span><br>        head_-&gt;next = new_var_block;<br>        head_-&gt;trigger = opr_block;<br>        head_ = new_var_block;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的基本思路是这样的：检查队列中有没有写依赖，这分两种情况：</p><ol><li>如果没有写依赖，那么意味着，目前该Var没有依赖在执行，或者说只有读依赖在执行，<br>所以这个新的读依赖可以直接执行，那么它没有必要添加到队列中，只需要更新<br><code>num_pending_reads_</code> 就好，当然因为该op可能还依赖别的var，所以你只能调用 <code>decr_wait</code><br>，只有当wait减为0的时候，才能开始运行。这部分代码在engine的push中。</li><li>如果有写依赖，那么读依赖必须在写依赖的后面执行，所以需要把读依赖添加到队列的 尾部。记住 <code>head_</code> 永远指向一个空的哨兵对象。</li></ol><h2 id="添加写依赖"><a href="#添加写依赖" class="headerlink" title="添加写依赖"></a>添加写依赖</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>AppendWriteDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedVar::AppendWriteDependency</span><span class="hljs-params">(OprBlock* opr_block)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span>&amp;&amp; new_var_block = VersionedVarBlock::<span class="hljs-built_in">New</span>();<br>    std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>    <span class="hljs-comment">// invariant.</span><br>    <span class="hljs-built_in">assert</span>(head_-&gt;next == <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">assert</span>(head_-&gt;trigger == <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">assert</span>(head_-&gt;write == <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// attach to head.</span><br>    head_-&gt;next = new_var_block;<br>    head_-&gt;trigger = opr_block;<br>    head_-&gt;write = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// check if it is ready to write</span><br>    <span class="hljs-keyword">if</span> (pending_write_ == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-comment">// invariant: is_ready_to_read()</span><br>        pending_write_ = head_;<br>        <span class="hljs-built_in">CHECK_GE</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (num_pending_reads_ == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// STATE CHANGE</span><br>            opr_block-&gt;<span class="hljs-built_in">decr_wait</span>();<br>            num_pending_reads_ = kWriteTriggered;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">CHECK_NE</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br>    &#125;<br>    head_ = new_var_block;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码的基本思路是这样的： 将该Op放入队列的尾部，接着检查该Op的依赖有没有就绪，这<br>要检查Var有没有写依赖(pending_read_&#x3D;&#x3D;nullptr)和读依赖(num_pending_read_&#x3D;&#x3D;0)的Op<br>正在执行，只有二者都没有时，才能开始运行，当然你依然要检查该Op对其他的Var的依赖<br>有没有就绪。需要注意的一点是，即便Op的Var写依赖就绪，该Op也不会从队列中移除，只<br>有该Op执行完成后才会被移除，这在CompleteWriteDependency中实现。</p><h2 id="读依赖完成"><a href="#读依赖完成" class="headerlink" title="读依赖完成"></a>读依赖完成</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>CompleteReadDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Dispatcher&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedVar::CompleteReadDependency</span><span class="hljs-params">(Dispatcher dispatcher)</span> </span>&#123;<br>    OprBlock *trigger = <span class="hljs-literal">nullptr</span>;<br>    &#123;<br>        <span class="hljs-comment">// this is lock scope</span><br>        std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>        <span class="hljs-built_in">CHECK_GT</span>(num_pending_reads_, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">if</span> (--num_pending_reads_ == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pending_write_ != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-comment">// STATE CHANGE</span><br>                trigger = pending_write_-&gt;trigger;<br>                num_pending_reads_ = kWriteTriggered;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (trigger != <span class="hljs-literal">nullptr</span> &amp;&amp; trigger-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">dispatcher</span>(trigger);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该部分代码会在一个op运算完成后调用，代码逻辑是比较简单的，先更新 <code>num_pending_read_</code>,<br>更新后如果该值为0，那么就意味着，所有的读依赖都已经执行完成,<br>这样就检查队列，若是存在写依赖，那么该写依赖就就绪了，那么Op就可以执行了(前提是 依赖的其他var也都就绪了,<br>wait为0)。上面的dispatcher实际就是用来将Op丢入执行引擎 的，它一般是PushToExecute，这个后文会看到。</p><h2 id="写依赖完成"><a href="#写依赖完成" class="headerlink" title="写依赖完成"></a>写依赖完成</h2><p>代码主要在 <code>src/engine/Threaded_engine.cc</code> 的 <code>CompleteWriteDependency</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Dispatcher&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ThreadedVar::CompleteWriteDependency</span><span class="hljs-params">(Dispatcher dispatcher)</span> </span>&#123;<br>  <span class="hljs-comment">// this is lock scope</span><br>  VersionedVarBlock *old_pending_write, *end_of_read_chain;<br>  OprBlock* trigger_write = <span class="hljs-literal">nullptr</span>;<br>  &#123;<br>    std::lock_guard&lt;std::mutex&gt; lock&#123;m_&#125;;<br>    <span class="hljs-comment">// invariants</span><br>    <span class="hljs-built_in">assert</span>(head_-&gt;next == <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">assert</span>(pending_write_ != <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">CHECK_EQ</span>(num_pending_reads_, kWriteTriggered);<br><br>    <span class="hljs-comment">// really delete</span><br>    <span class="hljs-keyword">if</span> (to_delete_) &#123;<br>      VersionedVarBlock *head = pending_write_-&gt;next;<br>      VersionedVarBlock::<span class="hljs-built_in">Delete</span>(pending_write_);<br>      <span class="hljs-built_in">assert</span>(head_ == head);<br>      VersionedVarBlock::<span class="hljs-built_in">Delete</span>(head);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// detach pending write</span><br>    old_pending_write = pending_write_;<br>    <span class="hljs-comment">// search for chains to trigger</span><br>    end_of_read_chain = old_pending_write-&gt;next;<br>    <span class="hljs-comment">// reset to 0 pending reads</span><br>    num_pending_reads_ = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (end_of_read_chain != head_ &amp;&amp;<br>           end_of_read_chain-&gt;write == <span class="hljs-literal">false</span>) &#123;<br>      ++num_pending_reads_;<br>      end_of_read_chain = end_of_read_chain-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (end_of_read_chain == head_) &#123;<br>      pending_write_ = <span class="hljs-literal">nullptr</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// check if there is pending reads, if not trigger write</span><br>      <span class="hljs-built_in">assert</span>(end_of_read_chain-&gt;write == <span class="hljs-literal">true</span>);<br>      pending_write_ = end_of_read_chain;<br>      <span class="hljs-keyword">if</span> (num_pending_reads_ == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// mark write as already actived in this var</span><br>        num_pending_reads_ = kWriteTriggered;<br>        trigger_write = end_of_read_chain-&gt;trigger;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// This is outside of lock scope</span><br>  <span class="hljs-comment">// Be very carful, pending_write_ and num_pending_reads_</span><br>  <span class="hljs-comment">// can change now, do not reply ont the two variables.</span><br>  <span class="hljs-comment">// The linked list \in [old_pending_write, end_of_read_chain)</span><br>  <span class="hljs-comment">// is already detached from this Var.</span><br>  <span class="hljs-comment">// So it is safe to modify these</span><br>  VersionedVarBlock *cur_head = old_pending_write-&gt;next;<br>  VersionedVarBlock::<span class="hljs-built_in">Delete</span>(old_pending_write);<br>  <span class="hljs-comment">// dispatch all the events</span><br>  <span class="hljs-keyword">while</span> (cur_head != end_of_read_chain) &#123;<br>    <span class="hljs-keyword">if</span> (cur_head-&gt;trigger-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">dispatcher</span>(cur_head-&gt;trigger);<br>    &#125;<br>    <span class="hljs-keyword">auto</span> prev = cur_head;<br>    cur_head = cur_head-&gt;next;<br>    <span class="hljs-built_in">assert</span>(cur_head != <span class="hljs-literal">nullptr</span>);<br>    VersionedVarBlock::<span class="hljs-built_in">Delete</span>(prev);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (trigger_write != <span class="hljs-literal">nullptr</span> &amp;&amp; trigger_write-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">dispatcher</span>(trigger_write);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和读依赖完成类似，只是写依赖的后面可能跟着多个读依赖，所以需要遍历链表直到发现下 一个写依赖, 这个写依赖由<br><code>end_of_read_chain</code> 指针来表示，如果没发现写依赖，那么 该指针指向 <code>head_</code>,遍历的过程中每发现一个读依赖就将<br><code>num_pending_reads_</code> 加一， 这样当遍历结束后， <code>old_pending_write</code> 指向已经完成的写依赖，而<br><code>end_of_read_chain</code> 指向下一个写依赖或者 <code>head_</code>, 这时候有两种情况：</p><ol><li>这两个指针的中间有多个元素，很显然这是多个读依赖，第二个 <code>while</code> 循环就是用来 并行的执行这两个指针中间的读依赖的。</li><li>这两个指针之间没有元素，那么意味着没有读依赖，那么就直接执行 <code>end_of_read_chian</code> 指向的写依赖，如果该指针指向<br><code>head_</code> 那么意味着队列为空， 什么也不用做。 最后 一部分的 <code>if</code> 就是用来处理这个情况的。</li></ol><h1 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h1><p>Engine是总的调用接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadedEngine::Push</span><span class="hljs-params">(OprHandle op, Context exec_ctx, <span class="hljs-type">int</span> priority)</span> </span>&#123;<br>    ThreadedOpr* threaded_opr = ThreadedOpr::<span class="hljs-built_in">CastFromBase</span>(op);<br>    OprBlock* opr_block = OprBlock::<span class="hljs-built_in">New</span>();<br>    opr_block-&gt;opr = threaded_opr;<br><br>    opr_block-&gt;wait.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<br>                              threaded_opr-&gt;const_vars.<span class="hljs-built_in">size</span>() +<br>                              threaded_opr-&gt;mutable_vars.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>));<br>    opr_block-&gt;ctx = exec_ctx;<br>    opr_block-&gt;priority = priority;<br>    ++pending_;<br>    <span class="hljs-comment">// Add read dependencies.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;const_vars) &#123;<br>        i-&gt;<span class="hljs-built_in">AppendReadDependency</span>(opr_block);<br>    &#125;<br>    <span class="hljs-comment">// Add write dependencies.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;mutable_vars) &#123;<br>        i-&gt;<span class="hljs-built_in">AppendWriteDependency</span>(opr_block);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (opr_block-&gt;<span class="hljs-built_in">decr_wait</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">PushToExecute</span>(opr_block, <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代码是比较清楚的，主要是 <code>AppendReadDependency</code> 和 <code>AppendWriteDependency</code> 的部<br>分，实际上就是把op加到它所依赖的Var的队列中, 最后检查wait是不是为0，如果为0，那<br>么意味着所有依赖都已经就绪，可以直接扔到执行引擎上执行了(PushToExecute),对于不同<br>的执行引擎, <code>PushToExecute</code> 的实现是不一样的。最终都会执行 <code>ExecuteOprBlock</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ExecuteOprBlock</span><span class="hljs-params">(RunContext run_ctx, OprBlock *opr_block)</span> </span>&#123;<br>    ThreadedOpr* threaded_opr = opr_block-&gt;opr;<br>    CallbackOnComplete callback = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">CreateCallback</span>(<br>        ThreadedEngine::OnCompleteStatic, threaded_opr);<br>    <span class="hljs-type">bool</span> debug_info = (engine_info_ &amp;&amp; debug_push_opr_ == opr_block);<br>    <span class="hljs-keyword">if</span> (!shutdown_phase_) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        threaded_opr-&gt;<span class="hljs-built_in">fn</span>(run_ctx, callback);<br>      &#125; <span class="hljs-built_in">catch</span>(dmlc::Error &amp;e) &#123;<br>        std::string what = e.<span class="hljs-built_in">what</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">callback</span>();<br>    &#125;<br><br>    OprBlock::<span class="hljs-built_in">Delete</span>(opr_block);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>上述代码实际就是执行op中的函数，同时在结束的时候运行 <code>OnCompleteStatic</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadedEngine::OnCompleteStatic</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    Engine *engine, <span class="hljs-type">void</span> *threaded_opr)</span> </span>&#123;<br>  <span class="hljs-built_in">static_cast</span>&lt;ThreadedEngine*&gt;(engine)-&gt;<span class="hljs-built_in">OnComplete</span>(<br>      <span class="hljs-built_in">static_cast</span>&lt;ThreadedOpr*&gt;(threaded_opr));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>显然， <code>OnCompleteStatic</code> 就是执行 OnComplete。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ThreadedEngine::OnComplete</span><span class="hljs-params">(ThreadedOpr* threaded_opr)</span> </span>&#123;<br>  <span class="hljs-comment">// Mark complete for read variables</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;const_vars) &#123;<br>    i-&gt;<span class="hljs-built_in">CompleteReadDependency</span>([<span class="hljs-keyword">this</span>](OprBlock* opr) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">PushToExecute</span>(opr, <span class="hljs-literal">false</span>);<br>      &#125;);<br>  &#125;<br>  <span class="hljs-comment">// Mark complete for write variables.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;&amp; i : threaded_opr-&gt;mutable_vars) &#123;<br>    <span class="hljs-type">bool</span> debug_info = (engine_info_ &amp;&amp; debug_wait_var_ == i);<br>    <span class="hljs-keyword">if</span> (debug_info) &#123;<br>      <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Complete write dep for &quot;</span> &lt;&lt; i;<br>    &#125;<br>    <span class="hljs-type">bool</span> to_delete = i-&gt;<span class="hljs-built_in">CompleteWriteDependency</span>(<br>        [<span class="hljs-keyword">this</span>, debug_info](OprBlock* opr) &#123;<br>          <span class="hljs-keyword">if</span> (debug_info) &#123;<br>            <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;PushToExecute &quot;</span> &lt;&lt; opr;<br>            debug_push_opr_ = opr;<br>          &#125;<br>          <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">PushToExecute</span>(opr, <span class="hljs-literal">false</span>);<br>          <span class="hljs-keyword">if</span> (debug_info) &#123;<br>            <span class="hljs-built_in">LOG</span>(INFO) &lt;&lt; <span class="hljs-string">&quot;Fin PushToExecute &quot;</span> &lt;&lt; opr;<br>          &#125;<br>        &#125;);<br>    <span class="hljs-keyword">if</span> (to_delete) &#123;<br>      ThreadedVar::<span class="hljs-built_in">Delete</span>(i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> npending;<br>  &#123;<br>    std::unique_lock&lt;std::mutex&gt; lock&#123;finished_m_&#125;;<br>    npending = --pending_;<br>  &#125;<br>  <span class="hljs-built_in">CHECK_GE</span>(npending, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (npending == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no need to grab lock when notify.</span><br>    finished_cv_.<span class="hljs-built_in">notify_all</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// delte operator if it is temperory</span><br>  <span class="hljs-keyword">if</span> (threaded_opr-&gt;temporary) &#123;<br>    ThreadedOpr::<span class="hljs-built_in">Delete</span>(threaded_opr);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个函数实际上就是Op完成后用来更新Var的队列的，在内部会调用每一个读依赖的 <code>CompleteReadDependency</code> 以及写依赖的<br><code>CompleteWriteDependency</code>, 注意上面传递给 <code>CompleteReadDependency</code> 和<br><code>CompleteWriteDependency</code> 的匿名函数(dispatcher)中主 要是调用了 <code>PushToExecute</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 <code>Push</code> 将Op的各种依赖加入相应的Var的队列，并且当依赖都满足的时候将op丢入执 行引擎执行，当执行引擎完成后，调用<br><code>Complete</code> 系列的函数来更新Var的队列,在更新队 列的过程中，它又会将依赖就绪的Op丢入执行引擎执行，这样一直循环，直到所有的计算过<br>程都完成。</p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mxnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gevent笔记与源码分析</title>
    <link href="/articles/gevent/"/>
    <url>/articles/gevent/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h2><p>Coroutine 也就是 corporate routine，中文名就是协程，从它的英文可以看出是协同 的例程的意思,<br>实际上这个概念和进程与线程有相似之处, 因为linux线程就是所谓的<br>轻量级进程,所以我们来比较一下进程与协程的异同:</p><ul><li><strong>相同点</strong>:二者都是可以看做是一种执行流, 该执行流可以挂起,并且在将来又可以在 你挂起的地方恢复执行,<br>这实际上都可以看做是continuation, 我们来看看当我们挂<br>起一个执行流时我们要保存的东西<ol><li><strong>栈</strong>, 因为如果你不保存栈,那么局部变量你就无法恢复,同时函数的调用链你也无 法恢复,</li><li><strong>寄存器的状态</strong>: 这好理解, 比如说EIP,如果你不保存,那么你恢复执行流就不知道 到底执行哪一条指令,<br>在比如说ESP,EBP, 如果你不保存,那么你即便有完整的栈 你也不知道怎么用.<br>这二者实际就是所谓的上下文,也可以说是continuation. 在执行流切换时必须保存 这两个东西, 内核调度进程时也是一回事.</li></ol></li><li><strong>不同点</strong>:<ol><li>执行流的调度者不同, 进程是内核调度, 而协程是在用户态调度, 也就是说进程<br>的上下文是在内核态保存恢复的,而协程是在用户态保存恢复的.<br>很显然用户态的 代价更低</li><li>进程会被抢占,而协程不会,也就是说协程如果不主动让出CPU,那么其他的协程是不<br>可能得到执行机会,这实际和早期的操作系统类似,比如DOS,<br>它有一个yield原语, 一个进程调用yield,那么它就会让出CPU, 其他的进程也就有机会执行了, 如果一<br>个进程进入了死循环,那么整个系统也就挂起了,永远无法运行其他的进程了, 但<br>对协程而言,这不是问题</li><li>对内存的占用不同,实际上协程可以只需要4K的栈就够了, 而进程占用的内存要大 的多.</li><li>从操作系统的角度讲, 多协程的程序是单线程,单进程的</li></ol></li></ul><h1 id="gevent背景知识"><a href="#gevent背景知识" class="headerlink" title="gevent背景知识"></a>gevent背景知识</h1><p>gevent用到了了libev以及greenlet还有cares,下面简单的介绍这几个库.</p><h2 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h2><p>实际是一个协程库(官方叫micro-thread), 它只提供协程本身,要在协程间切 换调度必须你在程序中手动来进行,直接上代码:</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">x, y</span>):<br>    z = gr2.switch(x+y)<br>    <span class="hljs-built_in">print</span> z<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">u</span>):<br>    <span class="hljs-built_in">print</span> u<br>    gr1.switch(<span class="hljs-number">42</span>)<br><br>gr1 = greenlet(test1)<br>gr2 = greenlet(test2)<br>gr1.switch(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot; world&quot;</span>)<br></code></pre></td></tr></table></figure><p>gr1, gr2以及运行该代码的解释器本身都是协程, 协程对象的switch方法用 来切换,比如 <code>gr2.switch</code> 就是切换到gr2.</p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ol><li>greenlet(run&#x3D;None, parent&#x3D;None): 创建一个greenlet实例.</li><li>greenlet.getcurrent:</li></ol><p>实例方法与属性</p><ol><li>gr.parent:每一个协程都有一个父协程,当前协程结束后会回到父协程中执行,该 属性默认是创建该协程的协程.</li><li>gr.run: 该属性是协程实际运行的代码. run方法结束了,那么该协程也就结束了.</li><li>gr.switch(*args, **kwargs): 切换到gr协程.</li><li>gr.throw(): 切换到gr协程,接着抛出一个异常.</li></ol><h2 id="libev"><a href="#libev" class="headerlink" title="libev"></a>libev</h2><p>和libevent类似, libev是一个事件循环库,他可以监听各个file descriptor, 一旦发现 就绪就调用对应的回调函数,<br>gevent内部就是使用libev来监听socket的.为了后续理解 方便有必要对libev进行简单的了解.</p><ol><li>watcher: 实际上是用来封装各种类型的事件的,不同类型的事件会有不同类型的 watcher, 比如 <code>ev_io</code>,<br><code>ev_timer</code>, 该结构一般会有一个回调函数,当事件触发 使就会调用回调函数.<br>watcher会有两种函数(注意TYPE代表watcher类型,可以是 io, timer,<br>signal等等):<ul><li>ev_TYPE_init: 对watcher对象进行初始化, 对IO而言该函数是 <code>ev_io_init</code>,<br>对timer而言,该函数是 <code>ev_timer_init</code>.</li><li>ev_TYPE_set: 与init系列函数的区别是该函数一般不设置callback</li><li>ev_TYPE_start: 将watcher注册到事件循环中,这样就可以监听事件了.</li></ul></li><li>loop: 事件循环</li></ol><p>来看看示例代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a single header file is required</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ev.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// for puts</span></span><br><br><span class="hljs-comment">// every watcher type has its own typedef&#x27;d struct</span><br><span class="hljs-comment">// with the name ev_TYPE</span><br>ev_io stdin_watcher;<br>ev_timer timeout_watcher;<br><br><span class="hljs-comment">// all watcher callbacks have a similar signature</span><br><span class="hljs-comment">// this callback is called when data is readable on stdin</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">stdin_cb</span> <span class="hljs-params">(EV_P_ ev_io *w, <span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span> (<span class="hljs-string">&quot;stdin ready&quot;</span>);<br>    <span class="hljs-comment">// for one-shot events, one must manually stop the watcher</span><br>    <span class="hljs-comment">// with its corresponding stop function.</span><br>    ev_io_stop (EV_A_ w);<br><br>    <span class="hljs-comment">// this causes all nested ev_run&#x27;s to stop iterating</span><br>    ev_break (EV_A_ EVBREAK_ALL);<br>&#125;<br><br><span class="hljs-comment">// another callback, this time for a time-out</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">timeout_cb</span> <span class="hljs-params">(EV_P_ ev_timer *w, <span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span> (<span class="hljs-string">&quot;timeout&quot;</span>);<br>    <span class="hljs-comment">// this causes the innermost ev_run to stop iterating</span><br>    ev_break (EV_A_ EVBREAK_ONE);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// use the default event loop unless you have special needs</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span> *<span class="hljs-title">loop</span> =</span> EV_DEFAULT;<br><br>    <span class="hljs-comment">// initialise an io watcher, then start it</span><br>    <span class="hljs-comment">// this one will watch for stdin to become readable</span><br>    ev_io_init (&amp;stdin_watcher, stdin_cb, <span class="hljs-comment">/*STDIN_FILENO*/</span> <span class="hljs-number">0</span>, EV_READ);<br>    ev_io_start (loop, &amp;stdin_watcher);<br><br>    <span class="hljs-comment">// initialise a timer watcher, then start it</span><br>    <span class="hljs-comment">// simple non-repeating 5.5 second timeout</span><br>    ev_timer_init (&amp;timeout_watcher, timeout_cb, <span class="hljs-number">5.5</span>, <span class="hljs-number">0.</span>);<br>    ev_timer_start (loop, &amp;timeout_watcher);<br><br>    <span class="hljs-comment">// now wait for events to arrive</span><br>    ev_run (loop, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// break was called, so exit</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获得loop对象, 创建一个io watcher,一个timer watcher, 分别初始化(调用init函<br>数),然后调用start注册回调函数到事件循环中, 接着调用ev_run启动事件循环.</p><h1 id="gevent源码分析"><a href="#gevent源码分析" class="headerlink" title="gevent源码分析"></a>gevent源码分析</h1><p>开始之前先申明: <strong>本文分析的是gevent1.0</strong>.</p><h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><p>core.ppyx文件实际上是用Cython写的代码，在Makefile中有这样一行代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs example">gevent/gevent.core.c: gevent/core.ppyx gevent/libev.pxd<br>        $(PYTHON) util/cythonpp.py -o gevent.core.c gevent/core.ppyx<br>        echo                          &gt;&gt; gevent.core.c<br>        echo &#x27;#include &quot;callbacks.c&quot;&#x27; &gt;&gt; gevent.core.c<br>        mv gevent.core.* gevent/<br><br></code></pre></td></tr></table></figure><p>上面的代码告诉我们core.ppyx会先转换为gevent.core.c这个C语言文件,然后在编译成 动态链接库，它的语法基本能看懂,<br>这个模块主要是实现loop这个类, hub对象中的<br>loop就是这个类的一个对象(注意名字虽然相同但一个是类,一个对象,不要弄混),这个<br>类将libev的事件循环机制封装了起来,我们先熟悉下这个类提供的API,熟悉这些API对<br>使用gevent很有帮助,我假设lp是loop类的对象(在gevent中就是get_hub().loop)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs example">def io(self, int fd, int events, ref=True, priority=None):<br>    return io(self, fd, events, ref, priority)<br><br>def timer(self, double after, double repeat=0.0, ref=True, priority=None):<br>    return timer(self, after, repeat, ref, priority)<br><br>def signal(self, int signum, ref=True, priority=None):<br>    return signal(self, signum, ref, priority)<br><br>def idle(self, ref=True, priority=None):<br>    return idle(self, ref, priority)<br><br>def prepare(self, ref=True, priority=None):<br>    return prepare(self, ref, priority)<br><br>def fork(self, ref=True, priority=None):<br>    return fork(self, ref, priority)<br><br>def async(self, ref=True, priority=None):<br>    return async(self, ref, priority)<br></code></pre></td></tr></table></figure><p>注意上面是Cython, 上面的一系列方法实际是libev中watcher的等价物.比如你调用 <code>lp.io(fd, 1)</code>,<br>就创建了一个监听fd的read事件的watcher对象,至于其它的api都是 类似,<br>每一个watcher对象都有一个 <code>start</code> 方法, 该方法接受一个回调函数以及一系 列传递给回调函数的参数,<br>调用该方法就会将watcher对象注册到libev的事件循环上, 看下面的示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">read_watcher = lp.io(fd, <span class="hljs-number">1</span>)<br>read_watcher.start(cb, args)<br></code></pre></td></tr></table></figure><p>运行上面的两行代码,那么当fd上读就绪时,那么就会调用cb函数,并且会把args传递给<br>cb函数.在gevent中回调函数一般是协程的switch方法,<br>这样一旦调用,那么就切换到 另一个协程中去执行.</p><h3 id="core源码分析"><a href="#core源码分析" class="headerlink" title="core源码分析"></a>core源码分析</h3><p>这一节来分析core.ppyx的源码, 在一次提醒你注意,代码是Cython, 我对Cython也不 太熟,但是代码大致能看懂.<br>同时要明白该模块是对libev的封装, libev中loop,<br>watcher,callback在该模块中都有对应物, 所以你要注意当提到loop时,我们到底是<br>该模块的loop还是libev的loop.</p><ol><li><p>先看callback</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs example">cdef public class callback [object PyGeventCallbackObject, type PyGeventCallback_Type]:<br>    cdef public object callback<br>    cdef public tuple args<br><br>    def __init__(self, callback, args):<br>        self.callback = callback<br>        self.args = args<br><br>    def stop(self):<br>        self.callback = None<br>        self.args = None<br></code></pre></td></tr></table></figure><p>实际上就是把回调函数以及要提供给回调函数的参数封装了起来.</p></li><li><p>loop: 事件循环的封装.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs example">cdef public class loop [object PyGeventLoopObject, type PyGeventLoop_Type]:<br>    cdef libev.ev_loop* _ptr<br>    cdef public object error_handler<br>    cdef libev.ev_prepare _prepare<br>    cdef public list _callbacks<br>    cdef libev.ev_timer _timer0<br><br>    def __init__(self, object flags=None, object default=None, size_t ptr=0):<br>        cdef unsigned int c_flags<br>        cdef object old_handler = None<br>        libev.ev_prepare_init(&amp;self._prepare, &lt;void*&gt;gevent_run_callbacks)<br>        libev.ev_timer_init(&amp;self._timer0, &lt;void*&gt;gevent_noop, 0.0, 0.0)<br>        if ptr:<br>            self._ptr = &lt;libev.ev_loop*&gt;ptr<br>        else:<br>            ......<br><br>        self._callbacks = []<br></code></pre></td></tr></table></figure><ol><li>_ptr: libev的一个ev_loop对象.</li><li>_prepare: libev中的prepare watcher,该watcher注册的回调函数会在事件循环进 入阻塞时调用,<br>从代码中可以看到注册的回调函数是 <code>gevent_run_callbacks</code>, 该函数会运行 <code>_callbacks</code><br>列表中的每一个callback实例.</li><li>_callbacks: 一个列表,实际上当你使用gevent的spawn创建协程时, spawn会在<br>该列表中插入一个callback实例, 该实例的回调函数实际就是你创建的<br>greenlet的switch方法, 这样当 <code>_prepare</code> watcher就绪时,新的协程就有了 启动的机会.</li></ol></li><li><p>watcher: 这是libev的watcher对象的封装,作为例子,我只分析io这一个例 子,timer,signal等等都是相似的,<br>为了方便我使用cwatcher来指代libev中的 watcher.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>#define WATCHER_BASE(TYPE)                                            \<br>    cdef public loop loop                                             \<br>    cdef object _callback                                             \<br>    cdef public tuple args                                            \<br>    cdef readonly int _flags                                          \<br>    cdef libev.ev_##TYPE _watcher                                     \<br><br>cdef public class io(watcher) [object PyGeventIOObject, type PyGeventIO_Type]:<br><br>    WATCHER_BASE(io)<br><br>    def start(self, object callback, *args, pass_events=False):<br>        CHECK_LOOP2(self.loop)<br>        if callback is None:<br>            raise TypeError(&#x27;callback must be callable, not None&#x27;)<br>        self.callback = callback<br>        if pass_events:<br>            self.args = (GEVENT_CORE_EVENTS, ) + args<br>        else:<br>            self.args = args<br>        LIBEV_UNREF<br>        libev.ev_io_start(self.loop._ptr, &amp;self._watcher)<br><br>    def __init__(self, loop loop, int fd, int events, ref=True, priority=None):<br>        if fd &lt; 0:<br>            raise ValueError(&#x27;fd must be non-negative: %r&#x27; % fd)<br>        if events &amp; ~(libev.EV__IOFDSET | libev.EV_READ | libev.EV_WRITE):<br>            raise ValueError(&#x27;illegal event mask: %r&#x27; % events)<br>        libev.ev_io_init(&amp;self._watcher, &lt;void *&gt;gevent_callback_io, fd, events)<br>        self.loop = loop<br>        if ref:<br>            self._flags = 0<br>        else:<br>            self._flags = 4<br>        if priority is not None:<br>            libev.ev_set_priority(&amp;self._watcher, priority)<br></code></pre></td></tr></table></figure><ol><li><p>WATCH_BASE, 它实际上定义了一系列的属性:</p><ul><li>loop: 实际是上面分析的loop类的一个实例</li><li>_watcher: cwatcher对象,也就是一个libev的ev_io对象.</li><li>callback: 回调函数, 注意该回调函数是由上层传递进来,它不是由libev直接<br>调用,而是由libev的回调函数调用,具体到本例就是被<br><code>gevent_callback_io</code> 调用.</li><li>args: 一个元组,传递给回调函数的参数</li></ul></li><li><p><span class="underline"><span class="underline">init</span></span>:<br>该函数会设置loop属性,同时初始化libev的io watcher对象 <code>_watcher</code> (主要做两件事:<br>指定事件类型,指定回调函数), 注意它的回调函数 是 <code>gevent_callback_io</code></p></li><li><p>start: 该函数中 会设置回调函数以及参数, 这里设置的回调函数是上层传入的, 不要和libev的回调函数混淆, 同时调用<br><code>ev_io_start</code> 将该watcher注册到 libev的事件循环中. 为了弄明白libev事件循环的过程,我接下来分析<br><code>gevent_callback_io</code>.</p></li><li><p>gevent_callback_io</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_OBJECT(PY_TYPE, EV_PTR, MEMBER)                             \</span><br><span class="hljs-meta">    ((struct PY_TYPE *)(((char *)EV_PTR) - offsetof(struct PY_TYPE, MEMBER)))</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gevent_callback_io</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ev_loop *_loop, <span class="hljs-type">void</span> *c_watcher, <span class="hljs-type">int</span> revents)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PyGeventIOObject</span>* <span class="hljs-title">watcher</span> =</span> GET_OBJECT(PyGeventIOObject, c_watcher, _watcher);<br>    gevent_callback(watcher-&gt;loop, watcher-&gt;_callback, watcher-&gt;args, (PyObject*)watcher, c_watcher, revents);<br>&#125;<br></code></pre></td></tr></table></figure><p>GET_OBJECT的作用是通过结构体中某一个域的指针来获得整个结构体的指针. 如果<br>你熟悉linux内核就会发现它和container_of的功能很相似.<br>所以这里实际就是根 据cwatcher对象_watcher来获得watcher的指针, 接着就调用<br><code>gevent_callback</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gevent_callback</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PyGeventLoopObject* loop, PyObject* callback,</span><br><span class="hljs-params">                            PyObject* args, PyObject* watcher, <span class="hljs-type">void</span> *c_watcher,</span><br><span class="hljs-params">                            <span class="hljs-type">int</span> revents)</span> &#123;<br>    ......<br>    result = PyObject_Call(callback, args, <span class="hljs-literal">NULL</span>);<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>所以该函数就调用了上层传入的callback.</p></li></ol></li></ol><h3 id="core的api总结"><a href="#core的api总结" class="headerlink" title="core的api总结"></a>core的api总结</h3><p>假设Loop代表类, loop代表实例</p><ol><li>loop.run: 启动事件循环</li><li>loop.run_callback(fun, *args): 将fun注册给loop的_prepare watcher,这样<br>fun就会在事件循环要阻塞时运行, spawn以及rawlink都会使用该方法.</li><li>loop.io: 创建一个IO watcher实例, 调用该实例的start方法来注册回调函数,同 时将该watcher放入事件循环.</li><li>loop.timer: 创建Timer Watcher对象</li><li>loop.signal: 创建signal Watcher对象</li><li>loop.idle:</li><li>loop.prepare:</li><li>loop.fork:</li></ol><p><strong>注意使用io,timer, signal</strong> 等方法创建watcher对象后, 必须调用该对象start方法<br>才能将watcher注册到事件循环中</p><h2 id="HUB"><a href="#HUB" class="headerlink" title="HUB"></a>HUB</h2><p>这实际上是greenlet的子类,所以它的每一个实例实际上就代表一个协程,这个类创建的 协程是专门用来运行事件循环的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hub</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    ...<br><br>    NOT_ERROR = (GreenletExit, SystemExit)<br>    loop_class = config(<span class="hljs-string">&#x27;gevent.core.loop&#x27;</span>, <span class="hljs-string">&#x27;GEVENT_LOOP&#x27;</span>)<br>    ...<br>    backend = config(<span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;GEVENT_BACKEND&#x27;</span>)<br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, loop=<span class="hljs-literal">None</span>, default=<span class="hljs-literal">None</span></span>):<br>        greenlet.__init__(self)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(loop, <span class="hljs-string">&#x27;run&#x27;</span>):<br>           ...<br>        <span class="hljs-keyword">else</span>:<br>            ...<br>            loop_class = _<span class="hljs-keyword">import</span>(self.loop_class)<br>            <span class="hljs-keyword">if</span> loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                loop = self.backend<br>            self.loop = loop_class(flags=loop, default=default)<br>        ...<br></code></pre></td></tr></table></figure><p>创建一个hub实例, 这个实例最重要的就是loop属性,这个实际就是core模块的loop类的 实例,也就是说是libev的事件循环的封装.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">assert</span> self <span class="hljs-keyword">is</span> getcurrent(), <span class="hljs-string">&#x27;Do not call Hub.run() directly&#x27;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        loop = self.loop<br>        loop.error_handler = self<br>        <span class="hljs-keyword">try</span>:<br>            loop.run()<br>        <span class="hljs-keyword">finally</span>:<br>            loop.error_handler = <span class="hljs-literal">None</span>  <span class="hljs-comment"># break the refcount cycle</span><br>        self.parent.throw(LoopExit(<span class="hljs-string">&#x27;This operation would block forever&#x27;</span>))<br></code></pre></td></tr></table></figure><p>这个方法就是协程的入口函数,它内部实际是一个循环, 这个循环就是用来启动libev的 事件循环的. 该函数一般是在调用 <code>hub.switch</code><br>时开始运行的.</p><h3 id="Waiter"><a href="#Waiter" class="headerlink" title="Waiter"></a>Waiter</h3><p>协程间的通信机制.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Waiter</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, hub=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> hub <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.hub = get_hub()<br>        <span class="hljs-keyword">else</span>:<br>            self.hub = hub<br>        self.greenlet = <span class="hljs-literal">None</span><br>        self.value = <span class="hljs-literal">None</span><br>        self._exception = _NONE<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;If a value/an exception is stored, return/raise it. Otherwise until switch() or throw() is called.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _NONE:<br>            <span class="hljs-keyword">if</span> self._exception <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> self.value<br>            <span class="hljs-keyword">else</span>:<br>                getcurrent().throw(*self._exception)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> self.greenlet <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;This Waiter is already used by %r&#x27;</span> % (self.greenlet, )<br>            self.greenlet = getcurrent()<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">return</span> self.hub.switch()<br>            <span class="hljs-keyword">finally</span>:<br>                self.greenlet = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">switch</span>(<span class="hljs-params">self, value=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Switch to the greenlet if one&#x27;s available. Otherwise store the value.&quot;&quot;&quot;</span><br>        greenlet = self.greenlet<br>        <span class="hljs-keyword">if</span> greenlet <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.value = value<br>            self._exception = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> getcurrent() <span class="hljs-keyword">is</span> self.hub, <span class="hljs-string">&quot;Can only use Waiter.switch method from the Hub greenlet&quot;</span><br>            switch = greenlet.switch<br>            <span class="hljs-keyword">try</span>:<br>                switch(value)<br>            <span class="hljs-keyword">except</span>:<br>                self.hub.handle_error(switch, *sys.exc_info())<br><br></code></pre></td></tr></table></figure><p>该类的实例有一个value属性, 一个_expception属性, 一个get方法,一个switch方法,他 们的行为是这样的:</p><ol><li>get: 当你在一个协程中调用get方法时, 它会先检查_exception的值,如果不为默 认的_NONE,<br>那么它就会根据value属性的值来决定是返回value的值还是抛出异 常,<br>如果_exception为默认值, 它会设置greenlet属性为当前的协程对象,接着就 会切换到hub协程.</li><li>switch: 实际就是调用Waiter对象的greenlet属性的switch方法, 这样就切换到 了对应的协程.<br>一般会注册到某个watcher的回调函数. 如果greenlet属性为<br>None,那么意味着switch在get之前运行了,那么就简单的设置下value以<br>及_exception属性.</li></ol><p><strong>需要等待的协程调用get方法,这样该协程就会挂起, 其他的协程调用switch方法切换 到因等待而挂起的协程</strong>,<br>我们来看看Waiter的一个使用例子, Hub的wait方法的代 码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hub</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">self, watcher</span>):<br>        waiter = Waiter()<br>        unique = <span class="hljs-built_in">object</span>()<br>        watcher.start(waiter.switch, unique)<br>        <span class="hljs-keyword">try</span>:<br>            result = waiter.get()<br>            <span class="hljs-keyword">assert</span> result <span class="hljs-keyword">is</span> unique, <span class="hljs-string">&#x27;Invalid switch into %s: %r (expected %r)&#x27;</span> % (getcurrent(), result, unique)<br>        <span class="hljs-keyword">finally</span>:<br>            watcher.stop()<br>    ...<br></code></pre></td></tr></table></figure><p><strong>wait方法的作用是挂起当前的协程,直到watcher监听的事件就绪</strong>.它创建一个<br>Waiter实例waiter,接着将waiter的switch方法注册到wacher上,这样当watcher监听的<br>事件就绪后就会调用实例的switch方法,接着就调用waiter的get方法, 根据watcher监<br>听的事件就绪的快慢,这里有两种可能:</p><ol><li><strong>get在switch之前运行</strong>: get会设置waiter的greenlet属性为当前执行的协程, 接着 切换到hub,<br>当将来某个时候事件就绪,那么调用waiter的switch,switch会调用<br>greenlet属性的switch方法,这样就切换回了当前运行的协程.</li><li><strong>get在switch之后运行</strong>: 这种情况比较少见,可是也是存在的, 这种情况下运行<br>switch时,waiter对象的greenlet属性为None, 所以switch方法只是简单的设置<br>waiter的value属性, 接着调用get会直接返回value属性,而不阻塞.注意不要弄 混_NONE与None.</li></ol><h2 id="Greenlet"><a href="#Greenlet" class="headerlink" title="Greenlet"></a>Greenlet</h2><p>这也是一个greenlet的子类,它也是用来产生协程的, 我们先来看看我们创建协程时常 用的spawn函数的源码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greenlet</span>(<span class="hljs-title class_ inherited__">greenlet</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run=<span class="hljs-literal">None</span>, *args, **kwargs</span>):<br>        hub = get_hub()<br>        greenlet.__init__(self, parent=hub)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return a new :class:`Greenlet` object, scheduled to start.</span><br><span class="hljs-string">        The arguments are passed to :meth:`Greenlet.__init__`.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        g = cls(*args, **kwargs)<br>        g.start()<br>        <span class="hljs-keyword">return</span> g<br></code></pre></td></tr></table></figure><p>gevent.spawn实际就是Greenlet类的spawn方法,该方法直接创建一个Greenlet实例,注<br>意该实例的parent是hub,而不是默认的主协程, 这样的用处是当协程完成退出时,程序<br>会继续执行hub的事件循环.然后调用实例的start方法, 下面看看start方法的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Schedule the greenlet to run in this loop iteration&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> self._start_event <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        self._start_event = self.parent.loop.run_callback(self.switch)<br></code></pre></td></tr></table></figure><p>start方法实际上就是把该实例丢到hub协程的循环当中,也就是说这个新建的协程就可 以被hub调度了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_callback</span>(<span class="hljs-params">self, func, *args</span>):<br>    CHECK_LOOP2(self)<br>    cdef callback cb = callback(func, args)<br>    self._callbacks.append(cb)<br>    libev.ev_ref(self._ptr)<br>    <span class="hljs-keyword">return</span> cb<br></code></pre></td></tr></table></figure><p>上面的代码先创建一个callback实例cb,接着将这个实例放进_callbacks列表中, 在core<br>部分我们分析了_callbacks列表的所有callback实例都会被_prepare watcher的回调<br>函数 <code>gevent_run_callbacks</code> 运行, 这样实际就是启动了协程.</p><h2 id="socket模块"><a href="#socket模块" class="headerlink" title="socket模块"></a>socket模块</h2><p>我们知道为了发挥协程的威力, 我们不能使用标准socket库,必须使用gevent实现的 socket库,<br>现在我们来分析一下gevent的socket模块,看看该模块是如何使用协程的,<br>我这里以socket的recv方法为例. 假设调用recv方法的协程为gr.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">socket</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, family=AF_INET, <span class="hljs-built_in">type</span>=SOCK_STREAM, proto=<span class="hljs-number">0</span>, _sock=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> _sock <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._sock = _realsocket(family, <span class="hljs-built_in">type</span>, proto)<br>            self.timeout = _socket.getdefaulttimeout()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(_sock, <span class="hljs-string">&#x27;_sock&#x27;</span>):<br>                self._sock = _sock._sock<br>                self.timeout = <span class="hljs-built_in">getattr</span>(_sock, <span class="hljs-string">&#x27;timeout&#x27;</span>, <span class="hljs-literal">False</span>)<br>                <span class="hljs-keyword">if</span> self.timeout <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                    self.timeout = _socket.getdefaulttimeout()<br>            <span class="hljs-keyword">else</span>:<br>                self._sock = _sock<br>                self.timeout = _socket.getdefaulttimeout()<br>        self._sock.setblocking(<span class="hljs-number">0</span>)<br>        fileno = self._sock.fileno()<br>        self.hub = get_hub()<br>        io = self.hub.loop.io<br>        self._read_event = io(fileno, <span class="hljs-number">1</span>)<br>        self._write_event = io(fileno, <span class="hljs-number">2</span>)<br><br></code></pre></td></tr></table></figure><p>__init__很简单,创建一个socket(self._sock),将该描述符设置为非阻塞,同时创建两个<br>watcher,分别监听读事件(self._read_event)以及写事件(self._write_event),下面<br>看看recv的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv</span>(<span class="hljs-params">self, *args</span>):<br>    sock = self._sock  <span class="hljs-comment"># keeping the reference so that fd is not closed during waiting</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> sock.recv(*args)<br>        <span class="hljs-keyword">except</span> error:<br>            ex = sys.exc_info()[<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> ex.args[<span class="hljs-number">0</span>] != EWOULDBLOCK <span class="hljs-keyword">or</span> self.timeout == <span class="hljs-number">0.0</span>:<br>                <span class="hljs-keyword">raise</span><br>            <span class="hljs-comment"># QQQ without clearing exc_info test__refcount.test_clean_exit fails</span><br>            sys.exc_clear()<br>        self._wait(self._read_event)<br></code></pre></td></tr></table></figure><p>recv直接调用内置模块的recv方法,如果发现该调用会阻塞,那么就调用_wait方法, 该 方法也是代码的关键部分.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_wait</span>(<span class="hljs-params">self, watcher, timeout_exc=timeout(<span class="hljs-params"><span class="hljs-string">&#x27;timed out&#x27;</span></span>)</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Block the current greenlet until *watcher* has pending events.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If *timeout* is non-negative, then *timeout_exc* is raised after *timeout* second has passed.</span><br><span class="hljs-string">    By default *timeout_exc* is ``socket.timeout(&#x27;timed out&#x27;)``.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    If :func:`cancel_wait` is called, raise ``socket.error(EBADF, &#x27;File descriptor was closed in another greenlet&#x27;)``.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">assert</span> watcher.callback <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;This socket is already used by another greenlet: %r&#x27;</span> % (watcher.callback, )<br>    <span class="hljs-keyword">if</span> self.timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        timeout = Timeout.start_new(self.timeout, timeout_exc, ref=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">else</span>:<br>        timeout = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">try</span>:<br>        self.hub.wait(watcher)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout.cancel()<br></code></pre></td></tr></table></figure><p>根据注释我们知道_wait方法会使当前的协程暂停,直到watcher监听的事件就绪. 代码的 关键部分是<br><code>self.hub.wait(watcher)</code>, 这个方法在上面已经分析过,只要明白它会阻 塞当前的协程切换到hub协程,<br>而如果watcher监听的事件就绪,它又会切换会当前协程,<br>在recv的例子中,一旦wacher监听的事件就绪也就意味着socket已经处于读就绪状态,所<br>以也就可以调用内置的socket模块的recv方法来获得数据了.</p><h2 id="timeout模块"><a href="#timeout模块" class="headerlink" title="timeout模块"></a>timeout模块</h2><p>该模块实现了一个超时机制, 它先挂起当前的协程, 当指定的时间到了之后,它会切换 到该协程,并且在该协程中抛出异常. 这样就实现了挂起协程的目的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timeout</span>(<span class="hljs-title class_ inherited__">BaseException</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, seconds=<span class="hljs-literal">None</span>, exception=<span class="hljs-literal">None</span>, ref=<span class="hljs-literal">True</span>, priority=-<span class="hljs-number">1</span></span>):<br>        self.seconds = seconds<br>        self.exception = exception<br>        self.timer = get_hub().loop.timer(seconds <span class="hljs-keyword">or</span> <span class="hljs-number">0.0</span>, ref=ref, priority=priority)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Schedule the timeout.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> self.pending, <span class="hljs-string">&#x27;%r is already started; to restart it, cancel it first&#x27;</span> % self<br>        <span class="hljs-keyword">if</span> self.seconds <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># &quot;fake&quot; timeout (never expires)</span><br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">elif</span> self.exception <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> self.exception <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(self.exception, string_types):<br>            <span class="hljs-comment"># timeout that raises self</span><br>            self.timer.start(getcurrent().throw, self)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># regular timeout with user-provided exception</span><br>            self.timer.start(getcurrent().throw, self.exception)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_new</span>(<span class="hljs-params">cls, timeout=<span class="hljs-literal">None</span>, exception=<span class="hljs-literal">None</span>, ref=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(timeout, Timeout):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> timeout.pending:<br>                timeout.start()<br>            <span class="hljs-keyword">return</span> timeout<br>        timeout = cls(timeout, exception, ref=ref)<br>        timeout.start()<br>        <span class="hljs-keyword">return</span> timeout<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pending</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return True if the timeout is scheduled to be raised.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.timer.pending <span class="hljs-keyword">or</span> self.timer.active<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cancel</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;If the timeout is pending, cancel it. Otherwise, do nothing.&quot;&quot;&quot;</span><br>        self.timer.stop()<br><br></code></pre></td></tr></table></figure><p>先看__init__, 它为实例创建了如下属性:</p><ol><li>seconds: 超时的秒数, 如果为None,那么永不超时</li><li>exception: 超时抛出的异常,如果为None,那么就抛出self本身</li><li>timer: 一个timer watcher</li></ol><p>在来看start, 它分为三种情况:</p><ol><li>self.second为None: 那么直接pass, 这就意味者timer没有注册到时间循环中,所 以也就永远不会超时</li><li>self.exception为None: 它会将 <code>getcurrent().throw</code> 注册为timer的回调函数,<br>我们知道协程对象的throw方法和switch是相似的,都会切换到对应协程,只是throw<br>在切换到对应协程后会立刻将它的参数作为异常抛出, 所以一旦超时,那么就会切 换到当前协程,然后抛出self</li><li>self.exception不为None, 和2相似,只是超时会抛出self.exception而不是self本 身.</li></ol><p>start_new是一个包装函数, 正常情况下你要先创建一个timeout实例,然后调用该实例 的start方法,<br>现在你只需要调用这个方法它就会把这两步一起搞定.</p><h3 id="timeout使用指南"><a href="#timeout使用指南" class="headerlink" title="timeout使用指南"></a>timeout使用指南</h3><p>一般情况下timeout都是这样使用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">timeout = Timeout(seconds, exception)<br>timeout.start()<br><span class="hljs-keyword">try</span>:<br>    ...  <span class="hljs-comment"># exception will be raised here, after *seconds* passed since start() call</span><br><span class="hljs-keyword">finally</span>:<br>    timeout.cancel()<br></code></pre></td></tr></table></figure><p>最开始的两行可以用Timeout.start_new代替, 在try中间我们一般会切换到其它的协 程,<br>当超时后会自动切换回来,并且抛出异常,这样try就可以捕捉到了.来看看一个更<br>具体的例子,event.py中的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">timer = Timeout.start_new(timeout)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">try</span>:<br>        result = self.hub.switch()<br>        <span class="hljs-keyword">assert</span> result <span class="hljs-keyword">is</span> self, <span class="hljs-string">&#x27;Invalid switch into Event.wait(): %r&#x27;</span> % (result, )<br>    <span class="hljs-keyword">except</span> Timeout <span class="hljs-keyword">as</span> ex:<br>        <span class="hljs-keyword">if</span> ex <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> timer:<br>            <span class="hljs-keyword">raise</span><br><span class="hljs-keyword">finally</span>:<br>    timer.cancel()<br></code></pre></td></tr></table></figure><p>很显然的例子.</p><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>该模块的Event实现了协程间的通知机制, 也就是一个协程可以唤醒监听该event的所 有协程.</p><h3 id="Event使用指南"><a href="#Event使用指南" class="headerlink" title="Event使用指南"></a>Event使用指南</h3><p>在一个协程中创建event对象,并调用该对象的wait方法,这样该协程就会阻塞,直到另 外一个协程调用了该event对象的set方法,代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># greenlet1</span><br>evt = Event()<br>evt.wait()                <span class="hljs-comment"># block until other greenlets invoke evt.set()</span><br><br><span class="hljs-comment"># greenlet2</span><br>evt.<span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><h2 id="AsycResult"><a href="#AsycResult" class="headerlink" title="AsycResult"></a>AsycResult</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h3 id="channel使用指南"><a href="#channel使用指南" class="headerlink" title="channel使用指南"></a>channel使用指南</h3><p>和go语言的channel类似,只是没有缓存也没有类型信息,如果要缓存,那么可能queue 更合适</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># greenlet1</span><br>chan = Channel()<br>val = chan.get()<br><br><span class="hljs-comment"># greenlet2</span><br>chan.put(val)<br></code></pre></td></tr></table></figure><p>使用方法也是两个协程配合, 一个读一个写,如果channel未就绪,那么相应的读或者 写就会阻塞执行该操作的的这个协程.</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>在Greenlet类的join函数中有如下代码：</p><figure class="highlight python"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">switch = getcurrent().switch<br>self.rawlink(switch)<br><br>result = self.parent.switch()<br></code></pre></td></tr></table></figure><p>rawlink的作用是注册一个函数，这个函数会在这个greenlet运行完成后调用</p><h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><p>gevent不像go一样是官方内置的，所以有些时候和第三方库配合会有一些问题，总的来说 python写成的库可以直接monkey<br>patch，C写成的库可以直接用豆瓣开源的greenify来打 patch。</p><h2 id="greenify"><a href="#greenify" class="headerlink" title="greenify"></a>greenify</h2><p>这个库可以将C扩展打patch，这样可以让他们兼容gevent，它直接工作于二进制文件这一级，<br>不需要你修改C扩展代码，目前只支持ELF文件格式。他会自动的对网络相关的代码来patch。</p><h2 id="PyMongo"><a href="#PyMongo" class="headerlink" title="PyMongo"></a>PyMongo</h2><p>有几个注意事项。</p><ol><li>只初始化一个 <code>pymongo.Connection</code> 对象，最好把这个弄成一个模块级或者全局变量，<br>库的内部由pool，所以你不用操心。</li><li>至少要monkey patch掉socket和threading模块</li><li>要调用 <code>end_request</code> 来将连接归还到pool中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gevent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的“缺点”</title>
    <link href="/articles/defects-of-python/"/>
    <url>/articles/defects-of-python/</url>
    
    <content type="html"><![CDATA[<h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>python是一个动态类型的语言，它只能进行动态类型检查，所谓动态类型检查，实际就<br>是说，python只有在运行时会进行类型检查,比如说这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><br>a = <span class="hljs-string">&quot;hello&quot;</span><br>add1(a)<br></code></pre></td></tr></table></figure><p>运行时python会报错，因为integer类型与string类型是不能相加的，但是这种类型错误<br>只能在运行到这条代码时才能检查出来，事实上还有一种静态类型检查，它可以不运行<br>程序就检查出程序的类型错误，这种语言大概可以分为两类：</p><ol><li>C&#x2F;C++，java等，它们的静态检查是在编译源码时完成的，在这种语言中你要对每一<br>个变量的类型进行标识，非常的繁琐，这也是为什么很多人觉得python比C&#x2F;C++这类<br>语言用起来更舒服的原因之一。</li><li>haskell，ML等，在这种语言中，每一次你运行一个程序时，它会先将程序送入一个<br>typechecker中，只有程序通过了typechecker的检查，才能让它运行。这类语言一般<br>内部会有一个推导系统，比如说著名的HM类型系统，所以在这种语言中你不需要做特<br>别多的类型标识，类型系统本身可以推导出绝大多数类型，所以你可以直接用<br><code>x=1</code>, 而不是 <code>int x=1</code>,因为类型系统可以根据1来推导出x的类型。</li></ol><p>静态类型系统的优点主要有以下几点：</p><ol><li>更好的发现错误：静态类型系统可以帮程序员检测出绝大多数低级错误，所以一些<br>Haskell程序员说，只要我的代码通过了类型检查，那么它90%的可能是正确的。</li><li>类型本身可以作为文档的一部分，比如说一个函数如果你知道了它的参数类型以及返 回值类型，那么你很可能就可以猜出它的功能。</li><li>IDE更好用，一般来说能够进行静态类型检查的语言，它的IDE都更好用，代码跳转，<br>重构等功能都非常准确，而python做不到这一点，即便是pyhon所谓最好的IDE<br>pycharm我也可以很轻松的让它出错。</li></ol><p>静态类型系统配合类型推是个好东西，既能享受静态类型检查带来的好处，又不用做过<br>多的类型标注，很可惜python中是无法实现这样的类型系统，也就是说无法进行完备的<br>静态类型检查，因为它太“灵活”， 实际上它的很多灵活性是多余的，因为好的编程风格，<br>是不推荐你使用这部分特性的。这部分灵活性也使得python的很多语义都与类型系统是<br>矛盾的。比如说列表，类型系统要求列表必须同质，也就说列表的元素必须是同一类型，<br>这是符合逻辑的，可是“灵活”的python却允许不同类型的元素放在同一个列表。在比如<br>说python允许一个变量绑定到不同类型的值，比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">aa = <span class="hljs-number">1</span><br>aa = <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>但是这种做法静态类型系统是不允许的（当然这是所有动态语言的问题 ）。还有很多这<br>样的例子。静态类型系统实际上是限制了程序语言的灵活性以及表达力，但这是值得的，<br>因为它去掉的基本都是一些不必要的灵活性，而且去掉这些灵活性之后可以让程序更严<br>谨，实际上现在已经有人在着手向python中添加静态类型，各位可以看看这篇<a href="https://quip.com/r69HA9GhGa7J">文章</a><br>。 有意了解更多类型知识的童鞋可以看看types and programming languages这本书。</p><h1 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h1><p>python强制缩进是一个明智的选择，它使得代码的可读性有了质的飞跃，但是它使用空<br>格这样的不可见字符来标示一个块的结束，我认为不是什么很好的选择。ruby社区有一<br>种说法：ruby使用end终结一个块是比python使用空格缩进更高级的做法。过去有一段时 间我对这种说法也是嗤之以鼻。但是我现在改变了看法,<br>使用空格这样的不可见字符来 标示一个块的结束有以下几个问题:</p><ol><li><p><strong>更容易出错</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">ls</span>):<br>    ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ls:<br>        ret += i<br>    <span class="hljs-keyword">return</span> ret<br><br><span class="hljs-comment"># incorrect</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">ls</span>):<br>    ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ls:<br>        ret += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><p>第二个函数仅仅因为多按了一个tab就产生了一个致命的bug，这种简单的例子可能还<br>好检查，可是对于复杂的函数这种bug很不好排查。如果有明确的块界定符，比如说<br>end，}，那么就根本不会有这种低级的问题.</p></li><li><p><strong>无法使用编辑器来自动格式化代码</strong>, 这是一个很大的问题,当你从网上拷贝一段别人 的代码后,你必须小心翼翼的来确保代码的缩进正确,<br>编辑器是无法自动格式化像 python这类语言的代码的, 这不是因为编辑器不够强大，而是本质上不可能实现，所<br>以python的代码我们必须手动来格式化，这是很机械的工作，可是因为python的设计<br>失误，我们无法把它交给机器来做，曾经我因为写其他语言代码的习惯, 所以在emacs<br>中写python代码时总是喜欢运行代码自动格式化的命令，可是每一次都弄得一团糟，<br>最后不得不在配置中把python的格式化命令去掉了,<br>所以对于python的这种语法虽然 看上去很简洁，但是我不认为是一个好的设计。</p></li><li><p><strong>无法实现一个完备的匿名函数</strong>,python的缩进方式除了导致第三方工具无法自动格<br>式化代码这个问题外，还有一个很大的问题，那就是python无法实现一个功能完备的<br>匿名函数。如果你有函数式编程经验，应该能体会匿名函数的重要性，举一个很简单 的例子，比如python的列表解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> i: i+<span class="hljs-number">1</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>二者实际是等价的，很多人对列表解析推崇有加，可是实际上它不过是个可有可无的<br>语法糖，而且还是一个表达能力并不强大的语法糖（我个人并不排斥语法糖，但是你<br>要明白语法糖背后隐藏的东西），这应该也是从haskell学来的，缩进语法应该也是，<br>我的印象中，python似乎从haskell学了很多蹩脚的东西。如果python能把匿名函数<br>做对，和map搭配会比列表解析强大的多。很可惜python的匿名函数就是一个“残废”<br>的东西，它内部只能有一个表达式，而不能像正常的函数那样包含多个语句，事实上<br>造成这一困境的原因就是python的缩进语法，因为匿名函数一般是作为参数传递给一<br>个函数，这样匿名函数的内部就不能换行，一旦换行缩进就乱了，所以python无法实<br>现一个完全正确的匿名函数。</p></li></ol><h1 id="变量的定义与赋值"><a href="#变量的定义与赋值" class="headerlink" title="变量的定义与赋值"></a>变量的定义与赋值</h1><p>python中不区分变量的定义与赋值，这也是一个设计失误</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="环境（environment）"><a href="#环境（environment）" class="headerlink" title="环境（environment）"></a>环境（environment）</h3><p>如果你写过解释器，那么你一定遇到过这个东西，简单的说环境就是用来跟踪在程序 的执行过程中，每一个标识符都绑定到什么值，所以从逻辑上它就是一个<br>map(identifier &lt;–&gt; value)，和python的dict类似。环境要和作用域规则结合起来, 下面来看一个简单的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scope</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):<br>        self.table = &#123;&#125;<br>        self.parent = parent<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">self, var, val</span>):<br>        <span class="hljs-keyword">if</span> var <span class="hljs-keyword">in</span> self.table:<br>            error(<span class="hljs-string">&quot;var(%s) have been binded in this environment&quot;</span> % var)<br>        <span class="hljs-keyword">else</span>:<br>            self.table[var] = val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, var</span>):<br>        val = self.table.get(var, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> self.parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> self.parent.get(var)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, var, val</span>):<br>        <span class="hljs-keyword">if</span> var <span class="hljs-keyword">in</span> self.table:<br>            self.table[var] = val<br>        <span class="hljs-keyword">elif</span> self.parent <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.parent.<span class="hljs-built_in">set</span>(var, val)<br>        <span class="hljs-keyword">else</span>:<br>            error(<span class="hljs-string">&quot;var(%s) is not binded in this environment&quot;</span> % var)<br></code></pre></td></tr></table></figure><p>上面的实现可以看出作用域实际上可以看做是一个dict,只是它有一个parent, 这样 就构成了一个链式的dict,可以从下往上搜索.</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>实际就是在当前变量所在作用域创建一个key&#x2F;value对, 注意实际上是调用 <code>bind</code> 方 法. 前提是该变量没有在当前作用域中绑定.</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>改变作用域中变量的值,如果当前作用域中没有该变量,那么就父作用域中找, 如果该变量不存在那么出错. 实际上该动作就是 <code>set</code> 方法.</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>每当进入一个新的作用域，那么解释器就会创建一个scope对象，该对象的 parent指针会指向当前的scope对象，从而构成一个链式的作用域。</p><h3 id="python的作用域规则"><a href="#python的作用域规则" class="headerlink" title="python的作用域规则"></a>python的作用域规则</h3><p>python有一个内置作用域，这个作用域的所有绑定是在任何地方都可见的。python的内 置函数以及内置异常都是在内置作用域中.<br>可以使用如下代码来查看内置作用域有哪些 绑定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> __builtin__<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">dir</span>(__builtin__)<br></code></pre></td></tr></table></figure><p>除了内置作用域，python在两个地方会创建新的作用域，一个是模块，另一个是函数 （包括方法）</p><h2 id="python的设计失误"><a href="#python的设计失误" class="headerlink" title="python的设计失误"></a>python的设计失误</h2><p>python有一个巨大的设计失误就是没有明确的区分变量的 <strong>声明</strong> 与 <strong>赋值</strong>,也就是说<br>python的”&#x3D;”有两种语义：当前作用域不存在该变量时，它会在作用域中创建该绑定，如果<br>已存在，那么它就会修改该绑定的值，这种混淆的行为严重的损伤了语言的表达能力，同时 也让程序更容易出错，因为变量会自动创建,<br>一个打字错误可能就会造成bug，而在需要明<br>确声明变量的语言中，这种错误是可以被编译器或者解释器检测出来的。同时python的这种<br>设计也让程序不可能自然的修改父作用域，父父作用域..的变量，因为你一旦使用“&#x3D;”那<br>么就会在当前作用域创建新变量，所以python不得不引入global这样丑陋的关键词，然而这<br>只能访问到最外层的全局作用域，处于中间的作用域它仍然无能为力。下面举个例子,比如<br>我们要实现这样一个函数，该函数第一次调用返回1,第二次调用返回2,第n次调用返回n。如<br>果用C语言实现我们可以使用静态变量，如果我们使用javascript实现呢？可能需要像下面 这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> succ = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> inner = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        i++;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> inner;<br>&#125;)()<br></code></pre></td></tr></table></figure><p>那我们如何用python来实现呢？你可能会很自然的写出这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">temp</span>():<br>    i = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        i = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> inner<br><br>succ = temp()<br></code></pre></td></tr></table></figure><p>这个代码和上面的代码逻辑是一样的，但是却达不到我们预期的效果，如果你运行的话 就会发现，它会出错(UnboundLocalError:<br>local variable ‘i’ referenced before assignment). 这其中有一些很细微的区别.<br>在inner中i&#x3D;i+1会在当前作用域创建一个 绑定，这个绑定在该语句之前也是可见的， 所以在求值 <code>i+1</code><br>这个表达式时，python 不会去外层作用域中查找， 它引用local作用域中的i，而你又是在赋值之前引用，所<br>以会报错。</p><h1 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h1><p>这是python被广为诟病的一个东西，与其说它是语言本身的问题，还不如说它是官方的C<br>语言实现的问题，JPython以及pypy都没有这个问题。简单的说GIL是一个全局锁，GIL的<br>存在简化了解释器的实现，但是代价是python的多线程变成了“伪多线程”，也就是说<br>python的多线程程序任一时刻只能运行一个单一的线程，它无法有效的运用多核CPU的优<br>势。因此对于使用python编写的CPU密集型的程序，你不要指望通过多线程来提高性能，<br>多线程只会让这类程序的性能变得更糟。IO密集型的程序影响应该是不大的，这也是为什<br>么tornado这样的库能够工作的很好的原因。所以很多时候为了利用多核，你必须使用多<br>进程，而多进程之间共享数据的代价是比多线程高的多的，也麻烦的多。而且对于分布式<br>系统GIL已经变成了一个比较大的问题,只是因为python语言的特点，所以大多数时候都不<br>会将其作为分布式系统的实现语言，所以在分布式系统领域还不是什么大问题。</p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Concurrency</title>
    <link href="/articles/concurrency/"/>
    <url>/articles/concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>CSP的执行实体是一个一个的process，这些process之间通过channel通信，代表语言是go，<br>go语言中的goroutine就是执行实体，goroutine之间通过channel通信，注意go语言中<br>channel是可以有缓冲区.</p><p>CSP模型有这几个特点:</p><ol><li>process之间通过channel来通信, 注意channel是匿名的，任何process都可以向channel中 读或者写，</li><li>channel的读或者写都是同步的，也就是说，如果一个process向channel中写的时候没有<br>process在读该channel那么该process就会阻塞，同理读的时候也一样</li></ol><p>下面是一个CSP模型的示意图：<img src="/articles/concurrency/static/img/csp_illustration2.png"></p><h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><p>Actor模型的执行实体是actor，每一个actor都有一个关联的mailbox，每个actor都可以读<br>取自己的mailbox中的消息，任一actor都可以向其它actor的mailbox发送消息，这样不同的<br>actor之间就可以通信了。Actor模型的代表语言是erlang。</p><p>Actor模型的特点:</p><ol><li>actor通过mailbox通信，这种通信是点对点的，也就是说一个actor发送消息时必须指定<br>要把消息发给哪一个actor的mailbox，这和CSP的channel的区别很大</li><li>actor发送消息时是异步的，也就是说它不会阻塞，当然如果一个actor读它的mailbox,<br>而这个时候mailbox中没有消息，那么该actor也是会阻塞的。</li></ol><p>下面是一个Actor模型的示意图：<img src="/articles/concurrency/static/img/actor_illustration2.png"></p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSP</tag>
      
      <tag>Actor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Continuation</title>
    <link href="/articles/continuation/"/>
    <url>/articles/continuation/</url>
    
    <content type="html"><![CDATA[<h1 id="continuation"><a href="#continuation" class="headerlink" title="continuation"></a>continuation</h1><p>这是一份关于continuation的<a href="http://www.cs.unm.edu/~williams/cs491/appcont.pdf">文档</a>,<br>将continuation讲的非常清楚,我简要的总结下我的理解: 先说几个概念与符号:</p><ol><li><p>escape procedure: 它和普通的procedure是一样的,而且也有相同的行为,会返回相<br>同的值,唯一的不同的是这个函数它返回后就会替换调用栈,也就是说它会返回解释器<br>的最顶层或者解释器的REPL循环, 一个普通的procedure对应的escape procedure通 过在符号后添加^ 来表示,比如<br><code>k</code> 是一个普通的procedure, 那么它对应的escape procedure就是 <code>k^</code> , 还有 <code>lambda</code><br>是用来构建普通的procedure, 那么 <code>lambda^</code> 就是用来构建 <code>escape procedure</code>.(注意 <code>lambda^</code> 不是scheme的一 部分)下面举个例子:</p><figure class="highlight scheme"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> k<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x y)<br>    (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x y)))<br></code></pre></td></tr></table></figure><p>现在假设你使用 <code>(+ 3 (k 1 2))</code> 那么结果是6, 但是如果你使用 <code>(+ 3 (k^ 1     2))</code> 它就会返回 <code>3</code>, 原因是 <code>k^</code> 与 <code>k</code> 虽然有相同的返回值,但是它会替换 调用栈,所以也就不会执行后面的<br><code>(+ 3)</code>,而是直接返回 <code>k^</code> 的值</p></li><li><p>continuation: 通俗点说 <code>continuation</code> 实际就是代表接下来要做的事或要进行的 操作, 也就是所谓的 <code>the rest of computation</code>, 所以当你要找一个函数来代表<br>某一点的continuation时,你只要弄清楚该点接下来要进行的操作,把这些操作封装<br>进一个函数就好 有了 <code>escape procedure</code> 的概念后,那么continuation实际就是 一个escape<br>procedure.</p></li><li><p>scheme的 call&#x2F;cc</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>      (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>        (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">k^</span> <span class="hljs-number">4</span>)))))<br></code></pre></td></tr></table></figure><p>从上例可以看出 <code>call/cc</code> 的参数是一个lambda函数, 该函数也有一个参数(<code>k^</code>), 很显然 <code>k^</code><br>是一个escape procedure, 当然 <code>k^</code> 也代表当前的<br><code>continuation</code>,在上例中,它的定义可以大致认为是这样的:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">lambda^</span> (v)<br>         (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span> v))<br></code></pre></td></tr></table></figure><p>因为上例直接返回最顶层,所以可以直接这样</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v)<br>  (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span> v))<br></code></pre></td></tr></table></figure><p>所以当你使用 <code>(k^ 4)</code> 时, 它就返回 <code>6</code>, 同时替换调用栈,返回解释器的最上层,同<br>时从这个例子你也可以体会continuation的含义,<br>continuation就是接下来要做的 事或者操作, 那么上例中 <code>call/cc</code> 之后接下来要做的事显然就是 (+<br>2 ret-of-call&#x2F;cc),也就是加2</p></li><li><p>continuation 本质上对应于栈, 是一种control context, 而environment是一种 data<br>context.</p></li><li><p>continuation 内部是静态作用域的, 这个性质有时会产生一些很难捕捉的bug.</p></li><li><p>tail call(尾调用): 如果在函数p内调用了q, 而且q的返回值也是p的返回值, 那么 我们就说q是一个尾调用,<br>尾调用是不会增加栈的, 因为它本质上就是一个goto语句.</p></li></ol><h2 id="call-x2F-cc-let-x2F-cc"><a href="#call-x2F-cc-let-x2F-cc" class="headerlink" title="call&#x2F;cc, let&#x2F;cc"></a>call&#x2F;cc, let&#x2F;cc</h2><p><code>call/cc</code> [1]是 <code>call-with-current-continuation</code> 的缩写. 它的基本形式是这样的:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)                           <span class="hljs-comment">;k is the continuation</span><br>    (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">k</span> <span class="hljs-number">4</span>))))<br><span class="hljs-comment">;;; the result is 4</span><br></code></pre></td></tr></table></figure><p><code>let/cc</code> 可以看做是 <code>call/cc</code> 的一种简写:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">let/cc</span> k                               <span class="hljs-comment">;k is the continuation</span><br>        body)<br><span class="hljs-comment">;;; identical</span><br>(<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)                    <span class="hljs-comment">;k is the continuation</span><br>           body))<br></code></pre></td></tr></table></figure><p><code>call/cc</code> 的参数是一个函数, 这个函数有一个参数, 这个参数会绑定到当前的 <code>continuation</code>, 具体到这个例子就是:<br><code>k</code> 代表当前的continuation(也就是 <code>call/cc</code> 调用时的 <code>continuation</code>), 现在当你应用该<br><code>continuation</code> 也就是使 用 <code>(k 4)</code> 时代码会立即从 <code>call/cc</code> 中返回, 并且返回值是 <code>4</code>, 注意它不会执行<br>前面的 (* 5), 所以不要以为是返回 20. 下面在举几个例子:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)<br>    (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>)))                           <span class="hljs-comment">;return 20</span><br><br>(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">2</span><br>   (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>    (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)<br>      (<span class="hljs-name"><span class="hljs-built_in">*</span></span> <span class="hljs-number">5</span> (<span class="hljs-name">k</span> <span class="hljs-number">4</span>)))))                    <span class="hljs-comment">;return 6</span><br><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> return <span class="hljs-literal">#f</span>)<br>(<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span><br>      (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (cont)<br>        (<span class="hljs-name"><span class="hljs-built_in">set!</span></span> return cont)<br>        <span class="hljs-number">1</span>)))                            <span class="hljs-comment">;return 2</span><br>(<span class="hljs-name">return</span> <span class="hljs-number">22</span>)                             <span class="hljs-comment">;return 23</span><br></code></pre></td></tr></table></figure><p>再来看一个比较不好懂的例子</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(((<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k) k))<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) x)) <span class="hljs-string">&quot;HEY!&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>(call/cc (lambda(k) k))</code> 返回当前的 <code>continuation</code>, 我假设该continuation为<br><code>cont</code>, 那么 <code>cont</code> 必然是一个escape procedure,而且可以看做是如下定义的:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (val)<br>  ((<span class="hljs-name">val</span><br>    (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) x)) <span class="hljs-string">&quot;HEY!&quot;</span>))<br></code></pre></td></tr></table></figure><p>所以原来的表达式也就等价于 <code>((cont (lambda(x) x)) &quot;HEY!&quot;)</code>,又因为cont是一个 escape<br>procedure,所以上面的表达式又等价于 <code>(cont (lambda(x) x))</code>,而该式很显 然返回 “HEY!“.</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>BREAK与RESUME, 通过BREAK来暂停, 通过RESUME来从暂停的位置启动.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> BREAK<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (message)<br>    (<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>               (<span class="hljs-name"><span class="hljs-built_in">set!</span></span> RESUME K^)<br>               ((<span class="hljs-name">lambda^</span> (x) x) message)))))<br></code></pre></td></tr></table></figure></li><li><p>exceptions 比如racket的异常处理设施, with-handlers以及raise</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(with-handlers ([predicate-expr handler-expr] ...)<br>  body ...+)<br></code></pre></td></tr></table></figure><p>下面是一个示例代码:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">always-fail</span> n)<br>    (<span class="hljs-name">with-handlers</span> ([<span class="hljs-name"><span class="hljs-built_in">even?</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v) <span class="hljs-symbol">&#x27;even</span>)]<br>                    [<span class="hljs-name"><span class="hljs-built_in">positive?</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v) <span class="hljs-symbol">&#x27;positive</span>)])<br>      (<span class="hljs-name">raise</span> n)))<br></code></pre></td></tr></table></figure><p>这种异常处理设施可以使用continuation来创建, 实际上就是将 body 部分放入 let&#x2F;cc中,<br>调用raise实际就是调用continuation</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> convert<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (exp)<br>    (<span class="hljs-name">match</span> exp<br>           [`(with-handlers ([,preds ,handlers] ...)<br>                            ,body ...)<br>            `(let ([ret (let/cc k^<br>                                ,@(map convert body))])<br>               (cond<br>                ,@(map (lambda (p h) `[(,p ret) (,h ret)]) preds handlers)<br>                ))]<br>           [`(raise ,val) `(k^ ,val)]<br>           [`(lambda (,uvar ...) ,body ...)<br>            `(lambda (,@uvar)<br>               ,@(map convert body))]<br>           [`(,f ,v ...)<br>            `(,(convert f)<br>              ,@(map convert v))]<br>           [`(if ,test ,conseq ,alt)<br>            `(if ,(convert test) ,(convert conseq) ,(convert alt))]<br>           [<span class="hljs-name">x</span> x])))<br></code></pre></td></tr></table></figure><p>上面这个函数就是将表达式中的with-handlers以及raise转换为continuation, 比 如下面的代码:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">convert</span> &#x27;(with-handlers ([even? (lambda (v) <span class="hljs-symbol">&#x27;even</span>)]<br>                          [positive? (lambda (v) <span class="hljs-symbol">&#x27;positive</span>)])<br>                         <span class="hljs-number">1</span><br>                         (raise <span class="hljs-number">11</span>)<br>                         <span class="hljs-number">2</span>))<br><span class="hljs-comment">;; =&gt;</span><br><span class="hljs-comment">;; &#x27;(let ((ret (let/cc k^ 1 (k^ 11) 2)))</span><br><span class="hljs-comment">;;    (cond</span><br><span class="hljs-comment">;;     ((even? ret) ((lambda (v) &#x27;even) ret))</span><br><span class="hljs-comment">;;     ((positive? ret) ((lambda (v) &#x27;positive) ret))))</span><br><br></code></pre></td></tr></table></figure><p>当然这个函数还有一些问题,但是我只是想演示一下异常处理设施的实现原理.</p></li><li><p>generators</p></li><li><p>coroutine</p></li></ol><h1 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h1><p><a href="http://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a>(continuation<br>passing style). 核心就是每一个函数都会带一个额外的参数<br>(continuation),前面说了continuation代表的是the rest of<br>computation, 因此这 个参数(continuation)代表了调用者需要对该函数的返回值进行的处理, 因此一个CPS<br>方式编写的函数最后都会使用函数的计算结果来调用你传递的那个continuation.</p><h2 id="自动CPS转换"><a href="#自动CPS转换" class="headerlink" title="自动CPS转换"></a>自动CPS转换</h2><p>一个自动进行CPS转换的宏</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> CPS<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> e1 e2))          <span class="hljs-comment">; other binary operators(- * / etc) are similar to +</span><br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> e1)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v1)<br>          ((<span class="hljs-name">CPS</span> e2)<br>           (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v2)<br>             (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> v1 v2)))))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> exp))        <span class="hljs-comment">;other unary operators(number?, string? etc) are similar to zero?</span><br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> exp)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (val)<br>          (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> val)))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">if</span></span> test conseq alt))<br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> test)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (v)<br>          (<span class="hljs-name"><span class="hljs-built_in">if</span></span> v<br>              ((<span class="hljs-name">CPS</span> conseq) k^)<br>              ((<span class="hljs-name">CPS</span> alt) k^)))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) body))<br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x)<br>             (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)<br>               ((<span class="hljs-name">CPS</span> body) k)))))]<br>    [(<span class="hljs-name">_</span> (<span class="hljs-name">app</span> arg))<br>     (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>       ((<span class="hljs-name">CPS</span> app)<br>        (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (f-val)<br>          ((<span class="hljs-name">CPS</span> arg)<br>           (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (arg-val)<br>             ((<span class="hljs-name">f-val</span> arg-val) k^))))))]<br>    [(<span class="hljs-name">_</span> v) (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^ ) (<span class="hljs-name">k^</span> v))]          <span class="hljs-comment">; basic values(number, string etc) must stay at last</span><br>    ))<br></code></pre></td></tr></table></figure><p>自动的CPS转换的要点</p><ol><li><p>首先任何表达式都要转换为 (lambda(k^) …) 的形式, 比如对一个常数表达式2, 你应该转换为 (lambda(k^) (k^<br>2))的形式, 这样做这是因为正在转换的表达式可 能是一个大的表达式中的子表达式, 所以应该把转换后的表达式传递给一个<br>continuation</p></li><li><p>对于lambda表达式, 以(lambda(x) x)为例, 因为它实际和常量一样, 所以应该这样 转换:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>  (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) x)))<br></code></pre></td></tr></table></figure><p>但是cps转换后lambda表达式是要接受两个参数, 也就是x与一个continuation, 所 以:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>  (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x dyn-k)<br>        ((<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k) (<span class="hljs-name">k</span> x))<br>         dyn-k))))<br><span class="hljs-comment">;;; a simple veraion</span><br>(<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k^)<br>  (<span class="hljs-name">k^</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x dyn-k)<br>        (<span class="hljs-name">dyn-k</span> x))))<br></code></pre></td></tr></table></figure><p>注意上面的k^是lambda表达式定义时的continuation, 而dyn-k是lambda表达式应用<br>时的continuation,因为应用时continuation可以不同所以它也就是动态的.</p></li></ol><h2 id="CPS的应用"><a href="#CPS的应用" class="headerlink" title="CPS的应用"></a>CPS的应用</h2><p>如果将一个解释器转换为CPS形式, 那么就可以很容易的实现像 scheme中call&#x2F;cc,<br>let&#x2F;cc这样可以获得当前continuation的结构, 因为解释器的continuation代表的解<br>释器接下来要进行的计算, 而解释器是用来模拟用户程序的, 所以实际上这个<br>continuation也可以看作是用户程序接下来要完成的计算,也就是用户程序当前的<br>continuation.</p><h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1><ol><li><a href="https://www.wikiwand.com/en/Call-with-current-continuation">wikipedia:<br>Call-with-current-continuation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lisp</tag>
      
      <tag>PL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/notes/nginx/"/>
    <url>/notes/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx的安装"><a href="#nginx的安装" class="headerlink" title="nginx的安装"></a>nginx的安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接使用ubuntu仓库中的nginx,不过版本有点陈旧,下面说一说编译安装, 编译安 装是非常典型的configure, make,<br>make install模式, 我只说一说configure的常用选 项.</p><ol><li>–prefix: nginx的安装目录</li><li>–with-XXX_XXX: 需要开启的模块</li></ol><p>添加第三方模块,使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs example">./configure --add-module=/path/to/your-module<br></code></pre></td></tr></table></figure><h2 id="重新编译安装"><a href="#重新编译安装" class="headerlink" title="重新编译安装"></a>重新编译安装</h2><p>有时候我们发现nginx缺少模块,需要重新编译安装, 那么使用如下步骤:</p><ol><li>使用configure, make编译, 不要运行make install, 因为这是重新安装会覆盖掉我 们的配置文件</li><li>将得到的nginx二进制程序直接覆盖旧版本的nginx程序,该程序一般在sbin目录,为 了保险,你可以先备旧版的nginx程序.</li><li>使用 <code>nginx -t</code> 测试nginx程序是否正确</li><li>使用 <code>nginx -s reload</code> 来重载nginx.</li></ol><h2 id="nginx的配置目录布局"><a href="#nginx的配置目录布局" class="headerlink" title="nginx的配置目录布局"></a>nginx的配置目录布局</h2><p>使用ubuntu的apt安装的nginx的配置一般有如下的目录格式</p><ol><li><p>nginx.conf包含了基本的http配置，同时会有如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs example">http &#123;<br><br>    .....<br><br>    include /etc/nginx/conf.d/*.conf;<br>    include /etc/nginx/sites-enabled/*;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它会包含conf.d 目录的配置，以及sites_enabled目录的所有配置</p></li><li><p>conf.d： 该目录的所有conf文件都会被包含</p></li><li><p>sites-available: 这个目录的每一个文件应该配置一个server, 也就是一个虚拟机,<br>其中有一个默认的配置default.</p></li><li><p>sites-enabled: 都是符号链接，指向sites-availabe目录的配置，通过这些符号链<br>接你可以有选择的开启sites-availabe中的server。</p></li></ol><h1 id="nginx的基础知识"><a href="#nginx的基础知识" class="headerlink" title="nginx的基础知识"></a>nginx的基础知识</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ol><li>upstream（上游）: 是指nginx后端的服务, 比如tornado, redis等等</li><li>downstream(下游): 指浏览器, 或者其它向nginx请求服务的程序.</li><li>主请求(main request): 由 HTTP 客户端从 Nginx 外部发起的请求.</li><li>子请求(subrequest): 由 Nginx 正在处理的请求在 Nginx 内部发起的一种级联请 求, 子请求的变量是独立的,<br>和父请求互不干扰.</li><li>内部跳转: 使用rewrite,echo_exec等指令执行的跳转, 它的作用原理是直接修改 url, 然后跳回find config<br>phase, 所以它就会使用修改后的url去匹配location, 然后接着执行rewrite等一系列phase.</li></ol><h2 id="phase"><a href="#phase" class="headerlink" title="phase"></a>phase</h2><p>一个http请求会依次经过如下11个phase:</p><ol><li>post read: 接收完请求头之后的第一个阶段,它位于uri重写之前, 实际上很少有 模块会注册在该阶段,默认的情况下,<br>该阶段被跳过.</li><li>server rewrite: server级别的uri重写阶段, 如果set, rewrite等ngx_rewrite模<br>块的指令放在server内,但在location外,那么就运行于该阶段.</li><li>find config: 寻找location配置阶段,该阶段使用重写之后的uri来查找对应的<br>location,值得注意的是该阶段可能会被执行多次,因为也可能有location级别的重<br>写指令, <strong>该阶段不允许模块注册</strong>.</li><li>rewrite: location级别的uri重写阶段,该阶段执行location基本的重写指令,也 可能会被执行多次. set,<br>rewrite等指令如果放在location内部,那么就运行于该阶 段.</li><li>post rewrite: location级别重写的后一阶段, 用来检查上阶段是否有使用rewrite 指令来i进行uri重写,<br>如果有那么就跳回find configphase, 这就是一个内部跳转, <strong>该阶段不允许模块注册</strong>.</li><li>preaccess: 访问权限控制的前一阶段，该阶段在权限控制阶段之前，一般也用于访 问控制，比如限制访问频率，链接数等；</li><li>access: 访问权限控制阶段, 比如基于ip黑白名单的权限控制, 基于用户名密码的 权限控制等.</li><li>post access: 访问权限控制的后一阶段,该阶段根据权限控制阶段的执行结果进行 相应处理. <strong>该阶段不允许模块注册</strong>.</li><li>try files: try_files指令的处理阶段，如果没有配置try_files 指令，则该阶段被跳过,<br><strong>该阶段不允许模块注册</strong>.</li><li>content: 内容生成阶段, 该阶段产生响应, 并发送到客户端. 如果location中没有<br>任何像echo,content_by_lua这样运行于content phase的指令,那么nginx会把当前 请求的<br>URI 映射到文件系统的静态资源服务模块, 如果文件系统没有对应的文件那 么返回404</li><li>log: 日志记录阶段, 该阶段记录访问日志.</li></ol><p>还有一个特殊的phase: <strong>body filter</strong>, 严格的说它不是一个phase, 任何时候输出响应 体时都会运行该阶段的指令.<br>该phase可能执行多次,因为输出时是分多次写的,一次一 个chunk.</p><h2 id="phases与指令的关系"><a href="#phases与指令的关系" class="headerlink" title="phases与指令的关系"></a>phases与指令的关系</h2><p>几乎所有的指令都与某一个phase相关联, 指令的实际执行顺序是这样决定的:</p><ol><li>如果两条指令在不同的phase, 那么指令的执行顺序与phase的先后顺序相同, 比如 set运行于rewrite phase,<br>而echo运行于content phase, 所以不论配置中set, echo的顺序如何, set必定在echo的前面执行.<br><strong>建议书写配置时按照指令实际执行 顺序来书写</strong>.</li><li>如果两条指令运行于相同的phase, 那么它们的执行顺序就比较混乱了. 有几种情 况:<ol><li>有些指令是按照书写顺序来执行的, 比如set, set_unescape_uri, set_by_lua 等</li><li>绝大多数第三方模块只能运行于所属phase的结尾,所以内置模块的指令必定早于 第三方模块指令的执行,<br>因此rewrite必定在rewrite_by_lua前面执行.<br>set_by_lua之所以能和内置的set指令交叉执行,是因为使用了一些特殊技巧</li><li>content phase只能注册一个处理器,所以不要同时使用不同模块的content指令,<br>比如echo指令就不能与content_by_lua指令共存,而且同一模块的content指令能<br>不能多次使用也是依模块而定, echo指令可以多次使用, content_by_lua就不行。</li></ol></li></ol><h2 id="nginx如何匹配请求"><a href="#nginx如何匹配请求" class="headerlink" title="nginx如何匹配请求"></a>nginx如何匹配请求</h2><p>实际先匹配server块, 接着匹配该server块中的location.</p><h3 id="匹配server块"><a href="#匹配server块" class="headerlink" title="匹配server块"></a>匹配server块</h3><ol><li>匹配listen指令<ul><li>每个server块的listen指令如果不完整, 比如缺少ip或者缺少port, 那么用默认 值补充完整,<br>ip的默认值是0:0:0:0, port的默认值是80.</li><li>使用请求的ip与port来匹配server块的listen指令, 如果最后只有一个server匹<br>配那么就使用该server处理请求,<br>如果有多个server那么就检查server_name指令.</li></ul></li><li>匹配server_name指令（前提是有多个server的listen指令成功匹配请求的ip与 port）<ul><li>获取请求的Host请求头</li><li>先精确匹配, 如果匹配成功那么选择该server, 如果有多个那么选第一个</li><li>匹配有*通配符 <strong>前缀</strong> 的server_name, 比如 <code>*.example.com</code>, 通配符必须 在前面</li><li>匹配有*通配符 <strong>后缀</strong> 的server_name, 比如 <code>www.example.*</code>, 通配符必须 在后面</li><li>正则匹配</li><li>使用默认的server</li></ul></li></ol><h3 id="匹配location"><a href="#匹配location" class="headerlink" title="匹配location"></a>匹配location</h3><p>实际上是根据location后面的url来匹配, 该rul会有一些前缀来标示url的类型(正则 或者非正则,<br>非正则会区分是精确匹配或者前缀匹配, 正则规则又会区分大小写),<br>具体的规则如下:</p><ol><li>无前缀: 匹配前缀(非正则)</li><li>^~ : 匹配前缀, 如果有一个 正则规则也匹配这个uri,优先采用该规则(非正则)</li><li>= : 精确匹配, 也就是说要一模一样(优先级最高, 非正则)</li><li>~ : 正则,区分大小写</li><li>~* : 正则, 不区分大小写</li><li>!~ : 和 ~ 作用相反</li><li>!~* : 和 ~* 作用相反</li></ol><p>匹配规则的优先级:</p><ol><li>先进行非正则匹配<ul><li>如果有 &#x3D;前缀 规则匹配, 那么使用该规则, 如果没有那么看下一条</li><li>如果最长前缀匹配的规则含有 ^~ 前缀, 那么使用该规则, 如果没有看下一条</li><li>将最长前缀匹配的规则保存起来, 然后使用正则表达式来匹配</li></ul></li><li>正则匹配, 直接根据位置的从上到下来匹配,第一条匹配的规则会被使用, 如果没有<br>匹配,那么就使用上面保存的最长匹配的非正则规则,如果该规则也不存在那么404.</li></ol><p>大体上你可以认为优先级是: &#x3D;规则 &gt; ^~规则 &gt; 正则规则 &gt; 无前缀规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = / &#123;&#125;                 <span class="hljs-comment"># 只匹配/, 不会匹配/xxx</span><br>location / &#123;&#125;<br>location ^~ /images/ &#123;&#125;<br>location ~* \.(gif|jpg|jpeg)$ &#123;&#125; <span class="hljs-comment"># 匹配所有图像文件</span><br></code></pre></td></tr></table></figure><h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><p>nginx配置的基本结构是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs example">......<br>events &#123;<br>......<br>&#125;<br><br>http &#123;<br>......<br>   server &#123;<br>   ......<br>      location ... &#123;<br>      ......<br>      &#125;<br>      location ... &#123;<br>      ......<br>      &#125;<br>    &#125;<br><br>   server &#123;<br>   ......<br>   &#125;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最外层"><a href="#最外层" class="headerlink" title="最外层"></a>最外层</h2><ol><li>user: 指定worker进程的用户名以及用户组</li><li>worker_processes: woker进程的数量,一般和CPU的核数一样</li><li>worker_rlimit_nofile: worker进程能打开的文件描述符数量.</li></ol><h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p>主要是配置事件相关</p><ol><li>worker_connections: 允许的连接数</li><li>use epoll : 事件循环,linux一般是epoll.</li></ol><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>一些http相关的配置</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>配置虚拟机, 最重要的是它的listen,server_name指令, 很多主机商就是用这种配置来<br>用一台机器服务多个网站的,配置多个server块,<br>每一个块的server_name改为对应的域 名, 那么就可以支持多个网站.</p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>这个块主要是指定对特定url的操作, location后面有一个url参数, 该参数就是用来匹<br>配http请求的url的,如果匹配成功,那么就执行对应的块中的指令.</p><h1 id="nginx的变量"><a href="#nginx的变量" class="headerlink" title="nginx的变量"></a>nginx的变量</h1><p>nginx变量是在nginx启动时创建, 而在请求中赋值的,变量在每一次请求中都有一个单独 的副本(<strong>子请求也会有单独的副本</strong>),<br>同时变量的生命周期与请求绑定,与location块无 关,不要想当然的认为它和程序语言的静态作用域相同.请看如下例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen 8080;<br>    location /foo &#123;<br>         <span class="hljs-built_in">set</span> <span class="hljs-variable">$a</span> hello;<br>         echo_exec /bar;<br>    &#125;<br>    location /bar &#123;<br>         <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a = [<span class="hljs-variable">$a</span>]&quot;</span>;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>在nginx启动时,它发现了set指令,所以它会创建$a这个变量, 可是这时变量是空的,同时 该变量全局可见,每一个请求都会有一个该变量的副本,<br>所以你访问&#x2F;bar会得到空值, 而 访问&#x2F;foo会得到hello, 因为你在&#x2F;foo中对$a进行了赋值.</p><h2 id="nginx的内置变量"><a href="#nginx的内置变量" class="headerlink" title="nginx的内置变量"></a>nginx的内置变量</h2><ol><li>$request_uri: 未解码的uri,包含query string</li><li>$uri: 已解码的uri, 不包含query string</li><li>$arg_XXX: 用来获得get传递的参数, 将XXX替换未参数名. 比如访问<br><code>http://localhost:8080/test?name=Tom&amp;class=3</code>, 那么$arg_name的值就是<br>Tom.注意返回的值是未解码形式.</li><li>$args:　请求中问号后面的部分, 也就是query string</li></ol><h2 id="常见的指令"><a href="#常见的指令" class="headerlink" title="常见的指令"></a>常见的指令</h2><ol><li>set: 创建nginx变量并且赋值(rewrite phase)</li><li>set_unescape_uri: 创建nginx变量,但是会将值解码后赋给该变量(rewrite phase)</li><li>set_escape_uri: 创建nginx变量,但是会将值编码后赋给该变量(rewrite phase)</li></ol><h1 id="nginx常用模块"><a href="#nginx常用模块" class="headerlink" title="nginx常用模块"></a>nginx常用模块</h1><h2 id="map-ngx-http-map-module"><a href="#map-ngx-http-map-module" class="headerlink" title="map(ngx_http_map_module)"></a>map(ngx_http_map_module)</h2><ol><li><p>map: <code>map string $variable &#123; ... &#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">map <span class="hljs-variable">$http_user_agent</span> <span class="hljs-variable">$bad_client</span> &#123;<br>    default            0;<br>    <span class="hljs-string">&quot;~*Baiduspider&quot;</span>    1;<br>    <span class="hljs-string">&quot;~*360Spider&quot;</span>      1;<br>    <span class="hljs-string">&quot;~*Yandex&quot;</span>         1;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果请求user_agent匹配baidu, 360, yandex特征,那么将bad_client变量设为1,默 认为值0,<br>这样你可以在配置中使用 <code>if ($bad_client) &#123; return 403; &#125;</code> 来拦截 这些机器人的访问.</p></li></ol><h2 id="GEO-ngx-http-geo-module"><a href="#GEO-ngx-http-geo-module" class="headerlink" title="GEO(ngx_http_geo_module)"></a>GEO(ngx_http_geo_module)</h2><p>可以根据客户端的ip来设置变量的值, 只能放在http块中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">geo <span class="hljs-variable">$geo</span> &#123;<br>    default        0;<br><br>    127.0.0.1      2;<br>    192.168.1.0/24 1;<br>    10.1.0.0/16    1;<br><br>    ::1            2;<br>    2001:0db8::/32 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据客户端的ip会对geo变量赋值. 这在拦截一些ip地址是有用. 和map配合可以拦截ip 与user-agent,<br>可以看这个<a href="https://github.com/oohnoitz/nginx-blacklist">nginx-blacklist</a><br>项目.</p><h2 id="Access-ngx-http-access-module"><a href="#Access-ngx-http-access-module" class="headerlink" title="Access(ngx_http_access_module)"></a>Access(ngx_http_access_module)</h2><p>用来对请求进行权限检查</p><ol><li>allow</li><li>deny</li></ol><p>会书写顺序检查allow,deny指令，直到第一个匹配。如果有不同的模块也加入了检查比 如access_by_lua, 那么<br><code>satisfy</code> 指令可以规定这些access模块如何协作， 该指令 的值只能为all或者any。</p><ul><li>all： 必须通过所有access模块的检查（默认）</li><li>any： 只要通过任何一个access模块的检查就好</li></ul><h2 id="Rewrite-ngx-http-rewrite-module"><a href="#Rewrite-ngx-http-rewrite-module" class="headerlink" title="Rewrite(ngx_http_rewrite_module)"></a>Rewrite(ngx_http_rewrite_module)</h2><p>该模块的指令如果放在server中,那么运行在server rewrite阶段, 如果放在location 中,那么就运行在rewrite阶段</p><ol><li><p>set: 创建变量</p></li><li><p>if: <code>if (condition) &#123; ... &#125;</code>, if是非常诡异的指令,能不用就尽量不用,一般来说<br>if只有在location中,并且在以下两种情况才100%正确:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span>(condition)&#123;<br>    <span class="hljs-built_in">return</span> status_code<br>&#125;<br><br><span class="hljs-keyword">if</span>(condition) &#123;<br>    <span class="hljs-comment"># other things</span><br>    rewrite xxx xxx             <span class="hljs-comment"># must stay last in if block</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>return: 原型如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">return code [text];<br>return code URL;<br>return URL;<br></code></pre></td></tr></table></figure><p>直接终止请求, 返回相应的code,或者重定向到url(30X)</p></li><li><p>rewrite: 用来重写url</p></li><li><p>break: 如果在if中,那么跳出if, 如果在location,那么忽略后面的Rewrite模块的 指令,直接进入下一phase.</p></li></ol><h2 id="Echo-ngx-http-echo-module"><a href="#Echo-ngx-http-echo-module" class="headerlink" title="Echo(ngx_http_echo_module)"></a>Echo(ngx_http_echo_module)</h2><p>这是第三方模块,提供了一些类似于shell的命令, 该模块的大部分指令运行于content phase. 常用的指令:</p><ol><li><p>echo: 输出内容到客户端(content phase)</p></li><li><p>echo_exec: 执行内部跳转(类似于rewrite,不过运行于content phase)</p></li><li><p>echo_location: 执行一个子请求(HTTP GET), 将子请求的结果发送到client,有点类<br>似于ngx_lua模块中的指令ngx.location.capture.<br>只是ngx.location.capture更灵 活,因为它可以做后续处理,而不是直接将结果发送到client.</p></li><li><p>echo_location_async: 和echo_location不过是异步的(HTTP GET), 也就是说主请<br>求很有可能在子请求之前结束. 但是nginx会保证输出指令的执行顺序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /main &#123;<br>        echo_reset_timer;<br>        echo_location_async /sub1;<br>        echo_location_async /sub2;<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;took <span class="hljs-variable">$echo_timer_elapsed</span> sec for total.&quot;</span>;<br>    &#125;<br>    location /sub1 &#123;<br>        echo_sleep 2; <span class="hljs-comment"># sleeps 2 sec</span><br>        <span class="hljs-built_in">echo</span> hello;<br>    &#125;<br>    location /sub2 &#123;<br>        echo_sleep 1; <span class="hljs-comment"># sleeps 1 sec</span><br>        <span class="hljs-built_in">echo</span> world;<br>    &#125;<br></code></pre></td></tr></table></figure><p>main虽然可能在子请求的前面结束,但是sub1, sub2,main的输出顺序nginx会保证, 因此输出会是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">hello<br>world<br>took 0.000 sec for total.<br></code></pre></td></tr></table></figure><p>该指令有点类似于ngx_lua模块的ngx.location.capture_multi指令.</p></li></ol><h1 id="nginx与lua"><a href="#nginx与lua" class="headerlink" title="nginx与lua"></a>nginx与lua</h1><p>将lua解释器嵌入到nginx, 使用lua可以比较轻松的实现一些业务逻辑, 这样就可以将<br>nginx从一个单纯的http服务器变成一个web应用服务器,在配合nginx高效的IO模型,性能<br>十分强大. 对于逻辑不复杂的业务直接使用lua在nginx这层实现是个不错的选择.</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>依赖于luajit,也可以使用lua, 不过luajit性能更好, ubuntu上可以使用如下命令安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libluajit-5.1-dev<br></code></pre></td></tr></table></figure><p>同时也依赖 <code>ngx_devel_kit</code> 这个模块, 这个模块即便是tengine也需要静态编译,因 为它不是http模块, 这个模块会被<br><code>set_by_lua</code> 指令用到.</p><ol><li><p>nginx安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure  --add-module=/path/to/ngx_lua \<br>             --add-module=/path/to/ngx_devel_kit<br></code></pre></td></tr></table></figure></li><li><p>tengine上安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure  --with-http_lua_module \<br>             --add-module=/path/to/ngx_devel_kit<br></code></pre></td></tr></table></figure></li></ol><h2 id="常用指令-nginx配置中使用"><a href="#常用指令-nginx配置中使用" class="headerlink" title="常用指令(nginx配置中使用)"></a>常用指令(nginx配置中使用)</h2><ol><li>set_by_lua: 作用于rewrite phase, 和set指令类似, 只是值是由lua脚本产生的,<br>该指令可以和set交叉运行</li><li>rewrite_by_lua: 作用于nginx的rewrite phase. 运行于rewrite phase的最后,<br>ngx_rewrite模块的指令总是先于该指令.</li><li>access_by_lua: 作用于nginx的access phase, 一般来说如果需要在请求开始之前<br>做一些处理,比如检查请求合法性,可以使用这条命令</li><li>content_by_lua: 作用于content phase, 是用来生成发送给客户端的内容的</li><li>log_by_lua: 作用于log phase, 一般用来对请求做一些善后处理,记住在该指令之<br>前nginx已经将内容发送到客户端.</li></ol><h2 id="lua中能使用的API"><a href="#lua中能使用的API" class="headerlink" title="lua中能使用的API"></a>lua中能使用的API</h2><p>ngx_lua暴露给lua的api都被放在ngx这个全局变量中,这是官方<a href="http://wiki.nginx.org/HttpLuaModule">文档</a><br>其中比较常用的有 这些,(<strong>特别要注意这些api所在phase,这是使用任何nginx模块都需要特别注意的</strong>)</p><ol><li><p>ngx.var.XXX: 所有nginx的变量都可以通过这种方式访问</p></li><li><p>ngx.ctx: 这是一个表, 它的生命周期和请求绑定, 请求结束了,其中记录的数据也<br>就无效了,经常用来在运行于不同的phase的lua脚本间传递数据.</p></li><li><p>ngx.location.capture: 发起一个子请求, 一些场景很有用,比如说你对<br>redis,mysql等服务进行了rest包装,而在一个请求中你想从多个服务中获得数据,就<br>可以用这个api发送子请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs example">location = /memc &#123;<br>    internal;<br>    memc_pass ...;<br>&#125;<br>location = /api &#123;<br>    content_by_lua &#x27;<br>        local resp = ngx.location.capture(&quot;/memc&quot;)<br>        if resp.status ~= 200 then<br>            ngx.exit(500)<br>        end<br>        ngx.say(resp.body)<br>    &#x27;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>/api</code> 中你可以获得 <code>/mem</code> 的结果, 当然你可以接着获得其它服务的结果.</p></li><li><p>ngx.location.capture_multi: 和capture类似,只是可以并发的发起多个子请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs example">location = /api &#123;<br>    content_by_lua &#x27;<br>        local res1, res2, res3 =<br>            ngx.location.capture_multi&#123;<br>                &#123;&quot;/memc&quot;&#125;, &#123;&quot;/mysql&quot;&#125;, &#123;&quot;/postgres&quot;&#125;<br>            &#125;<br>        ngx.say(res1.body, res2.body, res3.body)<br>    &#x27;;<br>&#125;<br></code></pre></td></tr></table></figure><p>并发的发起三个子请求.</p></li><li><p>ngx.status: 当前请求的response的HTTP状态码, 你可以修改状态码,但是前提是你<br>必须在nginx将response发送给client之前修改</p></li><li><p>ngx.req.XXX: 用来操作request的一系列api</p></li><li><p>ngx.say: 每一条命令都有一个换行符</p></li><li><p>ngx.print: 和say类似,没有换行符.</p></li><li><p>ngx.log: 记录日志</p></li><li><p>ngx.exec: 发起一个内部跳转(浏览器的url不改变), 类似于nginx的rewrite指令</p></li><li><p>ngx.redirect: 发起一个浏览器跳转(30X, 浏览器的url会改变)</p></li><li><p>ngx.exit(status_code): 直接退出请求</p></li><li><p>ngx.re.XXX: 正则相关,标准lua本身是不支持正则的.</p></li></ol><h2 id="lua数据共享"><a href="#lua数据共享" class="headerlink" title="lua数据共享"></a>lua数据共享</h2><ol><li>请求级别: 使用ngx.ctx, 它是一个table, 你可以使用它来在同一请求的不同的 phase间传递数据</li><li>worker进程级别: 可以创建一个lua模块,在模块内部创建一个表,因为lua解释器在 worker进程启动后就常驻内存,<br>所以这个表在进程内部一直有效. 因此你可以使用 这种方法在该进程处理的不同请求间共享数据.</li><li>nginx级别: 因为nginx是多进程架构, 为了在多个worker进程间共享数据必须用到 IPC机制,<br>ngx_lua使用share memory实现了一个ngx.shared.DICT, 内部是使用自旋<br>锁来避免竞争条件,该结构有get,set,incr,delete等api,<br>使用比较简单, 为了高效 的利用此api, 数据的大小应该尽量一致,特别不同的数据应该用不同的dict存放,主要<br>是为了减少碎片</li></ol><h2 id="lua-socket"><a href="#lua-socket" class="headerlink" title="lua socket"></a>lua socket</h2><p>ngx_lua实现了一个socket库,它能以非阻塞的形式进行网络操作. 利用这个库我们可以 直接访问upstream的服务,比如redis,<br>memcache等, 也可以访问tornado这样的上游服 务,只不过tornado需要使用http协议而已,<br><strong>注意该库的api基本都只能运行于 rewrite_by_lua,<br>access_by_lua, content_by_lua,ngx.timer中</strong>, 该库的api分为两 类tcp和udp.</p><h3 id="TCP-SOCKET"><a href="#TCP-SOCKET" class="headerlink" title="TCP SOCKET"></a>TCP SOCKET</h3><ol><li><p>创建tcp socket对象, 使用ngx.socket.tcp来创建, <code>local sock = ngx.socket.tcp()</code></p></li><li><p>connect: 可以使用hostname&#x2F;ip, port, 也可以使用unix socket文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ok, err = sock:connect(<span class="hljs-string">&quot;www.google.com&quot;</span>, <span class="hljs-number">80</span>)<br><span class="hljs-keyword">local</span> ok, err = sock:connect(<span class="hljs-string">&quot;220.181.57.216&quot;</span>, <span class="hljs-number">80</span>)<br><span class="hljs-keyword">local</span> ok, err = sock:connect(<span class="hljs-string">&quot;unix:/tmp/memcached.sock&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>   check_error()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>如果使用域名,那么必须在nginx.conf中配置dns, 加入这一行: <code>resolver     8.8.8.8;</code>, dns常见的有这几个:</p><ul><li>google: 8.8.8.8</li><li>alibaba: 223.5.5.5 或者 223.6.6.6</li><li>114DNS: 114.114.114.114</li></ul></li><li><p>send: 发送数据, 一定要先设置超时, 如果成功那么返回发送的数据量,如果失败 那么返回nil,以及一个错误消息字符串,<br>出错时socket会自动关闭,无需手动清理</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">sock:settimeout(<span class="hljs-number">1000</span>)  <span class="hljs-comment">-- one second timeout</span><br><span class="hljs-keyword">local</span> bytes, err = sock:send(request)<br></code></pre></td></tr></table></figure></li><li><p>receive</p></li></ol><p>很常规的client编程模式,上述调用都是非阻塞的,它对使用者来说是透明的, 下面是 示例代码:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">sock:settimeout(<span class="hljs-number">1000</span>)  <span class="hljs-comment">-- one second timeout</span><br><span class="hljs-keyword">local</span> line, err, partial = sock:receive()<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line <span class="hljs-keyword">then</span><br>   ngx.say(<span class="hljs-string">&quot;failed to read a line: &quot;</span>, err)<br>   <span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br>ngx.say(<span class="hljs-string">&quot;successfully read a line: &quot;</span>, line)<br></code></pre></td></tr></table></figure><h3 id="UDP-SOCKET"><a href="#UDP-SOCKET" class="headerlink" title="UDP SOCKET"></a>UDP SOCKET</h3>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux平台C语言乱码</title>
    <link href="/articles/linux-c-messy-code/"/>
    <url>/articles/linux-c-messy-code/</url>
    
    <content type="html"><![CDATA[<h2 id="文件加载到显示的过程"><a href="#文件加载到显示的过程" class="headerlink" title="文件加载到显示的过程"></a>文件加载到显示的过程</h2><p>只要是用过linux的人都应该遇到过乱码的问题，众所周知，乱码的产生的主要原因是编<br>码的问题，以B编码方式去读取以A编码方式编码的文件时就会产生乱码，文件读取到显示<br>的过程可以简单的用下图表表示：</p><p><img src="/articles/linux-c-messy-code/static/img/how-to-show-file.png"></p><ul><li>第一步是将文件读入内存，这一步可以看作是直接将文件的二进制形式的表示直接复制 进内存，就是将你用十六进制工具看到的那些东西复制进内存，</li><li>第二步是显示终端将内存中的数据以某种编码方式解码显示出来</li></ul><h2 id="linux乱码产生的原因"><a href="#linux乱码产生的原因" class="headerlink" title="linux乱码产生的原因"></a>linux乱码产生的原因</h2><p>在linux下显示终端的默认编码方式一般是utf8，而中文windows产生的文件默认编码则<br>是gb2312，linux首先读取文件到内存,这时内存中的数据是对原始消息使用gb2312编码<br>得到的,然后显示终端使用utf8解码这些信息,所以自然就无法得到正确的原始信息,也 就是产生了乱码.</p><h2 id="如何避免乱码"><a href="#如何避免乱码" class="headerlink" title="如何避免乱码"></a>如何避免乱码</h2><p>从上面的讨论可以看出，在linux下要不产生乱码，必须让内存中的二进制数据是对原<br>始信息通过utf8编码得到的，那么如何保证这一点呢，有两种方式，一种是让文件本身<br>是utf8编码的，这样读入内存后在以utf8解码后得到的信息肯定一样，也就是不会有乱<br>码，第二种是直接在内存中转换，假设我读一个以gb2312编码的文件，在内存中得到一<br>个缓冲区buf，如果你直接将buf传送给显示终端的话，那么显示终端就会以utf8对buf<br>的二进制数据解码，那么就会产生乱码，因为buf的二进制数据是以gb2312对原始信息<br>编码得到的，那么我要正常显示，则必须将buf中的二进制数据转换为将原始信息以 utf8编码得到的二进制信息，这里分两种情况讨论:</p><ol><li><p>文本文件的编码格式是utf8，这种情况可以直接用c语言读取显示，不会产生乱码， 所以不过多赘述</p></li><li><p>文本文件的编码是gb2312，那么直接用C语言操作时就会产生乱码，这种情况的解决方<br>式主要有两种，第一种就是运行程序之前将要操作的文本文件转换为utf8，打开shell，<br>输入以下命令:</p><p><code>iconv -f gb2312 -t utf8 youfile -c -o newfile</code></p></li></ol><p>其中youfile是要转换的文件，newfile就是得到的utf8编码的文件，其中c这个参数建议加上，<br>它可以忽略无效的字符，比如可以忽略utf8文件里的BOM，下面贴一段转换歌词编码的脚本给大<br>家参考:</p><figure class="highlight bash"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> *.lrc<br><span class="hljs-keyword">do</span><br>    is_utf8=$(file <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> | grep <span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$is_utf8</span>&quot;</span> ]<br>    <span class="hljs-keyword">then</span><br>        iconv -f gb2312 -t utf8 <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> -c -o tmp_lrc &amp;&amp; <span class="hljs-built_in">rm</span> -f <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br>        <span class="hljs-built_in">mv</span> tmp_lrc <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">continue</span>;<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>功能就是将一个目录里扩展名为lrc的文件编码转换为utf8</p><p>这种方式有个弊端就是文件必须提前转换编码，如果程序是给别人使用，我们不可能要求别<br>人先将文件的编码转换好在运行程序，那么有没有什么办法可以直接在C程序里进行转换呢？<br>下面就看看如何在程序中进行转换，先看代码:</p><figure class="highlight c"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iconv.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 1024</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    FILE *fp = fopen(<span class="hljs-string">&quot;she.lrc&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">char</span> dest[MAXLINE];<br>    <span class="hljs-type">char</span> *in = buf;<br>    <span class="hljs-type">char</span> *out = dest;<br>    fgets(buf,MAXLINE,fp);<br><br>    <span class="hljs-type">iconv_t</span> cd = iconv_open(<span class="hljs-string">&quot;UTF-8&quot;</span>,<span class="hljs-string">&quot;GBK&quot;</span>);<br>    <span class="hljs-type">int</span> lenght = MAXLINE;<br>    iconv(cd,&amp;in,&amp;lenght,&amp;out,&amp;lenght)<br>    iconv_close(cd);<br>    <span class="hljs-built_in">fputs</span>(dest,<span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序只是为了测试，所以有些错误处理代码去掉了，其中she.lrc是一个以gb2312编码<br>的歌词文件，用到了3个函数，icon_open,iconv,icon_close,这三个函数是libiconv库的接<br>口，这三个函数的详细介绍清参考:</p><ul><li><a href="http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv_open.3.html">ICONV_OPEN</a></li><li><a href="http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv.3.html">ICONV</a></li><li><a href="http://www.gnu.org/savannah-checkouts/gnu/libiconv/documentation/libiconv-1.13/iconv_close.3.html">ICONV_CLOSE</a></li></ul><p>这三个函数的帮助文档也可以直接man，很详细，使用的顺序也是先调<br>用iconv_open创建描述符，然后调用iconv转换，最后调用iconv_close<br>关闭描述符，函数原型为：</p><figure class="highlight c"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">iconv_t</span> <span class="hljs-title function_">iconv_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *tocode, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fromcode)</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">iconv</span><span class="hljs-params">(<span class="hljs-type">iconv_t</span> cd,</span><br><span class="hljs-params">                    <span class="hljs-type">char</span> **inbuf, <span class="hljs-type">size_t</span> *inbytesleft,</span><br><span class="hljs-params">                    <span class="hljs-type">char</span> **outbuf, <span class="hljs-type">size_t</span> *outbytesleft)</span>;<br> <span class="hljs-type">int</span> <span class="hljs-title function_">iconv_close</span><span class="hljs-params">(<span class="hljs-type">iconv_t</span> cd)</span>;<br></code></pre></td></tr></table></figure><p>其中fromcode和tocode是编码方式，shell下输入iconv –list会列出支持的编码方式。</p>]]></content>
    
    
    <categories>
      
      <category>articles</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Client-Side javascript</title>
    <link href="/notes/client-javascript/"/>
    <url>/notes/client-javascript/</url>
    
    <content type="html"><![CDATA[<h1 id="js运行方式"><a href="#js运行方式" class="headerlink" title="js运行方式"></a>js运行方式</h1><ol><li><code>&lt;script&gt;…..&lt;/script&gt;</code>内嵌</li><li><code>&lt;script src=&quot;path-to-js-file&quot;\&gt; &lt;/script&gt;</code> 外部js文件</li><li>事件处理，比如button的 onclick, onmouseover等等</li><li>javascript urls<ul><li><p>任何能使用url的地方，比如 a 标签的href，form的action使用如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript: alert(&#x27;hello world&#x27;);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这相当于单行代码，以javascript：开头，告诉浏览器下面的是js代码，当这行js有返回值时，firefox会替换掉当<br>前的页面为js的执行结果，所以如果要阻止这种行为，那么可以统一在js代码的前面加上void ，比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void new Date().toLocaleTimeString();&quot;</span>&gt;</span>Check the time without overwriting the document<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Bookmarklets 加入书签，那么这段代码就相当于直接插入了当前页面，比如订阅到鲜果的书签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">javascript</span>:<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;http://xianguo.com/subscribe?url=&#x27;</span>+<span class="hljs-built_in">encodeURIComponent</span>(location.<span class="hljs-property">href</span>), <span class="hljs-string">&#x27;xianguo&#x27;</span>);<span class="hljs-title function_">void</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="global-window-object"><a href="#global-window-object" class="headerlink" title="global window object"></a>global window object</h1><h2 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h2><ol><li>setTimeout(callback, timeout) :<br>只运行一次callback，返回值可以传递给clearTimeout来清除定时器</li><li>clearTimeout()</li><li>setInterval(callback, interval) :<br>每隔interval就运行一次callback,返回值可以传递给clearInterval来清除定<br>时器</li><li>clearInterval()</li></ol><h2 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h2><p>window.location指向一个Location object,这个object有一系列的属性,以<br><a href="http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&amp;m=10#results">http://www.oreilly.com:1234/catalog/search.html?q=JavaScript&amp;m=10#results</a><br>为例</p><ol><li>href: 整个url,如果对该属性赋值,则可以重定向到新url</li><li>protocal: ‘http:’</li><li>host: ‘<a href="http://www.oreilly.com:1234/">http://www.oreilly.com:1234</a>‘</li><li>hostname: ‘<a href="http://www.oreilly.com/">http://www.oreilly.com</a>‘</li><li>port: ‘1234’ 是一个字符串,不是数字</li><li>pathname: ‘&#x2F;catalog&#x2F;search.html’</li><li>search: ‘?q&#x3D;JavaScript&amp;m&#x3D;10’</li><li>hash: ‘#results’ anchor part of url</li></ol><h2 id="window-history"><a href="#window-history" class="headerlink" title="window.history"></a>window.history</h2><ol><li>history.forward(): 前进</li><li>history.back(): 后退</li><li>history.go(2), history.go(-2) : 前进2个页面,后退两个页面</li></ol><h2 id="window-navigator"><a href="#window-navigator" class="headerlink" title="window.navigator"></a>window.navigator</h2><ol><li>appName:</li><li>appVersion:</li><li>userAgent:</li><li>paltForm</li></ol><h2 id="window-document"><a href="#window-document" class="headerlink" title="window.document"></a>window.document</h2><ol><li>referrer: 一个错误的拼写, 主要用来指示用户是从什么链接跳转到该文档, 可以 用来防盗链, 和HTTP中referer类似</li><li>cookie: 设置cookie</li><li>title: text between <code>&lt;title&gt;</code> and <code>&lt;/title&gt;</code>.</li><li>domain:</li></ol><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>node: DOM树中的一个节点, 以下面这段html为例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Sample Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>An HTML Document<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>simple<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> document.<br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么DOM树是这样的: <img src="/static/img/DOM-tree.png"></p><h3 id="节点指针以及属性"><a href="#节点指针以及属性" class="headerlink" title="节点指针以及属性"></a>节点指针以及属性</h3><p>因为是树中的节点所以每个node对象都有以下的指针(以n代表一个node对象):</p><ol><li>n.parentNode: n的父节点对象</li><li>n.previousSibling: n的前一个兄弟节点对象</li><li>n.nextSibling: n的下一个兄弟节点对象</li><li>n.firstChild: n的第一个子节点对象</li><li>n.lastChild: n的最后一个子节点对象</li><li>n.childNodes: 返回一个类数组结构,包含所有的子节点.</li><li>n.firstElementChild: 第一个元素节点, 这在排除一些空格导致上的文本节点时 特别有用</li><li>n.lastElementChild:</li><li>n.childElementCount: 子节点中元素节点的个数</li></ol><p>除了节点指针外, 节点还有其它一些属性:</p><ol><li><strong>nodeType</strong>: The kind of node this is. Document nodes have the<br>value 9. Element nodes have the value 1. Text nodes have the value<ol start="3"><li>Comments nodes are 8 and Document- Fragment nodes are 11.</li></ol></li><li><strong>nodeValue</strong>: The textual content of a <strong>Text</strong> or <strong>Comment</strong><br>node.</li><li><strong>nodeName</strong>: The tag name of an Element, converted to uppercase.</li></ol><h3 id="node-type"><a href="#node-type" class="headerlink" title="node type"></a>node type</h3><p>有三种节点类型:</p><ul><li>Document Node: 最上方的那个节点, 用来代表整个文档, 这种节点一份文档只有 一个</li><li>Element Node: 用来代表html元素, 比如上图中的head节点就代表html中 <code>&lt;head&gt;...&lt;/head&gt;</code>.</li><li>Text Node: 代表文本,比如上例中 <code>Sample Document</code> 节点.</li></ul><h3 id="Element-node’s-attribute"><a href="#Element-node’s-attribute" class="headerlink" title="Element node’s attribute"></a>Element node’s attribute</h3><p>element node代表一个html元素, 他可以直接获得以及设置该html元素的属性,假设f 是一个form元素,<br>那么可以使用下面的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f.<span class="hljs-property">action</span> === <span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-comment">// test form&#x27;s action attribute</span><br>f.<span class="hljs-property">method</span> = <span class="hljs-string">&quot;POST&quot;</span>                   <span class="hljs-comment">// set the form&#x27;s method attribute to &quot;POST&quot;</span><br></code></pre></td></tr></table></figure><p>注意上面的方式返回值都是字符串, 所以要获得整数,可以使用parseInt, 而且只对 标准的html属性有效,<br>非标准的属性可以使用这两个函数来获取:</p><ol><li>getAttribute</li><li>setAttribute</li></ol><p>比如在html5中可以给一个元素设置以 <code>data-</code> 作为前缀的属性, 比如 <code>data-id</code>, 支持html5的浏览器会有一个<br><code>dataset</code> 属性, 如果n代表元素节点,那么 <code>n.dataset.id, n.dataset.time</code> 就会分别获得<br><code>data-id</code> 以及 <code>data-time</code> 的 值, 但是在不支持html5的浏览器上这就不是标准属性, 所以就需要<br><code>n.getAttribute(&#39;data-id&#39;), n.getAttribute(&#39;data-time&#39;)</code>.</p><h3 id="Element-node’s-content"><a href="#Element-node’s-content" class="headerlink" title="Element node’s content"></a>Element node’s content</h3><ol><li>innerHTML : 元素内的 html文本(不包含该元素本身的标签)</li><li>textContent&#x2F;innerText: 可以看作是innerHTML去掉所有的 HTML标签后得到的文 本.<br>IE没有定义textContent, firefox没有定义 innerText.</li><li>outerHTML: 和innerHTML相同,但是它会包含该元素本身的标签</li></ol><h2 id="选择DOM节点"><a href="#选择DOM节点" class="headerlink" title="选择DOM节点"></a>选择DOM节点</h2><ol><li>document.getElementById: 返回单个DOM节点</li><li>document.getElementsByName: 根据name属性查找, 返回NodeList, 这是一个类数 组对象, 只读.</li><li>document.getElementsByTagName</li><li>document.getElementsByClassName</li><li>document.querySelectorAll: 通过css selector来选择元素, 返回一个类数组结 构</li><li>document.querySelector: 和 querySelectorAll 类似,只是它值返回第一个匹配 的对象,<br>如果没有匹配的那么返回 null.</li></ol><h2 id="创建新DOM节点"><a href="#创建新DOM节点" class="headerlink" title="创建新DOM节点"></a>创建新DOM节点</h2><ol><li><p>document.createElement: 创建元素节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>document.createTextNode: 创建文本节点</p></li></ol><h2 id="插入DOM节点"><a href="#插入DOM节点" class="headerlink" title="插入DOM节点"></a>插入DOM节点</h2><p>可以使用 <code>insertBefore</code> 与 <code>appendChild</code> 这两个节点方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">parentOfBeforeNode.insertBefore(NodeToInsert, beforeNode);<br>parentElem.appendChild(nodeToInsert);<br></code></pre></td></tr></table></figure><p>有两个方便的函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> before = <span class="hljs-keyword">function</span>(<span class="hljs-params">parent, before, elem</span>)&#123;<br>  <span class="hljs-comment">// check if passed ``parent&#x27;&#x27;</span><br>  <span class="hljs-keyword">if</span> (! !!elem)&#123;<br>    elem = before;<br>    before = parent;<br>    parent = before.<span class="hljs-property">parentNode</span>;<br>  &#125;<br>  parent.<span class="hljs-title function_">insertBefore</span>(<span class="hljs-title function_">checkElem</span>(elem), before);<br>&#125;;<br><br><span class="hljs-keyword">var</span> append = <span class="hljs-keyword">function</span>(<span class="hljs-params">parent, elem</span>)&#123;<br>  parent.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">checkElem</span>(elem));<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除-替换DOM节点"><a href="#删除-替换DOM节点" class="headerlink" title="删除,替换DOM节点"></a>删除,替换DOM节点</h2><p>删除节点可以用 <code>removeChild</code> 函数.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">NodeParent.removeChild(NodeToRemove);<br></code></pre></td></tr></table></figure><p>所以你如果要删除一个DOM节点 <code>n</code>, 应该使用这样的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">n.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(n);<br></code></pre></td></tr></table></figure><p>替换一个节点使用 replaceChild 方法.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">n.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">replaceChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&quot;[ REDACTED ]&quot;</span>), n);<br></code></pre></td></tr></table></figure><h2 id="位置-scroll"><a href="#位置-scroll" class="headerlink" title="位置,scroll"></a>位置,scroll</h2><p>有两种坐标系统, 一种是 viewpoint coordinate, 一种是 document coordinate, 前<br>者只考虑可见的窗口部分,也就是说坐标系的原点在窗口的左上角,也就是所谓的 client<br>area的左上角, 通常这就是浏览器的窗口(不包括菜单栏, 工具栏,任务栏), 但是如果文档是显示在一个iframe中,<br>那么就是只包含iframe占用的部分, 后者还要 考虑滚动条,(坐标系的原点在文档的左上角).一般二者可以这样转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">documentX = viewpointX + scrollX<br>documentY = viewpointY + scrollY<br></code></pre></td></tr></table></figure><p>scrollX, scrollY 代表滚动条滚动的距离.</p><ol><li><p>获得viewpoint坐标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> box = e.<span class="hljs-title function_">getBoundingClientRect</span>()<br>box.<span class="hljs-property">top</span>;<br>box.<span class="hljs-property">right</span>;<br>box.<span class="hljs-property">bottom</span>;<br>box.<span class="hljs-property">left</span>;<br></code></pre></td></tr></table></figure><p>e是一个DOM节点元素, 返回的那几个属性都可以为负值或者大于屏幕, 这意味着该 元素目前不在视图之中.<br><strong>根据这四个值我们可以计算元素的精确大小</strong>.对隐藏元 素无效.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> box = e.<span class="hljs-title function_">getBoundingClientRect</span>();<br><span class="hljs-keyword">var</span> w = box.<span class="hljs-property">width</span> || (box.<span class="hljs-property">right</span> - box.<span class="hljs-property">left</span>); <span class="hljs-comment">// width</span><br><span class="hljs-keyword">var</span> h = box.<span class="hljs-property">height</span> || (box.<span class="hljs-property">bottom</span> - box.<span class="hljs-property">top</span>); <span class="hljs-comment">// height</span><br></code></pre></td></tr></table></figure></li><li><p>获得滚动条的offset</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getScrollOffsets</span>(<span class="hljs-params">w</span>) &#123;<br>  <span class="hljs-comment">// Use the specified window or the current window if no argument</span><br>  w = w || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// This works for all browsers except IE versions 8 and before</span><br>  <span class="hljs-keyword">if</span> (w.<span class="hljs-property">pageXOffset</span> != <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">scrollX</span>: w.<span class="hljs-property">pageXOffset</span>, <span class="hljs-attr">scrollY</span>: w.<span class="hljs-property">pageYOffset</span>&#125;;<br>  &#125;<br>  <span class="hljs-comment">// For IE (or any browser) in Standards mode</span><br>  <span class="hljs-keyword">var</span> d = w.<span class="hljs-property">document</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">compatMode</span> == <span class="hljs-string">&quot;CSS1Compat&quot;</span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">scrollX</span>: d.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollLeft</span>,<br>      <span class="hljs-attr">scrollY</span>: d.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span><br>    &#125;;<br>  &#125;<br>  <span class="hljs-comment">// For browsers in Quirks mode</span><br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">scrollX</span>: d.<span class="hljs-property">body</span>.<span class="hljs-property">scrollLeft</span>, <span class="hljs-attr">scrollY</span>: d.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scroll</p><ul><li>scrollTo(aka scroll): window对象的方法, 指定x,y坐标, 浏览器就会滚动到 对应位置</li><li>scrollIntoView: 一个Dom 节点的方法, 可以将这个元素滚动到视图中来.</li></ul></li></ol><h1 id="修改css"><a href="#修改css" class="headerlink" title="修改css"></a>修改css</h1><p>注意因为js中标识符中不能使用 - , 所以使用驼峰命名, 比如css的 <code>font-size</code> 在js 中就用, <code>fontSize</code>.</p><h2 id="使用style属性来修改css"><a href="#使用style属性来修改css" class="headerlink" title="使用style属性来修改css"></a>使用style属性来修改css</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">e.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&quot;absolute&quot;</span>;<br>e.<span class="hljs-property">style</span>.<span class="hljs-property">fontFamily</span> = <span class="hljs-string">&quot;sans-serif&quot;</span>;<br>e.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&quot;#ffffff&quot;</span>;<br></code></pre></td></tr></table></figure><p>代码中 e 是一个 Element Node. 注意上面的代码实际是创建行内样式, 因此设置 样式时很有效, 因为行内样式优先级最高,<br>但是获取样式就不能用这种方法, 因为 很可能该元素的样式在外部样式表中, 而不是行内样式中, 那么这种情况你使用这 样的代码<br><code>e.style.position</code> 会返回 “”,</p><h2 id="获取当前的样式"><a href="#获取当前的样式" class="headerlink" title="获取当前的样式"></a>获取当前的样式</h2><p>返回当前应用在该元素上的某项css值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> getStyle = <span class="hljs-keyword">function</span> (<span class="hljs-params">elem, name</span>)&#123;<br>  <span class="hljs-keyword">if</span>(elem.<span class="hljs-property">currentStyle</span>)&#123;   <span class="hljs-comment">// IE browser</span><br>    <span class="hljs-keyword">return</span> elem.<span class="hljs-property">currentStyle</span>[name];<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!! <span class="hljs-variable language_">window</span>.<span class="hljs-property">getComputedStyle</span>)&#123;<br>    <span class="hljs-comment">// W3C method(window.getComputedStyle)</span><br>    name = name.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/([A-Z])/g</span>, <span class="hljs-string">&quot;-$1&quot;</span>);<br>    name = name.<span class="hljs-title function_">toLowerCase</span>();<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(elem, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> s &amp;&amp; s.<span class="hljs-title function_">getPropertyValue</span>(name);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的函数可以这样使用 <code>getStyle(document.body, &#39;font-size&#39;)</code>, 但是它在获 取一些值比如 width<br>时, 可能返回 “%11”这样的值, 而不是计算后的值.</p><h2 id="className"><a href="#className" class="headerlink" title="className"></a>className</h2><p>通过className属性来修改HTML元素的 class属性, 之所以不用class这个词是因为它是 js的关键字.</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="Event-Object"><a href="#Event-Object" class="headerlink" title="Event Object"></a>Event Object</h2><p>通用属性:</p><ol><li>type: 一个字符串,比如 ‘load’, ‘click’, ‘mouseover’等等.</li><li>target&#x2F;srcElement: 触发事件的DOM元素, 后者是IE</li><li>stopPropagation()&#x2F;cancelBubble: 阻止冒泡, 后者是IE</li><li>preventDefault()&#x2F;returnValue&#x3D;false: 阻止默认行为, 后者是IE</li></ol><p>还有一些事件有一些特别的属性:</p><ol><li>鼠标事件有以下几个比较重要的属性:<ul><li>clientX, clientY: 鼠标在窗口中X, Y坐标, viewpoint coordinate.</li><li>pageX, pageY : 鼠标相对于文档的x, Y坐标, document coordinate(IE中无效).</li></ul></li><li>键盘事件有: ctrlKey, shiftKey, keyCode</li></ol><h2 id="常用事件类型"><a href="#常用事件类型" class="headerlink" title="常用事件类型"></a>常用事件类型</h2><h3 id="window的事件"><a href="#window的事件" class="headerlink" title="window的事件"></a>window的事件</h3><ol><li>load</li><li>scroll</li></ol><h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><ol><li>focus: element gains input focus</li><li>blur: element loses input focus</li></ol><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ol><li>click</li><li>dblclick</li><li>mouseover</li><li>mouseout</li><li>mousedown</li><li>mouseup</li><li>mousemove</li></ol><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul><li>keydown&#x2F;keypress: 二者是同义事件, 但是在阻止按键的默认行为时则只能用 keypress, 当你按组合快捷键时,<br>它会触发多个该类事件.</li><li>keyup</li></ul><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><ol><li>select: 选择了文本时触发</li><li>change: &lt;input type&#x3D;”text” &#x2F;&gt;, &lt;input type&#x3D;”password” &#x2F;&gt;,<br>&lt;select&gt;, <code>&lt;textarea&gt;</code> 等的内容改变且失去焦点时触发. 如果是文本框,当然还有keypress 事件.</li><li>submit: 这是form对象的事件, 它在表单被提交时触发.</li><li>reset</li></ol><h2 id="Register-Event-Handler"><a href="#Register-Event-Handler" class="headerlink" title="Register Event Handler"></a>Register Event Handler</h2><ol><li><p>onevent: 实际就是设置元素的html属性.基本代码模式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">window.onload = function(evt)&#123;...&#125;;<br></code></pre></td></tr></table></figure><p>这种方法有一些优缺点:</p><ul><li>优点: 事件处理函数中this被正确绑定到当前元素,同时这种方法兼容性很好</li><li>缺点: 一个元素对一类事件只能绑定一个事件处理函数, 重复绑定会覆盖以前的 绑定.<br>同时事件对象参数只在非IE浏览器有效(IE浏览器使用全局事件对象).</li></ul></li><li><p>addEventListener: 代码模式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">window.addEventListener(&#x27;load&#x27;, function()&#123;...&#125;, false);<br></code></pre></td></tr></table></figure><ul><li>优点: 可以绑定多个事件处理函数, this被正确绑定, event对象作为第一个参 数传递给事件处理函数</li><li>缺点: IE不支持</li></ul></li><li><p>IE(attachEvent) 在这种模式中, 如果要阻止浏览器的默认行为, 那么事件处理函数应该调用</p></li><li><p>这是一个比较好的版本, 你可以从这里<a href="static/doc/add-event.js">下载</a>.</p></li></ol><h2 id="Event-Cancellation"><a href="#Event-Cancellation" class="headerlink" title="Event Cancellation"></a>Event Cancellation</h2><h3 id="阻止浏览器默认行为"><a href="#阻止浏览器默认行为" class="headerlink" title="阻止浏览器默认行为"></a>阻止浏览器默认行为</h3><p>如果是onevent这种模式注册的事件处理函数, 要阻止浏览器的默认行为, 那么事件处 理函数应该返回false,<br>如果是addEventListener注册的事件处理函数, 要阻止浏览器 的默认行为, 那么事件处理函数应该调用<br><code>event.preventDefault()</code>. 如果是 IE(attachEvent)注册的事件处理函数, 那么事件处理函数应该调用<br><code>event.returnValue=false;</code>. 因此为了使这三中情况都能生效, 一般使用这样的代 码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventHandler = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>)&#123;<br>  evt = evt || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;    <span class="hljs-comment">// for IE</span><br><br>  <span class="hljs-keyword">if</span> (evt.<span class="hljs-property">preventDefault</span>)&#123;      <span class="hljs-comment">// standard technique</span><br>    evt.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (evt.<span class="hljs-property">returnValue</span>)&#123;         <span class="hljs-comment">// IE</span><br>    evt.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                 <span class="hljs-comment">// onevent</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>阻止事件冒泡, 如果event有stopPropagation, 那么调用该函数, 如果是IE, 设置 cancelBubble设为true.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventHandler = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>)&#123;<br>  <span class="hljs-keyword">if</span> (evt &amp;&amp; evt.<span class="hljs-property">stopPropagation</span>)&#123; <span class="hljs-comment">// non IE</span><br>    evt.<span class="hljs-title function_">stopPropagation</span>();<br>  &#125;<span class="hljs-keyword">else</span>&#123;                        <span class="hljs-comment">// IE</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><ol><li><p>获得事件处理函数中event对象(IE使用全局的event对象, 而非IE显式的传递event 对象作为参数给事件处理函数)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventhanlder = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>)&#123;<br>  evt = evt || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><h2 id="Create-XMLHttpRequest"><a href="#Create-XMLHttpRequest" class="headerlink" title="Create XMLHttpRequest"></a>Create XMLHttpRequest</h2><p>IE6没有标准的XMLHttpRequest构造函数, 可以使用以下代码模拟:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Emulate the XMLHttpRequest() constructor in IE5 and IE6</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span> === <span class="hljs-literal">undefined</span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// Use the latest version of the ActiveX object if available</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&quot;Msxml2.XMLHTTP.6.0&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (e1) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Otherwise fall back on an older version</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&quot;Msxml2.XMLHTTP.3.0&quot;</span>);<br>      &#125; <span class="hljs-keyword">catch</span>(e2) &#123;<br>        <span class="hljs-comment">// Otherwise, throw an error</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;XMLHttpRequest is not supported&quot;</span>);<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用 <code>var req = new XMLHttpRequest()</code> 来创建</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>指定verb(‘GET’, ‘POST’), url, async(true为异步, false为同步).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">req.open(verb, url [, async]);<br></code></pre></td></tr></table></figure><p>接着你可以使用 <code>setRequestHeader</code> 来指定http 头部, 这在使用 POST时特别重要,<br>因为你要指定你传递的数据类型(Content-Type).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">req.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>可以使用多个 <code>setRequestHeader</code> 语句.</p><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><p><code>req.send(msg);</code>, 如果是 GET,那么msg为null, 如果是 POST, msg为你要传递的内 容.</p><h2 id="Retrieving-the-Response"><a href="#Retrieving-the-Response" class="headerlink" title="Retrieving the Response"></a>Retrieving the Response</h2><p>如果请求完成,那么XMLHttpRequest会有以下属性:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>status</td><td>一个数值, 比如200, 404</td></tr><tr><td>statusText</td><td>一个字符串,比如”OK”, “Not Found”</td></tr><tr><td>getResponseHeader()</td><td>获得HTTP头部</td></tr><tr><td>getAllResponseHeader()</td><td></td></tr><tr><td>responseText</td><td>文本</td></tr><tr><td>responseXML</td><td>XML, 实际就是将文本解码成DOM树</td></tr></tbody></table><p>因为http请求一般都是异步发送, 所以必须要有一个事件来通知请求已经完成.这个事 件就是 <code>readystatechange</code>,<br>从理论上上说, 当 XMLHttpRequest 的 readyState属 性变动时都应该触发该事件,<br>但实际并不是如此, 下面是redayState的值:</p><table><thead><tr><th>Constant</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>UNSENT</td><td>0</td><td>open() has not been called yet</td></tr><tr><td>OPENED`</td><td>1</td><td>open() has been called</td></tr><tr><td>HEADERS_RECEIVED</td><td>2</td><td>Headers have been received</td></tr><tr><td>LOADING</td><td>3</td><td>The response body is being received</td></tr><tr><td>DONE</td><td>4</td><td>The response is complete</td></tr></tbody></table><p>XMLHttpRequest readyState values</p><p>一般来说从0到1是不会触发事件的, 但是调用send会触发事件,即便这时候 <code>readyState</code> 的值没有改变,都是1,<br>在实践中我们也只对特定的 readyState变动感 兴趣(主要是4, 也就是请求完成),<br>所以在事件处理函数中我们一般要测试 readyState的值比如下面这个函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getText</span>(<span class="hljs-params">url, callback</span>) &#123;<br>  <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>  <span class="hljs-comment">// Create new request</span><br>  request.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url);<br>  <span class="hljs-comment">// Specify URL to fetch</span><br>  request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// Define event listener</span><br>    <span class="hljs-comment">// If the request is compete and was successful</span><br>    <span class="hljs-keyword">if</span> (request.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; request.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-comment">// get type</span><br>      <span class="hljs-keyword">var</span> type = request.<span class="hljs-title function_">getResponseHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>);<br>      <span class="hljs-keyword">if</span> (type.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;xml&#x27;</span>) !== -<span class="hljs-number">1</span> &amp;&amp; request.<span class="hljs-property">responseXML</span>)&#123;<br>        <span class="hljs-title function_">callback</span>(request.<span class="hljs-property">responseXML</span>);<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&quot;application/json&quot;</span>)&#123;<br>        <span class="hljs-title function_">callback</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">responseText</span>)) <span class="hljs-comment">// JSON response</span><br>      &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-title function_">callback</span>(request.<span class="hljs-property">responseText</span>);  <span class="hljs-comment">// String response</span><br>      &#125;<br>    &#125;<br>  &#125;;<br>  request.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">// Send the request now</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>readyState</code> 为 <code>4</code> 只是说请求已经完成,但并不一定请求成功, 有可能是404 或其它http错误, 只有测试<br><code>status</code> 为 <code>200</code> 时才是成功的http请求.</p><h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>实际就是创建一个 <code>&lt;script&gt;...&lt;/script&gt;</code> 节点, 然后将其插入文档, 这样浏览器会 自动的发送一个http<br>get请求,并且把请求得到的内容当做 js代码来执行. 根据这个原<br>理,那么服务器必须生成能执行的js代码,而不仅仅只是返回数据,<br>也就是说一般要指定 一个处理函数作为前缀(prefix), 这也是jsonp中p的由来. 为了指定这个处理函数, 一 般在url中指定,<br>比如在url的后面添加 ?jsonp&#x3D;handler 或者 ?callback&#x3D;handler,这<br>样服务器端就知道你指定的处理函数了.</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js笔记</title>
    <link href="/notes/javascript/"/>
    <url>/notes/javascript/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript文档"><a href="#javascript文档" class="headerlink" title="javascript文档"></a>javascript文档</h1><p>几份不错的文档：<a href="http://bonsaiden.github.io/JavaScript-Garden/">JavaScript Garden</a> ,火狐开发者社区的js <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide?redirectlocale=en-US&redirectslug=JavaScript%252FGuide">tutorial</a></p><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="type的基本常识"><a href="#type的基本常识" class="headerlink" title="type的基本常识"></a>type的基本常识</h2><ol><li>数字, 字符串, boolean, null, undefined是js的基本类型，它们不是object, 其<br>它所有的值都是object, 数字, 字符串, bookean这三种类型有对应的包装对象 （wrapper<br>object），当你访问字符串的方法时，实际上会自动的创建一个临时的 字符串包装对象，就像调用了new<br>String(s),当调用完成后这个临时对象会被丢弃，<br>对于数字（Number），bool（Boolean）都是同样的原理</li><li>数字，字符串，bool都是不可变的，而object是可变的.</li><li>类型转换： 2 + ‘2a’ &#x3D; ‘22a’(操作符是+，则自动将数字转换为字符串，如果是其<br>它操作符则尝试将字符串转为整数，’22’转换为22,<br>但’2a’无法转换，这一点和 parseInt不同)</li></ol><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>不区分整数与浮点数</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">2.22</span>;<br></code></pre></td></tr></table></figure><p>有一些数学函数，用来处理数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">53</span>)         <span class="hljs-comment">//=&gt; 9007199254740992: 2 to the power 53</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">.6</span>)         <span class="hljs-comment">//=&gt; 1.0: round to the nearest integer</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">.6</span>)         <span class="hljs-comment">//=&gt; 1.0: round up to an integer</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">.6</span>)         <span class="hljs-comment">//=&gt; 0.0: round down to an integer</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(-<span class="hljs-number">5</span>)         <span class="hljs-comment">//=&gt; 5: absolute value</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(x,y,z)         <span class="hljs-comment">//Return the largest argument</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(x,y,z)         <span class="hljs-comment">//Return the smallest argument</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()         <span class="hljs-comment">//Pseudo-random number x where 0 &lt;= x &lt; 1.0</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>         <span class="hljs-comment">//π: circumference of a circle / diameter</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-property">E</span>         <span class="hljs-comment">//e: The base of the natural logarithm</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">3</span>)         <span class="hljs-comment">//The square root of 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>/<span class="hljs-number">3</span>)         <span class="hljs-comment">//The cube root of 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-number">0</span>)         <span class="hljs-comment">//Trigonometry: also Math.cos, Math.atan, etc.</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>)         <span class="hljs-comment">//Natural logarithm of 10</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">100</span>)/<span class="hljs-title class_">Math</span>.<span class="hljs-property">LN10</span>         <span class="hljs-comment">//Base 10 logarithm of 100</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">512</span>)/<span class="hljs-title class_">Math</span>.<span class="hljs-property">LN2</span>         <span class="hljs-comment">//Base 2 logarithm of 512</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>(<span class="hljs-number">3</span>)         <span class="hljs-comment">//Math.E cubed</span><br></code></pre></td></tr></table></figure><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> then = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2010</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// The 1st day of the 1st month of 2010</span><br><span class="hljs-keyword">var</span> later = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2010</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-comment">// Same day, at 5:10:30pm, local time</span><br>                     <span class="hljs-number">17</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();   <span class="hljs-comment">//The current date and time</span><br><span class="hljs-keyword">var</span> elapsed = now - then;  <span class="hljs-comment">//Date subtraction: interval in milliseconds</span><br><br>later.<span class="hljs-title function_">getFullYear</span>() <span class="hljs-comment">// =&gt; 2010</span><br>later.<span class="hljs-title function_">getMonth</span>() <span class="hljs-comment">// =&gt; 0: zero-based months</span><br>later.<span class="hljs-title function_">getDate</span>() <span class="hljs-comment">// =&gt; 1: one-based days</span><br>later.<span class="hljs-title function_">getDay</span>() <span class="hljs-comment">// =&gt; 5: day of week. 0 is Sunday 5 is Friday.</span><br>later.<span class="hljs-title function_">getHours</span>() <span class="hljs-comment">// =&gt; 17: 5pm, local time</span><br>later.<span class="hljs-title function_">getUTCHours</span>() <span class="hljs-comment">// =&gt; hours in UTC time; depends on timezone</span><br><br>later.<span class="hljs-title function_">toString</span>()   <span class="hljs-comment">// =&gt; &quot;Fri Jan 01 2010 17:10:30 GMT-0800 (PST)&quot;</span><br>later.<span class="hljs-title function_">toUTCString</span>()   <span class="hljs-comment">// =&gt; &quot;Sat, 02 Jan 2010 01:10:30 GMT&quot;</span><br>later.<span class="hljs-title function_">toLocaleDateString</span>()   <span class="hljs-comment">// =&gt; &quot;01/01/2010&quot;</span><br>later.<span class="hljs-title function_">toLocaleTimeString</span>()   <span class="hljs-comment">// =&gt; &quot;05:10:30 PM&quot;</span><br>later.<span class="hljs-title function_">toISOString</span>()   <span class="hljs-comment">// =&gt; &quot;2010-01-02T01:10:30.000Z&quot;; ES5 only</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串使用单引号或者双引号,建议使用单引号,因为这样可以更好的和html配合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;hello world&#x27;</span>; <span class="hljs-comment">// 字符串单双引号等价</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;hello world&quot;</span>;<br></code></pre></td></tr></table></figure><p>js的字符串实际上就是一串16位(2个字节)的值，因为js使用UTF-16来encoding unicode字符，所以如果一个uncode<br>point使用utf-16编码后有3个字节，那么使用length时该字符就是2个长度,js的字符串操作基本都是以16位的值为基础，<br>而不是以逻辑上的字符为基础的</p><h3 id="常见字符串处理函数"><a href="#常见字符串处理函数" class="headerlink" title="常见字符串处理函数"></a>常见字符串处理函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello, world&quot;</span>     <span class="hljs-comment">// =&gt; 3: position of first &quot;l&quot; at or after 3</span><br>s.<span class="hljs-property">length</span>             <span class="hljs-comment">// 12, the length of string(this is property, not method)</span><br><br>s.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>)    <span class="hljs-comment">// =&gt; &quot;h&quot;: the first character.</span><br>s.<span class="hljs-title function_">charAt</span>(s.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)    <span class="hljs-comment">// =&gt; &quot;d&quot;: the last character.</span><br>s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)    <span class="hljs-comment">// =&gt; &quot;ell&quot;: the 2nd, 3rd and 4th characters.</span><br>s.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)    <span class="hljs-comment">// =&gt; &quot;ell&quot;: same thing</span><br>s.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">3</span>)    <span class="hljs-comment">// =&gt; &quot;rld&quot;: last 3 characters</span><br>s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;l&quot;</span>)    <span class="hljs-comment">// =&gt; 2: position of first letter 1.</span><br>s.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;l&quot;</span>)    <span class="hljs-comment">// =&gt; 10: position of last letter 1.</span><br>s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-number">3</span>)    <span class="hljs-comment">// =&gt; 3: position of first &quot;l&quot; at or after 3</span><br><br>s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;, &quot;</span>)         <span class="hljs-comment">//  [&#x27;hello&#x27;, &#x27;world&#x27;]  an Array</span><br>s.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;H&quot;</span>)   <span class="hljs-comment">// Hello world, replace all instances</span><br>s.<span class="hljs-title function_">toUpperCase</span>()       <span class="hljs-comment">// HELLO WORLD</span><br></code></pre></td></tr></table></figure><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>只能为true或者false,以下的值会自动转换为false：</p><ol><li>false</li><li>null</li><li>undefined</li><li>“” (empty string)</li><li>NAN (not a number)</li><li>0, -0</li></ol><p>除以上的值之外的所有的值，包括所有的对象都会自动转换为true, 可以通过 !! 来明 确的将一个值转换为bool</p><h2 id="undefined与null"><a href="#undefined与null" class="headerlink" title="undefined与null"></a>undefined与null</h2><p>前者表示没有定义，后者表示变量的值为空，eg：var x;(x为undefined)</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="Create-RegExp-Object"><a href="#Create-RegExp-Object" class="headerlink" title="Create RegExp Object"></a>Create RegExp Object</h2><p>正则表示式是对象(RegExp对象), 有两种定义方法:</p><ol><li><code>var pattern = /../;</code>, <strong>无引号,不是字符串</strong>.</li><li><code>var pattern = new RegExp(...);</code></li></ol><p><strong>正则表达式要写成一行, 因为正则表达式中空格是非常重要的</strong>.</p><h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><p>正则表达式可以指定标志, 比如 <code>/../g</code>, <code>/../i</code>.</p><ol><li>g : 全局模式</li><li>i : 忽略大小写模式</li></ol><h2 id="group"><a href="#group" class="headerlink" title="group"></a>group</h2><p>正则表达式可以分组. 分组有以下几类:</p><ol><li>(..) : 这种分组是捕获型分组, 每一个捕获型分组都会有一个编号, 这种编号是从 1开始, 如果一个捕获型分组的编号是 <code>2</code>,<br>且最后的结果是 <code>result</code>, 那么该分 组匹配的文本就是 <code>result[2]</code>.</li><li>(?: ..): 以 <code>?:</code> 开头, 非捕获型分组, 这种分组不会干扰捕获型分组的编号, 它 匹配的文本也不会出现在最终的结果中.</li></ol><h2 id="RegExp-method"><a href="#RegExp-method" class="headerlink" title="RegExp method"></a>RegExp method</h2><p>这是regexp的方法</p><ol><li><code>.exec(str)</code>: 返回一个数组, 数组的第一个元素是匹配的完整字符串,接下来的元素 是所有的捕获型分组,<br>注意全局模式对exec不起作用, 它只返回第一个匹配.</li><li><code>.test(str)</code>: 如果str中包含能被匹配的字符串, 那么返回true, 否则返回false.</li></ol><h2 id="String-method"><a href="#String-method" class="headerlink" title="String method"></a>String method</h2><p>这是字符串的方法</p><ol><li><p><code>.search(regexp)</code>: 返回匹配字符串的第一个字符在原字符串中的index, 无匹配 那么返回 -1,<br>全局模式对search无用.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;JavaScript is fun&quot;</span>;<br>s.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/script/i</span>) <span class="hljs-comment">// Returns 4</span><br>s.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/a(.)a/</span>)   <span class="hljs-comment">// Returns 1</span><br></code></pre></td></tr></table></figure><p>如果 <code>search</code> 的第一个参数不是正则表达式及而是一个字符串, 那么先将它转换 为正则表达式(将字符串传递给 <code>new RegExp(..)</code>)</p></li><li><p><code>.replace(regexp, new_str)</code>: 返回替换后的新字符串, 如果regexp是全局模式,<br>那么会替换所有的匹配的字符串, 否则只替换第一处. 如果regexp中使用了分组,那<br>么可以在new_str中通过 $1, $2 … $n 来引用第一个, 第二个一直到第n个分组匹 配的字符串.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/javascript/i</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>);<br><span class="hljs-string">&quot;Doe, John&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\w+)\s*,\s*(\w+)/</span>, <span class="hljs-string">&quot;$2 $1&quot;</span>); <span class="hljs-comment">// =&gt; &quot;John Doe&quot;</span><br></code></pre></td></tr></table></figure><p>如果 <code>replace</code> 的第一个参数不是正则表达式及而是一个字符串, 那么直接使用字 符串字面值匹配</p></li><li><p><code>.match(regexp)</code>: 返回一个数组, 如果regexp是全局模式, 那么数组元素就是所 有匹配的字符串,<br>如果没有使用全局模式, 那么数组的第一个元素是匹配的字符串, 接下来的元素是所有的捕获型分组,<br>具体可以看下面的例子.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// regexp has &#x27;g&#x27; attribute</span><br><span class="hljs-string">&quot;1 plus 2 equals 3&quot;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d+/g</span>)  <span class="hljs-comment">// =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span><br><br><span class="hljs-comment">// regexp doesn&#x27;t have &#x27;g&#x27; attribute</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-regexp">/(\w+):\/\/([\w.]+)\/(\S*)/</span>;<br><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Visit my home page at http://www.isp.com/~david&quot;</span>;<br><span class="hljs-keyword">var</span> result = text.<span class="hljs-title function_">match</span>(url);<br><span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-keyword">var</span> fullurl = result[<span class="hljs-number">0</span>];   <span class="hljs-comment">// Contains &quot;http://www.isp.com/~david&quot;</span><br>  <span class="hljs-keyword">var</span> protocol = result[<span class="hljs-number">1</span>];   <span class="hljs-comment">// Contains &quot;http&quot;</span><br>  <span class="hljs-keyword">var</span> host = result[<span class="hljs-number">2</span>];   <span class="hljs-comment">// Contains &quot;www.isp.com&quot;</span><br>  <span class="hljs-keyword">var</span> path = result[<span class="hljs-number">3</span>];   <span class="hljs-comment">// Contains &quot;~david&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>match</code> 的参数不是正则表达式, 那么先转换为正则表达式.</p></li><li><p><code>.split(regexp)</code>:</p></li></ol><!-- end list --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;123,456,789&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);          <span class="hljs-comment">// =&gt; [&#x27;123&#x27;, &#x27;456&#x27;, &#x27;789&#x27;]</span><br><span class="hljs-string">&quot;1, 2, 3, 4, 5&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\s*,\s*/</span>); <span class="hljs-comment">// =&gt; [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</span><br></code></pre></td></tr></table></figure><p>不会将字符串字面值转换为正则表达式, 和 <code>replace</code> 类似.</p><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义数组可以使用两种方法: Array与[],但是推荐[],因为像 new Array(3)这样的代<br>码，它会返回一个空数组，可是却将这个数组的length设置为3,这是一个令人困惑的<br>特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 结果: [1, 2, 3]</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 结果: [1, 2, 3]</span><br><br>[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 结果: [3]</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 结果: []</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-comment">// 结果: [&#x27;3&#x27;]</span><br><br><span class="hljs-comment">// 译者注：因此下面的代码将会使人很迷惑</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 结果: [3, 4, 5]</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 结果: []，此数组长度为 3</span><br><br></code></pre></td></tr></table></figure><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>不要使用for…in, 而要使用如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, ...... <span class="hljs-number">100000000</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = list.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(list[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>原因是for … in会遍历整个原型链，效率不高</p><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><table><thead><tr><th>方法名</th><th>作用</th><th>返回值</th><th>例子</th></tr></thead><tbody><tr><td>concat</td><td>将数组连接起来</td><td>新数组</td><td>[1,2].concat([‘a’,’b’]); &#x3D;&gt;[1,2,’a’,’b’]</td></tr><tr><td>join</td><td>构造一个字符串</td><td>字符串</td><td>[‘a’,’b’,’c’].join(‘,’); &#x3D;&gt;‘a,b,c’</td></tr><tr><td>pop</td><td>移除最后一个元素(原地改变)</td><td>数组</td><td>[‘a’,’b’,’c’].pop(); &#x3D;&gt; ‘c’</td></tr><tr><td>push</td><td>将元素插入数组尾部(原地改变)</td><td>数组</td><td></td></tr><tr><td>reverse</td><td>反转元素顺序(原地改变)</td><td>数组</td><td>[1,2,3].reverse() &#x3D;&gt;[3,2,1]</td></tr><tr><td>sort</td><td>排序数组,默认比较字符串,可以传递比较函数(原地改变)</td><td>数组</td><td>[4,15,28].sort() &#x3D;&gt;[15,28,4]</td></tr><tr><td>slice</td><td>选取数组的一段</td><td>新数组</td><td>[‘a’,’b’,’c’].slice(0,1) &#x3D;&gt;[‘a’]</td></tr></tbody></table><h1 id="objects-对象"><a href="#objects-对象" class="headerlink" title="objects(对象)"></a>objects(对象)</h1><h2 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h2><p>object有点类似于关联数组, js中除了数字，字符串，bool，null，undefined之外都<br>是对象，数组，函数等等都是对象，对象有属性名，与属性值，数组的属性名是一些小<br>的连续的整数，这也是适合用数组的场景，其它的地方都应该用对象. object的定义如 下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Kitten&#x27;</span>,<br>  age : <span class="hljs-number">12</span><br>&#125;;<br><br>foo.<span class="hljs-property">name</span>; <span class="hljs-comment">// kitten</span><br>foo[<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-comment">// kitten</span><br><br><span class="hljs-keyword">var</span> get = <span class="hljs-string">&#x27;name&#x27;</span>;<br>foo[get]; <span class="hljs-comment">// kitten</span><br><br>foo<span class="hljs-number">.1234</span>; <span class="hljs-comment">// SyntaxError</span><br>foo[<span class="hljs-string">&#x27;1234&#x27;</span>]; <span class="hljs-comment">// works</span><br></code></pre></td></tr></table></figure><p>两种访问方法foo.name与foo[‘name’]， 推荐前者(前提是name必须是合法的js标识<br>符)，和python的dict不同，{}中的name不要加引号，因为这里严格的说是object的 属性，而不是key</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>对象对属性名的搜索有一定的规则, 一般情况下通过字面值构建的对象都会与<br>Object.prototype链接，也就是以Object.prototype为原型,所以如果一个属性在对象<br>中没有找到，那么她会自动到 Object.prototype中找，这样我们就可以给对象进行扩<br>充，比如给object.prototype中添加一个方法，那么每一个对象都可以调用, 同时也可<br>以给指定一个对象的原型,比如下面这个函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">beget</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-property">beget</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>)&#123;<br>    <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>Object.beget 会返回一个新对象, 这个对象会以调用者指定的 o 为原型.</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><ol><li>JSON.stringify: 将一个对象转换为字符串(serialize)</li><li>JSON.parse: 将一个字符串转换为对象.</li></ol><h1 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h1><p>基本和C语言类似，while，for，do…while，if…else if…else,switch…case, break,<br>continue都和C语言差不多，<br>break,continue和C语言有个区别就是后面可以跟一个label，break后面跟label那么它就不是终止最内层循环，而是终止<br>label指定的循环，eg：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> z = <span class="hljs-number">0</span><br><span class="hljs-attr">labelCancelLoops</span>: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Outer loops: &quot;</span> + x);<br>    x += <span class="hljs-number">1</span>;<br>    z = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Inner loops: &quot;</span> + z);<br>        z += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (z === <span class="hljs-number">10</span> &amp;&amp; x === <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">break</span> labelCancelLoops;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (z === <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>break<br>labelCancelLoops会终止最外层那个循环，continue后面跟label也和这类似，continue如果有label，那么它会终<br>止当前循环，而开始新一轮的label指定的循环</p><ul><li>for (key in obj) : 对于C语言类似的数组，它会获得index，而对于关联数组则会获得key,<br>所以取值需要obj[key]，但是这种循环不建议使用，因为它实际是遍历原型链，所以你无法<br>保证顺序，也会做很多无用功</li><li>for each (var item in obj): item会赋值为值，而不是key</li></ul><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><p>函数也是对象, 每一个函数对象都会链接到 Function.prototype对象上, 也就是以<br>Function.prototype对象为原型,而Function.prototype又会链接到<br>Object.prototype 上. 同时每一个函数对象有一个prototype属性, 每一个通过new创建的对象都会链接到 这个属性<br>但是这个属性和函数对象本身没关系.</p><h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> number * number;<br>&#125;<br><br><span class="hljs-keyword">var</span> square = <span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>)&#123;  <span class="hljs-comment">// recommend</span><br>  <span class="hljs-keyword">return</span> number * number;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四种调用方式"><a href="#四种调用方式" class="headerlink" title="四种调用方式"></a>四种调用方式</h2><h3 id="method调用模式"><a href="#method调用模式" class="headerlink" title="method调用模式"></a>method调用模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">inc</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> += <span class="hljs-keyword">typeof</span> inc === <span class="hljs-string">&#x27;number&#x27;</span> ? inc : <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br>myObject.<span class="hljs-title function_">increment</span>();           <span class="hljs-comment">// myObject.value is 1</span><br>myObject.<span class="hljs-title function_">increment</span>(<span class="hljs-number">2</span>);           <span class="hljs-comment">// myObject.value is 2</span><br></code></pre></td></tr></table></figure><p>这样调用时this会自动绑定到该对象, 在上例中就是 myObject.</p><h3 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h3><p>普通的函数调用: 比如 <code>var sum = add(3, 4);</code>, 在这种调用方式中, 在函数内部 (add)<br>this会被绑定到全局对象也就是 window对象</p><h3 id="构造器调用模式-不推荐"><a href="#构造器调用模式-不推荐" class="headerlink" title="构造器调用模式(不推荐)"></a>构造器调用模式(不推荐)</h3><p>实际是对OOP的一种不必要且蹩脚的模拟, 很晦涩难懂, 这种调用方式是使用 new 操 作符来调用. 这样调用时函数会有截然不同的行为.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Quo</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">string</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = string;<br>&#125;;<br><br><span class="hljs-title class_">Quo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get_status</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span>;<br>&#125;<br><span class="hljs-keyword">var</span> myQuo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quo</span>(<span class="hljs-string">&quot;confused&quot;</span>);<br>myQuo.<span class="hljs-title function_">get_status</span>()              <span class="hljs-comment">// the result is &quot;confused&quot;</span><br></code></pre></td></tr></table></figure><p>我解释下上面的代码: 首先 Quo 是一个函数对象(构造器), 当对这个对象使用 new 操作符时会创建一个新的对象也就是myQuo,<br>myQuo会以 Quo.prototype 为原型, 同时 在 Quo运行时, this会绑定到正在创建的那个对象也就是 myQuo.</p><p>一般来说构造器函数要以大写开头的名字命名, 同时在构造器内部不会明确的使用 return语句, 但是一旦明确的使用了return,<br>那么最后的结果就是return后的那个对 象了. 内置的Number, String, Regex,<br>Date等等实际都是构造器函数.</p><p>在一般的 OOP 语言中是区分类与对象, 所以上述代码实际就是在模拟类, 可是js完全 不需要类, 所有这种模拟是不必要的</p><h3 id="apply调用模式"><a href="#apply调用模式" class="headerlink" title="apply调用模式"></a>apply调用模式</h3><p>每一个函数都有一个apply方法, 该方法接受2个参数, 第一个参数是传递给 this的, 第二个参数是一个参数数组,<br>和lisp的apply有点类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">var</span> sum = add.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, arr); <span class="hljs-comment">// sum is 3</span><br></code></pre></td></tr></table></figure><p>在上例的这次add函数的apply调用中, 在add函数的内部 this 被绑定到 null.</p><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>js的函数是first class object，所以它可以作为参数传递，也可以作为返回值返回， 支持闭包与匿名函数，使用词法作用域,<br>它的很多地方借鉴了lisp的特性，下面是一些 示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// define a function if num==0</span><br> <span class="hljs-keyword">var</span> myFunc;<br> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)&#123;<br>   myFunc = <span class="hljs-keyword">function</span>(<span class="hljs-params">theObject</span>) &#123;<br>     theObject.<span class="hljs-property">make</span> = <span class="hljs-string">&quot;Toyota&quot;</span><br>   &#125;<br> &#125;<br><span class="hljs-comment">// closure</span><br><span class="hljs-comment">// The outer function defines a variable called &quot;name&quot;</span><br> <span class="hljs-keyword">var</span> pet = <span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) &#123;<br>   <span class="hljs-comment">// The inner function has access to the &quot;name&quot; variable of the outer function</span><br>   <span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">return</span> name;<br>   &#125;<br>   <span class="hljs-comment">// Return the inner function, thereby exposing it to outer scopes</span><br>   <span class="hljs-keyword">return</span> getName;<br> &#125;,<br>     myPet = <span class="hljs-title function_">pet</span>(<span class="hljs-string">&quot;Vivie&quot;</span>);<br><span class="hljs-title function_">myPet</span>();                            <span class="hljs-comment">// Returns &quot;Vivie&quot;</span><br></code></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol><li><code>var</code> 用来声明变量, 每一个变量都应该先声明, 后使用.</li><li>如果省略了 <code>var</code> 那么会创建一个全局变量, 不要省略var是一个好的做法, 而且 特别要注意打字错误,<br>jslint会提示没有用var声明的变量 <strong>特别注意</strong>.</li><li>js 没有块作用域, 也就是说不是每一对{} 都会创建一个新的作用域,这和C,java不 同.</li><li>其它规则和lisp类似</li></ol><!-- end list --><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">scope = <span class="hljs-string">&quot;global&quot;</span>;         <span class="hljs-comment">// Declare a global variable, even without var.</span><br><span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">&quot;global&quot;</span>;    <span class="hljs-comment">// Declare another global variable.</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope2</span>(<span class="hljs-params"></span>) &#123;<br>  scope = <span class="hljs-string">&quot;local&quot;</span>;          <span class="hljs-comment">// Oops! We just changed the global variable.</span><br>  <span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">&quot;local&quot;</span>;     <span class="hljs-comment">// Declare a local varible with the same name.</span><br><br>  myscope = <span class="hljs-string">&quot;local&quot;</span>;        <span class="hljs-comment">// This implicitly declares a new global variable.</span><br>  <span class="hljs-keyword">return</span> [scope, myscope];  <span class="hljs-comment">// Return two values.</span><br>&#125;<br><span class="hljs-title function_">checkscope2</span>()             <span class="hljs-comment">// =&gt; [&quot;local&quot;, &quot;local&quot;]: has side effects!</span><br>scope                     <span class="hljs-comment">// =&gt; &quot;local&quot;: global variable has changed.</span><br>myscope                   <span class="hljs-comment">// =&gt; &quot;local&quot;: global namespace cluttered up.</span><br></code></pre></td></tr></table></figure><p>js的作用域设计的比 python好, 因为变量需要声明, 所以就可以将创建绑定与修改变 量的值区分开, 也就不需要引入 <code>global</code><br>这样的关键字, 也就不需要对全局作用域特 殊对待.</p><h2 id="给类型增加方法"><a href="#给类型增加方法" class="headerlink" title="给类型增加方法"></a>给类型增加方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">method</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, func</span>)&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[name]) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[name] = func;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>给 String 增加 trim方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span>.<span class="hljs-title function_">method</span>(<span class="hljs-string">&#x27;trim&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s+|\s+$/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="内置的函数"><a href="#内置的函数" class="headerlink" title="内置的函数"></a>内置的函数</h2><ol><li>eval:运行js代码, 不推荐使用.</li><li>isFinite: test a number if it is a finite number</li><li>isNaN: is not a number</li><li>parseInt,parseFloat: 将字符串转换为整数或者浮点数</li></ol><h1 id="一些js技巧"><a href="#一些js技巧" class="headerlink" title="一些js技巧"></a>一些js技巧</h1><ol><li><p>在每个应用中仅创建一个全局的对象,然后将所有的函数都变成这个全局对象的属性, 减少与其它应用程序或者类库产生相互影响的可能性.</p></li><li><p>每个语句结束要插入分号,不要依赖js解释器的自动插入分号功能.</p></li><li><p>不要使用&#x3D;<code>, !</code> 而应该一直使用&#x3D;&#x3D;&#x3D;与!&#x3D;&#x3D; .</p></li><li><p>if, while这样的语句一定要使用 {}, 即便只有一条语句.</p></li><li><p>不要使用 <code>++</code> 与 <code>--</code> , 因为这让程序不易理解.</p></li><li><p>不要依赖 switch 中 case 的贯穿, 也就是说, 每一个case都要一个break.</p></li><li><p>尽量不要使用位操作(&amp;, !, ^),因为js没有整数类型, 它只有双精度浮点数</p></li><li><p>函数的声明应该用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;...&#125;;<br></code></pre></td></tr></table></figure><p>而不是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><p>因为第二种方式会使得不管函数定义在什么地方,它都会被移到被定义时的作用域的 最开头, 这违背了函数先定义后使用规则(scheme,<br>python都遵循该规则).</p></li><li><p>尽量不要使用 new Object, new Array, 应该使用 {} [] 来代替</p></li><li><p>不要使用new运算符.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scheme笔记</title>
    <link href="/notes/scheme/"/>
    <url>/notes/scheme/</url>
    
    <content type="html"><![CDATA[<h1 id="scheme笔记"><a href="#scheme笔记" class="headerlink" title="scheme笔记"></a>scheme笔记</h1><h2 id="几个概念-concept"><a href="#几个概念-concept" class="headerlink" title="几个概念 concept"></a>几个概念 <span class="tag" data-tag-name="concept"><span class="smallcaps">concept</span></span></h2><h3 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h3><p>标识符,可以看作是一个唯一的名字,可以用来引用变量,函数等等</p><h3 id="variable"><a href="#variable" class="headerlink" title="variable"></a>variable</h3><p>变量</p><h3 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h3><ul><li>a string of characters</li><li>a string of digits</li></ul><!-- end list --><figure class="highlight scheme"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> atom?<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (s)<br>    (<span class="hljs-name"><span class="hljs-built_in">and</span></span> (<span class="hljs-name"><span class="hljs-built_in">not</span></span> (<span class="hljs-name"><span class="hljs-built_in">pair?</span></span> s))<br>         (<span class="hljs-name"><span class="hljs-built_in">not</span></span> (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> s)))))<br></code></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>a collection of atoms enclosed by parentheses. example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs example">&#x27;()<br>&#x27;(a)<br>&#x27;(a b c)<br>&#x27;((a b) c d)<br></code></pre></td></tr></table></figure><p>语法描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">list -&gt; &#x27;()<br>      | (sexp . list)<br></code></pre></td></tr></table></figure><h3 id="S-expression"><a href="#S-expression" class="headerlink" title="S-expression"></a>S-expression</h3><ul><li>all lists</li><li>all atoms</li></ul><!-- end list --><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">sexp -&gt; list<br>      | atom<br></code></pre></td></tr></table></figure><h2 id="Naming-Conventions"><a href="#Naming-Conventions" class="headerlink" title="Naming Conventions"></a>Naming Conventions</h2><ol><li>谓词后加? , 但是常用的数字比较&#x3D;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;后面不需要?</li><li>类型测试, pair? , atom?</li><li>字符操作(char-xxx), 字符串操作(string-xxx), 向量操作(vector-xxx)</li><li>类型转换(type1-&gt;type2)</li><li>但函数有副作用时,应该以 ! 结尾, 比如 <code>set!</code></li></ol><h2 id="core-syntactic-forms-core-syntactic-form"><a href="#core-syntactic-forms-core-syntactic-form" class="headerlink" title="core syntactic forms core syntactic form"></a>core syntactic forms <span class="tag" data-tag-name="core"><span class="smallcaps">core</span></span> <span class="tag" data-tag-name="syntactic"><span class="smallcaps">syntactic</span></span> <span class="tag" data-tag-name="form"><span class="smallcaps">form</span></span></h2><ol><li><p>top-level <code>define</code> forms 实际就是创建新的绑定,可以绑定 <code>list</code>, <code>lambda procedure</code><br>这是几个示例代 码:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> double-any<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (f x)<br>    (<span class="hljs-name">f</span> x x)))<br><span class="hljs-comment">;;; identical</span><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">double-any</span> f x)<br>  (<span class="hljs-name">f</span> x x))<br><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> xyz &#x27;(x y z))<br></code></pre></td></tr></table></figure></li><li><p>constants BNF:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs example">&lt;constant&gt; -&gt; &lt;boolean&gt;<br>            | &lt;number&gt;<br>            | &lt;character&gt;<br>            | &lt;string&gt;<br></code></pre></td></tr></table></figure></li><li><p>variables</p></li><li><p>procedure applications <code>(procedure arg1 ... argn)</code> 求值规则:</p><ol><li>Find the value of <code>procedure</code>.</li><li>Find the value of <code>arg1</code>.</li><li>Find the value of <code>argn</code>.</li><li>Apply the value of <code>procedure</code> to the values of <code>arg1</code> … <code>argn</code>.</li></ol></li><li><p><code>quote</code> expressions (‘)</p><ol><li>quoting an <code>identifier</code> tells Scheme to treat the identifier as<br>a <code>symbol</code> rather than as a <code>variable</code>. 也就是说scheme解释器不会去当前的<br>环境中寻找与该标识符绑定的值, 而是直接将该标识符当作symbol也就是数据处理.</li><li>quoting a list tells scheme to treat the list as data, rather<br>than as a procedure application</li></ol></li><li><p><code>lambda</code> expressions <code>(lambda (x) (+ x x)) ==&gt; #&lt;procedure&gt;</code></p><p>一般形式有这三种:</p><ul><li><code>(lambda (var1 var2 ...) exp1 exp2 ...)</code>: var1 var2 …会依次赋值</li><li><code>(lambda (var1 var2 . var) exp1 exp2)</code>: var1 var2会依次赋值, 余下的参数<br>会组成一个列表赋给var</li><li><code>(lambda var exp1 exp2)</code>: 将所有的实参作为一个list赋给var, 注意var没有括号</li></ul></li><li><p><code>if</code> expressions: <code>(if test-expr then-expr else-expr)</code> 只有<br><code>test-expr</code> 为 <code>#f</code> 时才会运行 <code>else-expr</code>, 所以你一般要使用 <code>null?</code> <code>eq?</code> 这样的函数<br>来测试</p></li><li><p><code>set!</code> expressions(Assignment): Assignments do not create new<br>bindings, as with <code>let</code> or <code>lambda</code>, but rather change the values of<br>existing bindings.也就是说赋值不会像let, lambda那样产生新的绑定,而是会改变已存在绑<br>定的值,如果你给set!指定的符号不存在,它会报错(set!: cannot set undefined<br>variable)</p></li></ol><p>其它的都是一些扩展,也就是可以通过define-syntax定义出来的,比如let,and,or,not等<br>等,只有以上的部分才需要解释器直接实现的</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> let<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>    [(<span class="hljs-name">_</span> ((<span class="hljs-name">x</span> v) ...) e1 e2 ...)<br>     ((<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x ...) e1 e2 ...) v ...)]))<br><br>(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> and<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>    [(<span class="hljs-name">_</span>) <span class="hljs-literal">#t</span>]<br>    [(<span class="hljs-name">_</span> e) e]<br>    [(<span class="hljs-name">_</span> e1 e2 e3 ...)<br>     (<span class="hljs-name"><span class="hljs-built_in">if</span></span> e1 (<span class="hljs-name"><span class="hljs-built_in">and</span></span> e2 e3 ...) <span class="hljs-literal">#f</span>)]))<br></code></pre></td></tr></table></figure><p>实际上define-syntax实际就是进行模式匹配,像cond,如果匹配那么就进行替换,比 如(and 1)就匹配((_ e)<br>e)所以就被替换为1, <sub>就是and的占位符</sub>, 而 <code>pat ...</code> 代表 0个或者多个表达式, 比如<br><code>(x v) ...</code> 代表有0个或多个 <code>(x v)</code> 这样的表达式</p><h2 id="let-let"><a href="#let-let" class="headerlink" title="let let"></a>let <span class="tag" data-tag-name="let"><span class="smallcaps">let</span></span></h2><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-comment">;;; form 1</span><br>(<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">a</span> exp1)<br>      (<span class="hljs-name">b</span> exp2))<br>  (<span class="hljs-name">body1</span>)<br>  (<span class="hljs-name">body2</span>))<br><span class="hljs-comment">;;; form2</span><br>(<span class="hljs-name"><span class="hljs-built_in">let</span></span> f ([<span class="hljs-name">a</span> exp1]<br>        [<span class="hljs-name">b</span> exp2])<br>  (<span class="hljs-name">body1</span>)<br>  (<span class="hljs-name">body2</span>))<br></code></pre></td></tr></table></figure><p>由于 <code>scheme</code> 对待中括号与对待小括号是一样的,所以为了可读性, <code>let</code> 一般可以用如下代 码:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let</span></span> ([<span class="hljs-name">a</span> exp1]<br>      [<span class="hljs-name">b</span> exp2])<br>  (<span class="hljs-name">body1</span>)<br>  (<span class="hljs-name">body2</span>))<br></code></pre></td></tr></table></figure><p>form2主要是为了递归, 它使得在函数体中可以引用函数名, 比如下面的代码</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let</span></span> fac ([<span class="hljs-name">n</span> <span class="hljs-number">10</span>])<br>  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> n)<br>      <span class="hljs-number">1</span><br>      (<span class="hljs-name"><span class="hljs-built_in">*</span></span> n (<span class="hljs-name">fac</span> (<span class="hljs-name">sub1</span> n)))))<br></code></pre></td></tr></table></figure><ul><li><p>let: 如上所见,实际就是一个扩展语法,a,b只在body中可见, 所以你在exp2中不能使 用a</p></li><li><p>let*: exp2中可以引用a, 也就是a可以用来定义b, 可以用嵌套的 <code>let</code> 来定义 <code>let*</code></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> let*<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>    [(<span class="hljs-name">_</span> () e1 e2 ...)<br>     (<span class="hljs-name"><span class="hljs-built_in">let</span></span> () e1 e2 ...)]<br>    [(<span class="hljs-name">_</span> ((<span class="hljs-name">x1</span> v1) (<span class="hljs-name">x2</span> v2) ...) e1 e2 ...)<br>     (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">x1</span> v1))<br>       (<span class="hljs-name"><span class="hljs-built_in">let*</span></span> ((<span class="hljs-name">x2</span> v2) ...) e1 e2 ...))]))<br></code></pre></td></tr></table></figure></li><li><p>letrec: 主要用来解决定义递归函数时,函数名在函数体中不可见的问题,比如</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let</span></span> ([<span class="hljs-name">sum</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (lst)<br>                (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> lst) <span class="hljs-number">0</span><br>                    (<span class="hljs-name"><span class="hljs-built_in">+</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> lst) (<span class="hljs-name">sum</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> lst)))))])<br>  (<span class="hljs-name">sum</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)))<br></code></pre></td></tr></table></figure><p>如果运行上面的代码,那么你会 <code>sum undefined</code> 的错误, 原因是 <code>sum</code> 在后面的函数 体中不可见, 所以你使用<br><code>(sum (cdr lst))</code> 就会出错,当然你可以使用这种方法</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let</span></span> ([<span class="hljs-name">sum</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (sum lst)<br>                (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> lst) <span class="hljs-number">0</span><br>                    (<span class="hljs-name"><span class="hljs-built_in">+</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> lst) (<span class="hljs-name">sum</span> sum (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> lst)))))])<br>  (<span class="hljs-name">sum</span> sum &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)))<br></code></pre></td></tr></table></figure><p>但这种方法不够自然,而且比较丑陋,不符合scheme中定义递归函数的一般模式,所以 就引入了 <code>letrec</code>.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">letrec</span></span> ([<span class="hljs-name">sum</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (ls)<br>                (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> ls)<br>                    <span class="hljs-number">0</span><br>                    (<span class="hljs-name"><span class="hljs-built_in">+</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> ls) (<span class="hljs-name">sum</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> ls)))))])<br>  (<span class="hljs-name">sum</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>)))<br><span class="hljs-comment">;; the result is 15</span><br></code></pre></td></tr></table></figure></li><li><p>letrec*: 和 <code>letrec</code> 类似, 只是后面的绑定可以引用前面已经绑定的变量</p></li><li><p>let-values: 绑定多个变量 syntax:</p><ul><li>(let-values ((formals expr) …) body1 body2 …)</li><li>(let*-values ((formals expr) …) body1 body2 …)</li></ul><!-- end list --><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let-values</span></span> ([(<span class="hljs-name">a</span> b) (<span class="hljs-name"><span class="hljs-built_in">values</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)] [<span class="hljs-name">c</span> (<span class="hljs-name"><span class="hljs-built_in">values</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)])<br>  (<span class="hljs-name"><span class="hljs-built_in">list</span></span> a b c)) <span class="hljs-comment">; the result is (1 2 (1 2 3))</span><br><br>(<span class="hljs-name"><span class="hljs-built_in">let*-values</span></span> ([(<span class="hljs-name">a</span> b) (<span class="hljs-name"><span class="hljs-built_in">values</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)] [(<span class="hljs-name">a</span> b) (<span class="hljs-name"><span class="hljs-built_in">values</span></span> b a)])<br>  (<span class="hljs-name"><span class="hljs-built_in">list</span></span> a b)) <span class="hljs-comment">; the result is (2 1)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h2><h3 id="if-if"><a href="#if-if" class="headerlink" title="if if"></a>if <span class="tag" data-tag-name="if"><span class="smallcaps">if</span></span></h3><p>当要写多个表达式时应该加入 <code>begin</code> , 注意 <code>begin</code> 会依次执行它所包含的表达式,并 返回最后一个表达式的值</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name">test-exp</span>)<br>    (<span class="hljs-name"><span class="hljs-built_in">begin</span></span><br>      expression1<br>      expression2)<br>    expression3)<br></code></pre></td></tr></table></figure><p>如果 <code>test-exp</code> 为true, 依次执行 <code>expression1</code>, <code>expression2</code> 那么返回<br><code>expression2</code> 的值, 之所以需要 <code>begin</code> 是由 <code>if</code> 的语法决定的, <code>if</code> 的语 法如下:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name">test-exp</span>)<br>    (<span class="hljs-name">true-exp</span>)<br>    (<span class="hljs-name">false-exp</span>))<br></code></pre></td></tr></table></figure><p>所以如果你在 <code>true-exp</code> 的位置放入多条表达式,那么这些表达式的第二条会 被当作 <code>false-exp</code> ,而且因为 <code>if</code><br>后的表达式的条数超出 <code>2</code> 条而报错, 所以 你需要把多条表达式括起来,但是你不能直接加一个括号,比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">((true-exp1)(true-exp2))<br></code></pre></td></tr></table></figure><p>这样之所以不行是因为scheme会将 (true-exp1) 当作procedure求值,这显然不 对,<br>所以scheme使用begin(更准确的说begin是为了引入side effect), 也就变成 了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">(begin<br>  (true-exp1)<br>  (true-exp2))<br></code></pre></td></tr></table></figure><p>这就是if使用begin的原因了, 注意在 let, lambda, define,cond的body中都不需<br>要begin,因为它们都没有if这种特殊的状况.</p><h3 id="cond-cond"><a href="#cond-cond" class="headerlink" title="cond cond"></a>cond <span class="tag" data-tag-name="cond"><span class="smallcaps">cond</span></span></h3><p>内部相当于有个隐含的begin,所以可以直接写多个表达式</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">cond</span></span> [(<span class="hljs-name">test-exp</span>) (<span class="hljs-name">exp1</span>) (<span class="hljs-name">exp2</span>)]<br>      [<span class="hljs-name"><span class="hljs-built_in">else</span></span> expression3])<br></code></pre></td></tr></table></figure><p>如果test-exp为true, 那么返回expression2的值 注意一个特殊的形式: &#x3D;&gt;</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">cond</span></span> ((<span class="hljs-name"><span class="hljs-built_in">assv</span></span> <span class="hljs-symbol">&#x27;b</span> &#x27;((a <span class="hljs-number">1</span>) (b <span class="hljs-number">2</span>))) =&gt; cadr)<br>      (<span class="hljs-name"><span class="hljs-built_in">else</span></span> <span class="hljs-literal">#f</span>))                       <span class="hljs-comment">;; ==&gt;  2</span><br></code></pre></td></tr></table></figure><p>会将 test-exp的值传递给 &#x3D;&gt;后面的函数, &#x3D;&gt;后面必须是一个带一个参数的函数</p><h3 id="when-unless-when-unless"><a href="#when-unless-when-unless" class="headerlink" title="when unless when unless"></a>when unless <span class="tag" data-tag-name="when"><span class="smallcaps">when</span></span> <span class="tag" data-tag-name="unless"><span class="smallcaps">unless</span></span></h3><ul><li><p>(when (test-exp) exp1 exp2) : test-exp为真就执行exp1, exp2</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> when<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>    [(<span class="hljs-name">_</span> e0 e1 e2 ...) (<span class="hljs-name"><span class="hljs-built_in">if</span></span> e0 (<span class="hljs-name"><span class="hljs-built_in">begin</span></span> e1 e2 ...))]))<br></code></pre></td></tr></table></figure></li><li><p>(unless (test-exp) exp1 exp2) : 只有当 <code>test-exp</code> 为#f时才会运行body中的 表达式</p></li></ul><h3 id="case-case"><a href="#case-case" class="headerlink" title="case case"></a>case <span class="tag" data-tag-name="case"><span class="smallcaps">case</span></span></h3><p>类似于C语言的switch</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">x</span> <span class="hljs-number">4</span>) (<span class="hljs-name">y</span> <span class="hljs-number">5</span>))<br>  (<span class="hljs-name"><span class="hljs-built_in">case</span></span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x y)<br>    ((<span class="hljs-name">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>) <span class="hljs-symbol">&#x27;odd</span>)<br>    ((<span class="hljs-name">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span>) <span class="hljs-symbol">&#x27;even</span>)<br>    (<span class="hljs-name"><span class="hljs-built_in">else</span></span> <span class="hljs-symbol">&#x27;out-of-range</span>))) <span class="hljs-comment">;; ===&gt; odd</span><br></code></pre></td></tr></table></figure><h3 id="do-do"><a href="#do-do" class="headerlink" title="do do"></a>do <span class="tag" data-tag-name="do"><span class="smallcaps">do</span></span></h3><p><code>syntax: (do ((var init update) ...) (test result ...) expr ...)</code></p><p>循环(do ((var init update) …) (test res …) exp …) var的初始值是init,接<br>着每一次迭代都绑定到update, (test res..)如果为true,那么就终止循环</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> divisors<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (n)<br>    (<span class="hljs-name"><span class="hljs-built_in">do</span></span> ((<span class="hljs-name">i</span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> i <span class="hljs-number">1</span>))<br>         (<span class="hljs-name">ls</span> &#x27;()<br>             (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">integer?</span></span> (<span class="hljs-name"><span class="hljs-built_in">/</span></span> n i))<br>                 (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> i ls)<br>                 ls)))<br>        ((<span class="hljs-name"><span class="hljs-built_in">&gt;=</span></span> i n) ls))))<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>(map procedure list1 list2 …) 会返回一个 <code>list</code></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">map</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x y) (<span class="hljs-name"><span class="hljs-built_in">*</span></span> x y))<br>     &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)<br>     &#x27;(<span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span>))      <span class="hljs-comment">; return (8 14 18 20)</span><br></code></pre></td></tr></table></figure><p><code>map</code> 与 <code>for-each</code> 可以代替许多循环的工作, 而且逻辑上比循环更清晰.</p><h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p>和 <code>map</code> 类似但是不返回一个list作为结果, 也就是说 <code>for-each</code> 是用来产生side effect.</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>(apply procedure obj … list)</p><ul><li><code>(apply + &#39;(4 5)) ===&gt; 9</code></li><li><code>(apply min 5 1 3 &#39;(6 8 3 2 5))</code> 结果是1</li></ul><h3 id="multiple-values"><a href="#multiple-values" class="headerlink" title="multiple values"></a>multiple values</h3><ul><li><p>(values obj …) :返回多个值,注意它的返回值可以用 <code>let-values</code> 来绑定,不能用 <code>define</code></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let-values</span></span> ([(<span class="hljs-name">a</span> b) (<span class="hljs-name"><span class="hljs-built_in">values</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)])<br>  (<span class="hljs-name"><span class="hljs-built_in">+</span></span> a b))<br></code></pre></td></tr></table></figure></li><li><p>(call-with-values producer consumer): producer产生多个值, 然后将这些值传<br>递给consumer.注意producer必须可以不带参数的方式来调用</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">call-with-values</span></span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> () (<span class="hljs-name"><span class="hljs-built_in">values</span></span> <span class="hljs-symbol">&#x27;bond</span> <span class="hljs-symbol">&#x27;james</span>))<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x y) (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> y x)))  <span class="hljs-comment">; the result is (james . bond)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="内置的函数"><a href="#内置的函数" class="headerlink" title="内置的函数"></a>内置的函数</h2><h3 id="predication"><a href="#predication" class="headerlink" title="predication"></a>predication</h3><ol><li>= : 只用来比较整数, 不要用来比较浮点数</li><li>eq? : 可以类似的看作是指针比较, 即便是内容相同,但是如果是两个不同对象,它 就返回 <code>#f</code>, 比如 <code>(eq? (cons &#39;a &#39;b) (cons &#39;a &#39;b))</code> 虽然是同样的list, 可 是它在内存中的位置不同,所以为 #f.<br>有以下几种情况是相等的.<ul><li><p>#t, #f, 两个identifier的值如果都是#t或者#f,那么它们相等</p></li><li><p>相同的符号(symbol), 比如</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> sym1 <span class="hljs-symbol">&#x27;hello</span>)<br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> sym2 <span class="hljs-symbol">&#x27;hello</span>)<br>(<span class="hljs-name"><span class="hljs-built_in">eq?</span></span> sym1 sym2)<br></code></pre></td></tr></table></figure></li><li><p>‘()</p></li></ul></li><li>eqv? : 和 <code>eq?</code> 很类似, 只是它在一些 <code>eq?</code> 没有定义的地方也可以使用</li><li>equal? : 只要内容相同,它就会返回 #t,可以认为它的检查比 <code>eq?</code> 宽松</li><li>boolean? : 等价于 <code>(lambda (x) (or (eq? x #t) (eq? x #f)))</code></li><li>null? : 只作用于list, only <code>(null? &#39;())</code> return <code>#t</code>.</li><li>pair? :</li><li>number? :</li><li>complex? :</li><li>rational? :</li><li>real? :</li><li>integer? :</li><li>char? :</li><li>string? :</li><li>vector? :</li><li>symbol? :</li><li>procedure? :</li><li>bytevector? :</li><li>hashtable? :</li></ol><h3 id="list-procedure"><a href="#list-procedure" class="headerlink" title="list procedure"></a>list procedure</h3><p><code>list</code> 的语法定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">List ::= &#x27;()<br>     ::= (Sexp . List)<br></code></pre></td></tr></table></figure><ol><li><p>cons: (cons ‘a ‘b) &#x3D;&#x3D;&gt; (a . b),只能带两个参数</p></li><li><p>cons* : (cons* ‘a ‘b ‘c) &#x3D;&#x3D;&gt; (a b . c) (cons* ‘a ‘b ‘(c)) &#x3D;&#x3D;&gt;<br>(a b c)</p></li><li><p>car: the firsts element of pair (<strong>only for non-empty list</strong> )</p></li><li><p>cdr: Only for non-empty list, the cdr of any non-empty list is also<br>a list.</p></li><li><p>set-car! :有副作用, 会原地改变pair的值</p></li><li><p>set-cdr! :</p></li><li><p>car, caar, caaar…etc: 连续执行n次(a的次数)car (caar ‘((5)) ) &#x3D;&#x3D;&#x3D;&gt; 5</p></li><li><p>cdr cddr cdddr …etc : 连续执行n次(d的个数)cdr</p></li><li><p>cadar : (car (cdr (car lst))) 记住按照顺序从左到右,最右边的先对list起作用</p></li><li><p>list: 创建一个list eg: (list 1 2 3 4) &#x3D;&#x3D;&#x3D;&gt; ‘(1 2 3 4)</p></li><li><p>length: list的长度</p></li><li><p>append: 将一个list添加另一个list的后边,eg: (append ‘(1 2) ‘(3 4)) &#x3D;&#x3D;&#x3D;&gt; ‘(1 2 3</p><ol start="4"><li></li></ol></li><li><p>reverse: 将list倒转</p></li><li><p>(list-ref list n): 第n个元素</p></li><li><p>(list-tail list n) : 倒数第n个元素</p></li><li><p>memq memv member memp 分别用eq? eqv? equal? 指定的procedure 来测试一个元<br>素是否属于list, 如果属于那么就返回包括该元素以及该元素后面的元素组成的 list, <code>(memq &#39;a &#39;(b c a d e)) --&gt; (a d e)</code></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> memq<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x ls)<br>    (<span class="hljs-name"><span class="hljs-built_in">cond</span></span><br>      ((<span class="hljs-name"><span class="hljs-built_in">null?</span></span> ls) <span class="hljs-literal">#f</span>)<br>      ((<span class="hljs-name"><span class="hljs-built_in">eq?</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> ls) x) ls)<br>      (<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name"><span class="hljs-built_in">memq</span></span> x (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> ls))))))<br></code></pre></td></tr></table></figure></li><li><p>remq (obj list) remv remove remp 删除list中的所有obj</p></li><li><p>assq assv assoc assp 可以看做是关联数组((key1 . val1) (key2 . val2) …)</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> assq<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x ls)<br>    (<span class="hljs-name"><span class="hljs-built_in">cond</span></span><br>      ((<span class="hljs-name"><span class="hljs-built_in">null?</span></span> ls) <span class="hljs-literal">#f</span>)<br>      ((<span class="hljs-name"><span class="hljs-built_in">eq?</span></span> (<span class="hljs-name"><span class="hljs-built_in">caar</span></span> ls) x) (<span class="hljs-name"><span class="hljs-built_in">car</span></span> ls))<br>      (<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name"><span class="hljs-built_in">assq</span></span> x (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> ls))))))<br></code></pre></td></tr></table></figure><p>返回第一个匹配的pair</p></li><li><p>(filter procedure list): return a list of the elements of list for<br>which procedure returns true</p></li><li><p>(partition procedure list): 返回两个list,第一个list包含所以使 <code>procedure</code><br>为#f的元素,第二个包含所有使 <code>procedure</code> 为 <code>#f</code> 的元素, <code>partition</code><br>的返回值可以使用 <code>let-values</code> 来绑定或者使用 <code>call-with-values</code><br>来调用其它函数</p></li><li><p>(find procedure list) : 返回第一个使procedure为#t的元素</p></li><li><p>(map f list1 list2 …)</p></li><li><p>(foldl f init list1 list2 …): <strong>racket 的内置版本有bug</strong></p></li><li><p>(foldr f init list1 list2 …):</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> foldl<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (f x ls)<br>    (<span class="hljs-name"><span class="hljs-built_in">cond</span></span><br>     [(<span class="hljs-name"><span class="hljs-built_in">null?</span></span> ls) x]<br>     [<span class="hljs-name"><span class="hljs-built_in">else</span></span><br>      (<span class="hljs-name">foldl</span> f (<span class="hljs-name">f</span> x (<span class="hljs-name"><span class="hljs-built_in">car</span></span> ls)) (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> ls))])))<br><span class="hljs-comment">;; (foldl op init &#x27;(1 2 3 4))</span><br><span class="hljs-comment">;; we can think foldl&#x27;s behavior like this: (init op 1 op 2 op 3 op 4)</span><br><span class="hljs-comment">;; op has left associativity</span><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> foldr<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (f x ls)<br>    (<span class="hljs-name"><span class="hljs-built_in">cond</span></span><br>     [(<span class="hljs-name"><span class="hljs-built_in">null?</span></span> ls) x]<br>     [<span class="hljs-name"><span class="hljs-built_in">else</span></span><br>      (<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> ls) (<span class="hljs-name">foldr</span> f x (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> ls)))])))<br><span class="hljs-comment">;; (foldr op init &#x27;(1 2 3 4 5))</span><br><span class="hljs-comment">;; we can think foldl&#x27;s behavior like this: (1 op 2 op 3 op 4 op init)</span><br><span class="hljs-comment">;; op has right associativity</span><br><br></code></pre></td></tr></table></figure></li></ol><h3 id="number-procedure"><a href="#number-procedure" class="headerlink" title="number procedure"></a>number procedure</h3><ol><li>zero? :</li><li>positive? :</li><li>negative? :</li><li>even? :</li><li>odd? : 奇数</li><li>数学函数: max, min, floor, ceiling(向+无穷取整),<br>truncate(向0取整),round(最接近的整数),<br>abs,gcd,expt(指数),三角系列函数(san,cos….)</li></ol><h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>字符使用 <code>#\x</code> 来表示,比如 <code>a</code> 就是 <code>#\a</code>,</p><ul><li><p>(char&#x3D;? char1 char2 char3 …)</p></li><li><p>(char&lt;? char1 char2 char3 …)</p></li><li><p>(char&gt;? char1 char2 char3 …)</p></li><li><p>(char&lt;&#x3D;? char1 char2 char3 …)</p></li><li><p>(char&gt;&#x3D;? char1 char2 char3 …)</p></li><li><p>(char-ci&#x3D;? char1 char2 char3 …) 大小写敏感</p></li><li><p>(char-ci&lt;? char1 char2 char3 …)</p></li><li><p>(char-ci&gt;? char1 char2 char3 …)</p></li><li><p>(char-ci&lt;&#x3D;? char1 char2 char3 …)</p></li><li><p>(char-ci&gt;&#x3D;? char1 char2 char3 …)</p></li><li><p>(char-upcase char) :大写,相对应的还有个char-downcase</p></li><li><p>(char-&gt;integer char)</p></li><li><p>(integer-&gt;char n)</p></li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>双引号内的是字符串</p><ul><li>(string&#x3D;? char1 char2 char3 …)</li><li>(string&lt;? char1 char2 char3 …)</li><li>(string&gt;? char1 char2 char3 …)</li><li>(string&lt;&#x3D;? char1 char2 char3 …)</li><li>(string&gt;&#x3D;? char1 char2 char3 …)</li><li>(string-ci&#x3D;? char1 char2 char3 …) 大小写敏感</li><li>(string-ci&lt;? char1 char2 char3 …)</li><li>(string-ci&gt;? char1 char2 char3 …)</li><li>(string-ci&lt;&#x3D;? char1 char2 char3 …)</li><li>(string-ci&gt;&#x3D;? char1 char2 char3 …)</li><li>(string char …): 构建个包含指定的字符的字符串</li><li>(make-string n), (make-string n char)</li><li>(string-append string …)</li><li>(substring string start end)</li><li>(string-upcase string)</li><li>(string-&gt;list): 把string转换成包含char的list</li><li>(char-&gt;list lst)</li></ul><h3 id="vector-procedure"><a href="#vector-procedure" class="headerlink" title="vector procedure"></a>vector procedure</h3><p>list访问时需要遍历,不够高效, vector可以像数组一样O(1)时间内访问</p><ol><li>(vector obj …)</li><li>make-vector: (make-vector 5 ‘a) &#x3D;&#x3D;&#x3D;&gt; #(a a a a a)</li><li>vector-length: vector的长度</li><li>(vector-ref vec n)</li><li>(vector-set! vec n obj)</li><li>(vector-fill vec obj): 所有的元素都替换为obj</li><li>list-&gt;vector :</li><li>vector-&gt;list :</li></ol><h3 id="symbol-procedure"><a href="#symbol-procedure" class="headerlink" title="symbol procedure"></a>symbol procedure</h3><p>每一个symbol在解释器内部都是指向同一个对象,所以用eq?来测试相同的symbol会返 回#t, 这也使得比较操作很高效</p><ol><li>symbol&#x3D;? :symbol是否相等,也可以用eq?来比较</li><li>symbol-&gt;string:</li><li>string-&gt;symbol:</li></ol><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3><ul><li><p>(make-eq-hashtable) : 使用eq?来比较两个key, 返回一个hashtable</p></li><li><p>(make-eq-hashtable size)</p></li><li><p>(make-eqv-hashtable) : 使用eqv?来比较两个key</p></li><li><p>(make-eqv-hashtable size)</p></li><li><p>(make-hashtable hash equiv?) : hash指定hash函数, equiv?指定比较两个key的 函数</p></li><li><p>(make-hashtable hash equiv? size)</p></li><li><p>(hashtable-set! hashtable key obj) :</p></li><li><p>(hashtable-ref hashtable key default) :</p></li><li><p>(hashtable-delete! hashtable key) :</p></li><li><p>(hashtable-size hashtable) : hashtable的大小</p></li><li><p>(hashtable-contains? hashtable key) :测试是否包含指定的key</p></li></ul><h2 id="macros"><a href="#macros" class="headerlink" title="macros"></a>macros</h2><p>定义一个宏实际上就是把一个keyword与一个 macro transformer 绑定, 一个macro<br>transformer一般就是一个带有一个参数的函数, 而macro transformer的输入是一个原<br>始代码的syntax object, 输出则是包含转换后代码的 syntax object. <code>syntax-rules</code><br>返回的就是一个macro transform.所以你可以抛开 <code>syntax-rules</code> 而这样写一个宏:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> self-as-string<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (stx)<br>    (<span class="hljs-name">datum-&gt;syntax</span> stx<br>                   (<span class="hljs-name">format</span> <span class="hljs-string">&quot;~s&quot;</span> (<span class="hljs-name">syntax-&gt;datum</span> stx)))))<br></code></pre></td></tr></table></figure><h3 id="define-syntax"><a href="#define-syntax" class="headerlink" title="define-syntax"></a>define-syntax</h3><p>和define类似</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> let*<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>    [(<span class="hljs-name">_</span> () b1 b2 ...) (<span class="hljs-name"><span class="hljs-built_in">let</span></span> () b1 b2 ...)]<br>    [(<span class="hljs-name">_</span> ((<span class="hljs-name">i1</span> e1) (<span class="hljs-name">i2</span> e2) ...) b1 b2 ...)<br>     (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ([<span class="hljs-name">i1</span> e1])<br>       (<span class="hljs-name"><span class="hljs-built_in">let*</span></span> ([<span class="hljs-name">i2</span> e2] ...) b1 b2 ...))]))<br></code></pre></td></tr></table></figure><h3 id="let-syntax与letrec-syntax"><a href="#let-syntax与letrec-syntax" class="headerlink" title="let-syntax与letrec-syntax"></a>let-syntax与letrec-syntax</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let</span></span> ([<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x <span class="hljs-number">1</span>))])<br>  (<span class="hljs-name"><span class="hljs-built_in">let-syntax</span></span> ([<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>                    [(<span class="hljs-name">_</span> x) x])]<br>               [<span class="hljs-name">g</span> (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>                    [(<span class="hljs-name">_</span> x) (<span class="hljs-name">f</span> x)])])<br>    (<span class="hljs-name"><span class="hljs-built_in">list</span></span> (<span class="hljs-name">f</span> <span class="hljs-number">1</span>) (<span class="hljs-name">g</span> <span class="hljs-number">1</span>)))) <span class="hljs-comment">;; (1 2)</span><br><br>(<span class="hljs-name"><span class="hljs-built_in">let</span></span> ([<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x) (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x <span class="hljs-number">1</span>))])<br>  (<span class="hljs-name"><span class="hljs-built_in">letrec-syntax</span></span> ([<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>                       [(<span class="hljs-name">_</span> x) x])]<br>                  [<span class="hljs-name">g</span> (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> ()<br>                       [(<span class="hljs-name">_</span> x) (<span class="hljs-name">f</span> x)])])<br>    (<span class="hljs-name"><span class="hljs-built_in">list</span></span> (<span class="hljs-name">f</span> <span class="hljs-number">1</span>) (<span class="hljs-name">g</span> <span class="hljs-number">1</span>)))) <span class="hljs-comment">;; (1 1)</span><br></code></pre></td></tr></table></figure><h3 id="syntax-rules"><a href="#syntax-rules" class="headerlink" title="syntax-rules"></a>syntax-rules</h3><p>基本语法: <code>(syntax-rules (literal ...) (pattern template) ...)</code></p><p>返回一个transformer, 实际就是一个 <code>procedure</code>, 这个 <code>procedure</code> 接受一个 syntax<br>object,然后返回一个syntax object.</p><ul><li>literal: 一些关键字, 出现在pattern会原样匹配</li><li>pattern: 用于匹配输入的表达式的模式</li><li>template: 输出,记住template是原样输出,这是和syntax-case的最大区别.</li><li>下划线’_‘: 可以匹配任何结构,一般用来代表宏名</li><li>… : 代表前面的部分重复0次或者多次</li></ul><p>一个例子,这个例子实现一个类 <code>if</code> 的条件判断语句,他的形式是 <code>(my-if cond then exp1 else exp2)</code> 这看起来更可读性更好:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> my-if<br>  (<span class="hljs-name"><span class="hljs-built_in">syntax-rules</span></span> (<span class="hljs-name">then</span> else)<br>    [(<span class="hljs-name">_</span> condition then true-exp else false-exp)<br>     (<span class="hljs-name"><span class="hljs-built_in">if</span></span> condition true-exp false-exp)]))<br></code></pre></td></tr></table></figure><p><code>then, else</code> 是关键字,所以它会原样的匹配输入</p><h3 id="syntax-object"><a href="#syntax-object" class="headerlink" title="syntax object"></a>syntax object</h3><p><code>(syntax template)</code> 的缩写为 <code>#&#39;template</code>, syntax和quote很类似,只是它会将<br>template中的pattern variable替换掉, 并且会绑定上下文信息</p><ol><li>syntax: 创建一个字面的 syntax object,比如 <code>(syntax &#39;(+ 1 x))</code>, 简写 <code>#&#39;(+ 1 x)</code>.</li><li>syntax-&gt;datum: 将一个syntax object转换为它原来的内容.</li><li>identifier? : 测试一个syntax object 是不是标识符</li><li>syntax-e : 只解包一层.</li></ol><h3 id="syntax-case"><a href="#syntax-case" class="headerlink" title="syntax-case"></a>syntax-case</h3><p>比 <code>syntax-rules</code> 更具一般性,而且更通用, 使用syntax-case的一般形式是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs example">(define-syntax macro-name<br>   (lambda (x)<br>     (syntax-case x (other keywords go here if any)<br>       [<br>         (macro-name macro-arg1 macro-arg2)<br>         ;;Expansion of macro (one or multiple forms)<br>         ;;(syntax is a reserved word)<br>         (syntax (expansion of macro goes here))<br>       ]  ...<br> )))<br></code></pre></td></tr></table></figure><p>解释一下上面的代码: 整个lambda定义的就是一个macro transformer, 它的唯一参数 x<br>实际就是一个包含了原始代码的syntax object. 通过syntax-case<br>来匹配x,然后返 回一个包含了转换后代码的syntax object</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> my-if<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x)<br>    (<span class="hljs-name"><span class="hljs-built_in">syntax-case</span></span> x (<span class="hljs-name">then</span> else)<br>      [(<span class="hljs-name">_</span> condition then true-exp else false-exp)<br>       (<span class="hljs-name"><span class="hljs-built_in">syntax</span></span> (<span class="hljs-name"><span class="hljs-built_in">if</span></span> condition true-exp false-exp))])))<br><span class="hljs-comment">;;Define a new macro</span><br>(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> swap!<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x)<br>    <span class="hljs-comment">;;we don&#x27;t have any keywords this time</span><br>    (<span class="hljs-name"><span class="hljs-built_in">syntax-case</span></span> x ()<br>      [(<span class="hljs-name">swap!</span> a b)<br>       (<span class="hljs-name"><span class="hljs-built_in">syntax</span></span><br>        (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">c</span> a))<br>          (<span class="hljs-name"><span class="hljs-built_in">set!</span></span> a b)<br>          (<span class="hljs-name"><span class="hljs-built_in">set!</span></span> b c)))]<br>      )))<br><br>(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> syntax-rules<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x)<br>    (<span class="hljs-name"><span class="hljs-built_in">syntax-case</span></span> x ()<br>      [(<span class="hljs-name">_</span> (<span class="hljs-name">i</span> ...) ((<span class="hljs-name">keyword</span> . pattern) template) ...)<br>       #&#x27;(lambda (x)<br>           (syntax-case x (i ...)<br>             [(_ . pattern) #<span class="hljs-symbol">&#x27;template</span>] ...))])))<br></code></pre></td></tr></table></figure><h3 id="with-syntax"><a href="#with-syntax" class="headerlink" title="with-syntax"></a>with-syntax</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define-syntax</span></span> with-syntax<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x)<br>    (<span class="hljs-name"><span class="hljs-built_in">syntax-case</span></span> x ()<br>      [(<span class="hljs-name">_</span> ((<span class="hljs-name">p</span> e) ...) b1 b2 ...)<br>       #&#x27;(syntax-case (list e ...) ()<br>           [(p ...) (let () b1 b2 ...)])])))<br></code></pre></td></tr></table></figure><h2 id="input-and-output"><a href="#input-and-output" class="headerlink" title="input and output"></a>input and output</h2><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><p>scheme的输入输出用到一个叫做port的对象,port也是first class object, port有很<br>多种类,比如文件,字符缓冲区, tcp网络连接, 管道等等</p><ol><li>文件:<ul><li><p>(open-output-file fname) : 返回一个port,用于将内容写入到文件</p></li><li><p>(open-input-file fname) : 返回一个port用于读取指定文件的内容</p></li><li><p>(close-output-port port)</p></li><li><p>(close-input-port port)<br>还有一种常用方式(更简单, 会自动关闭port):</p></li><li><p>(call-with-input-file filename proc) : 打开filename并将得到的port传递<br>给proc, 并且调用完成时会关闭port</p></li><li><p>(call-with-output-file filename proc) : 打开filename并将得到的port传递<br>给proc, 并且调用完成时会关闭port</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">call-with-output-file</span></span> <span class="hljs-string">&quot;data&quot;</span><br>  #:exists <span class="hljs-symbol">&#x27;truncate</span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (out)<br>    (<span class="hljs-name"><span class="hljs-built_in">display</span></span> <span class="hljs-string">&quot;hello&quot;</span> out)))<br><br>(<span class="hljs-name"><span class="hljs-built_in">call-with-input-file</span></span> <span class="hljs-string">&quot;data&quot;</span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (in)<br>    (<span class="hljs-name">read-line</span> in)))<br></code></pre></td></tr></table></figure></li></ul></li><li>字符缓冲区<ul><li>(open-output-string) :</li><li>(open-input-string “xxx”):</li></ul></li></ol><!-- end list --><ol><li><p>default port</p><p>默认解释器会打开2个port, 一个输入,一个输出,分别会绑定到shell的输入输出,很 多实现还会打开一个error<br>port,用于IO的scheme procedure都可以带一个可选的参 数port, 如果不指定port,<br>那么就使用默认的port, 默认的port有这两个函数获得</p><ul><li>(current-input-port)</li><li>(current-output-port)</li></ul><p>如果要改变默认的port,可以使用下面的两个函数:</p><ul><li>(with-input-from-file filename thunk) : 将默认的 input port重新绑定到文<br>件,这可以实现重定向</li><li>(with-output-from-file filename thunk) : 将默认的 output port重新绑定到<br>文件,这可以实现重定向</li></ul></li></ol><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><ul><li>输入:<ol><li>read: 它会自动将读入的内容转换为scheme内置的数据结构,实际是一个递归下 降的parser</li><li>(read-char), (read-char input-port): next character</li></ol></li><li>输出:<ol><li>print</li><li>write</li><li>display</li><li>printf: 可以指定一个字符串来格式化,用的较多</li><li>fprintf: 写入文件,多一个port参数</li></ol></li></ul><h3 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">call-with-input-file</span></span> <span class="hljs-string">&quot;myfile.ss&quot;</span><br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (p)<br>    (<span class="hljs-name"><span class="hljs-built_in">let</span></span> f ((<span class="hljs-name">x</span> (<span class="hljs-name"><span class="hljs-built_in">read</span></span> p)))<br>      (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">eof-object?</span></span> x)<br>          &#x27;()<br>          (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> x (<span class="hljs-name">f</span> (<span class="hljs-name"><span class="hljs-built_in">read</span></span> p)))))))<br><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> read-word<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (p)<br>    (<span class="hljs-name"><span class="hljs-built_in">list-&gt;string</span></span><br>      (<span class="hljs-name"><span class="hljs-built_in">let</span></span> f ()<br>        (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">c</span> (<span class="hljs-name"><span class="hljs-built_in">peek-char</span></span> p)))<br>          (<span class="hljs-name"><span class="hljs-built_in">cond</span></span><br>            ((<span class="hljs-name"><span class="hljs-built_in">eof-object?</span></span> c) &#x27;())<br>            ((<span class="hljs-name"><span class="hljs-built_in">char-alphabetic?</span></span> c)<br>             (<span class="hljs-name"><span class="hljs-built_in">read-char</span></span> p)<br>             (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> c (<span class="hljs-name">f</span>)))<br>            (<span class="hljs-name"><span class="hljs-built_in">else</span></span> &#x27;())))))))<br><br></code></pre></td></tr></table></figure><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><p>递归的思想要从逻辑上理解，在设计一个递归函数时，一开始就要明确该函数在逻辑上<br>的作用(不要一开始就陷入编码细节中)，然后分清该函数在逻辑上与子问题的联系，并<br>以此为 依据来进行函数体的设计, 特别需要注意检查结束条件,比如加法(0), 乘法 (1), list(‘())就是一些结束条件.</p><p>递归函数的设计要点：</p><ol><li>要明确检查终止条件（null？ zero？）</li><li>要明确与子问题的关系，弄清分类的情况（cond）</li></ol><h2 id="continuation"><a href="#continuation" class="headerlink" title="continuation"></a>continuation</h2><p>scheme中获得当前continuation的构造是call&#x2F;cc, let&#x2F;cc</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">let/cc</span> k                               <span class="hljs-comment">;k is the continuation</span><br>        body)<br><span class="hljs-comment">;;; identical</span><br>(<span class="hljs-name"><span class="hljs-built_in">call/cc</span></span> (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (k)                    <span class="hljs-comment">;k is the continuation</span><br>           body))<br></code></pre></td></tr></table></figure><h2 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h2><figure class="highlight scheme"><figcaption><span>numberLines</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> last-try<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> ( x )<br>    (<span class="hljs-name"><span class="hljs-built_in">and</span></span> ( will-stop ? last-try)<br>         ( eternity x ))))<br></code></pre></td></tr></table></figure><p>上述代码中:eternity会永远运行,比如:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> eternity<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (x)<br>    (<span class="hljs-name">eternity</span> x)))<br></code></pre></td></tr></table></figure><p>假设存在停机函数 <code>will-stop?</code>, <code>will-stop?</code> 可以测试出一个函数是否会停机.那么:</p><ol><li>假设 <code>last-try</code> 会停机, 那么 <code>(will-stop? last-try)</code> 返回 #t, 因此也就会运行<br><code>(eternity x)</code>, 前面说了, eternity会永远运行, 所以 <code>last-try</code> 不会停机.</li><li>假设 <code>last-try</code> 不停机, 那么 <code>(will-stop? last-try)</code> 返回 #f, 因此也就不会运 行<br><code>(eternity x)</code>, 那么 <code>last-try</code> 很显然就会返回. 所以 <code>last-try</code> 会停机</li></ol><p>因此这就是个悖论.因此停机函数 will-stop?不存在</p><h2 id="some-example-code-the-little-schemer"><a href="#some-example-code-the-little-schemer" class="headerlink" title="some example code(the little schemer)"></a>some example code(the little schemer)</h2><h1 id="racket"><a href="#racket" class="headerlink" title="racket"></a>racket</h1><h2 id="struct-新的数据类型-struct"><a href="#struct-新的数据类型-struct" class="headerlink" title="struct(新的数据类型) struct"></a>struct(新的数据类型) <span class="tag" data-tag-name="struct"><span class="smallcaps">struct</span></span></h2><p>语法形式: <code>(struct struct-id (field-id ...))</code></p><ul><li>struct-id : 是一个constructor, 可以用来构建一个该数据类型的实例</li><li>struct-id? :一个predication,测试是否是该数据类型的实例</li><li>struct-id-field-id: 从实例中获取 <code>field-id</code> 属性的值</li></ul><p>下面来看个例子:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">struct</span> posn (<span class="hljs-name">x</span> y))                     <span class="hljs-comment">;定义一个posn类型</span><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> pos1 (<span class="hljs-name">posn</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>))                <span class="hljs-comment">;struct-id: 构建一个posn实例</span><br>(<span class="hljs-name">posn?</span> pos1)                            <span class="hljs-comment">;struct-id?: 是否为一个posn对象实例</span><br>(<span class="hljs-name">posn-x</span> pos1)                           <span class="hljs-comment">;struct-id-field-id: 获得x属性</span><br></code></pre></td></tr></table></figure><h3 id="复制更新"><a href="#复制更新" class="headerlink" title="复制更新"></a>复制更新</h3><p>根据已有对象更新其中的特定域然后返回新对象</p><p>语法形式: <code>(struct-copy struct-id struct-expr [field-id expr] ...)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs example">Examples:<br><br>&gt; (define p1 (posn 1 2))<br>&gt; (define p2 (struct-copy posn p1 [x 3]))<br>&gt; (list (posn-x p2) (posn-y p2))<br><br>&#x27;(3 2)<br>&gt; (list (posn-x p1) (posn-x p2))<br><br>&#x27;(1 3)<br></code></pre></td></tr></table></figure><h3 id="subtypes-类似于继承-subtypes"><a href="#subtypes-类似于继承-subtypes" class="headerlink" title="subtypes(类似于继承) subtypes"></a>subtypes(类似于继承) <span class="tag" data-tag-name="subtypes"><span class="smallcaps">subtypes</span></span></h3><p>语法形式: <code>(struct struct-id super-id (field-id ...))</code></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">struct</span> posn (<span class="hljs-name">x</span> y))<br>(<span class="hljs-name">struct</span> pos3d posn (<span class="hljs-name">z</span>))<br></code></pre></td></tr></table></figure><p>那么pos3d就有 <code>(x y z)</code> 三个属性</p><h2 id="match-模式匹配-match"><a href="#match-模式匹配-match" class="headerlink" title="match(模式匹配) match"></a>match(模式匹配) <span class="tag" data-tag-name="match"><span class="smallcaps">match</span></span></h2><p>正则表达式只能用来匹配字符串,而 <code>match</code> 可以用来匹配任何的 <code>scheme value</code>, 它的语法形式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(match target-expr<br>  [pattern expr ...+] ...)<br></code></pre></td></tr></table></figure><p>将 <code>target-expr</code> 与 pattern匹配, 如果匹配成功就执行后面的expr, 对pattern的 语法要做以下说明:</p><ul><li><p>… 或 <span class="underline">_</span> : 代表0次或者多次</p></li><li><p>..k 或 _<sub>k</sub> : 代表至少 <code>k</code> 此 下面是一个将let转换为等价的lambda形式的例子</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">match</span> &#x27;(let ([a <span class="hljs-number">1</span>]<br>              [b <span class="hljs-number">2</span>])<br>          (set! a <span class="hljs-number">11</span>)<br>          (- a b))<br>       [`(let ([,var* ,val*] ...) ,body* ...)<br>        `((lambda (,@var*)<br>            ,@body*) ,@val*)])<br></code></pre></td></tr></table></figure><p>注意因为…的作用,上面的var*, val*, body*都是列表, 所以在后面需要使用 ,@来 分解.</p></li><li><p>literal: 字面值直接用 <code>equal?</code> 测试是否相等</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">match</span> <span class="hljs-number">2</span><br>       [<span class="hljs-name">1</span> <span class="hljs-symbol">&#x27;one</span>]<br>       [<span class="hljs-name">2</span> <span class="hljs-symbol">&#x27;two</span>]<br>       [<span class="hljs-name">3</span> <span class="hljs-symbol">&#x27;three</span>])<br>(<span class="hljs-name">match</span> <span class="hljs-literal">#f</span><br>       [<span class="hljs-literal">#t</span> <span class="hljs-symbol">&#x27;yes</span>]<br>       [<span class="hljs-literal">#f</span> <span class="hljs-symbol">&#x27;no</span>])<br></code></pre></td></tr></table></figure></li><li><p>(list lvp …): 会绑定对应的标识符,注意几个特殊符号,vector和list类似</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">match</span> &#x27;(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br>[(<span class="hljs-name"><span class="hljs-built_in">list</span></span> a <span class="hljs-symbol">&#x27;+</span> b) (<span class="hljs-name"><span class="hljs-built_in">+</span></span> a b)])         <span class="hljs-comment">;return 3</span><br><br>(<span class="hljs-name">match</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br>[(<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> a ...) a])                 <span class="hljs-comment">;return &#x27;(2 3)</span><br><br>(<span class="hljs-name">match</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)<br>[(<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> a ..3) a]<br>[<span class="hljs-name">_</span> <span class="hljs-symbol">&#x27;else</span>])                          <span class="hljs-comment">;return &#x27;(2 3 4)</span><br></code></pre></td></tr></table></figure><p>上例中 <code>a b</code> 就被绑定为 1, 2</p></li><li><p>(struct-id pat …)或者(struct struct-id (pat …)):匹配一个实例,并且绑定 一些变量</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">define-struct</span> tree (<span class="hljs-name">val</span> left right))<br>(<span class="hljs-name">match</span> (<span class="hljs-name">make-tree</span> <span class="hljs-number">0</span> (<span class="hljs-name">make-tree</span> <span class="hljs-number">1</span> <span class="hljs-literal">#f</span> <span class="hljs-literal">#f</span>) <span class="hljs-literal">#f</span>)<br>       [(<span class="hljs-name">tree</span> a (<span class="hljs-name">tree</span> b  _ _) _) (<span class="hljs-name"><span class="hljs-built_in">list</span></span> a b)])       <span class="hljs-comment">;&#x27;(0 1)</span><br></code></pre></td></tr></table></figure></li><li><p>(struct struct-id _) :匹配任何 struct-id的实例</p></li><li><p>(? expr pat …): expr是一个predication, 只有它返回true的时候,才会匹配后 面的pat</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">match</span> &#x27;(<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>)<br>       [(<span class="hljs-name"><span class="hljs-built_in">list</span></span> (<span class="hljs-name">?</span> odd?) ...) <span class="hljs-symbol">&#x27;yes</span>])<br></code></pre></td></tr></table></figure><p>它的工作原理是这样,以下面的例子为例:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">match</span> &#x27;((<span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-number">3</span> <span class="hljs-number">6</span>)<br>       [`(,(? pred? `(,a1 ,a2)) ,b ,c) `(,a1 ,b ,c)])<br></code></pre></td></tr></table></figure><p>如果上面的例子匹配, 那么b, c应该分别绑定3, 6, 那么前面的 <code>(? pred? `(,a1 ,a2))</code> 应该匹配(1 2), 所以先将(1 2) 传递给pred?, 如果pred? 返回#t, 那么接 着用(1 2)<br>去匹配后面的`(,a1 ,a2). 也就是说pred? 只会检查(? pred? …) 匹配 的那一部分.</p></li><li><p>(quasiquote qp): unqote或unquote-splicing的部分会绑定为变量,其它部分会原样匹配</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">match</span> &#x27;(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br>[`(,a + ,b) (<span class="hljs-name"><span class="hljs-built_in">+</span></span> a b)])<br></code></pre></td></tr></table></figure><p>a b都是unquote指定的部分,所以绑定为变量, 其它部分比如 + 就原样匹配, 可以和 (? expr pat …)结合使用:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">match</span> &#x27;(+ a <span class="hljs-string">&quot;hello&quot;</span>)<br>       [`(+ a ,(? number? x)) x]<br>       [`(+ a ,(? string? x)) x])<br></code></pre></td></tr></table></figure><p>关于quasiquote的一些说明:</p><ul><li><p>quasiquote(`): 和quote(‘)类似, 只是表达式中的unquote会求值在返回,如果没<br>有unquote,那么它的行为就和 <code>quote</code> 一样,来看几个例子: <code>(cons a b)</code> 等价于<br><code>`(,a ,b)</code></p></li><li><p>unquote(,): 指定的部分会先求职,在插入list中</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">quasiquote</span></span> (<span class="hljs-name">1</span> <span class="hljs-number">2</span> (<span class="hljs-name">unquote</span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>)) (<span class="hljs-name">unquote</span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> <span class="hljs-number">5</span> <span class="hljs-number">1</span>))))<br><span class="hljs-comment">;;; equivalent</span><br>`(<span class="hljs-number">1</span> <span class="hljs-number">2</span> ,(+ <span class="hljs-number">1</span> <span class="hljs-number">2</span>) ,(+ <span class="hljs-number">5</span> <span class="hljs-number">1</span>))                <span class="hljs-comment">;&#x27;(1 2 3 6)</span><br></code></pre></td></tr></table></figure></li><li><p>unquote-splicing(,@): 和unquote的行为类似, 只是它所指定的表达式求值后必<br>须返回list,这个list中的元素会拆开然后插入原list中</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">`(<span class="hljs-number">1</span> <span class="hljs-number">2</span> ,@(list (+ <span class="hljs-number">1</span> <span class="hljs-number">2</span>) (<span class="hljs-number">2</span> <span class="hljs-number">2</span>)) <span class="hljs-number">5</span>)         <span class="hljs-comment">;&#x27;(1 2 3 4 5)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>module的基本语法是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(module name-id initial-module-path<br>  decl ...)<br></code></pre></td></tr></table></figure><p>例子:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">module</span> cake racket<br>        (<span class="hljs-name"><span class="hljs-built_in">provide</span></span> print-cake)<br><br>        (<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">print-cake</span> n)<br>          (<span class="hljs-name">show</span> <span class="hljs-string">&quot;   ~a   &quot;</span> n <span class="hljs-literal">#\.</span>)<br>          (<span class="hljs-name">show</span> <span class="hljs-string">&quot; .-~a-. &quot;</span> n <span class="hljs-literal">#\|</span>)<br>          (<span class="hljs-name">show</span> <span class="hljs-string">&quot; | ~a | &quot;</span> n <span class="hljs-literal">#\space</span>)<br>          (<span class="hljs-name">show</span> <span class="hljs-string">&quot;---~a---&quot;</span> n <span class="hljs-literal">#\-</span>))<br><br>        (<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">show</span> fmt n ch)<br>          (<span class="hljs-name">printf</span> fmt (<span class="hljs-name"><span class="hljs-built_in">make-string</span></span> n ch))<br>          (<span class="hljs-name"><span class="hljs-built_in">newline</span></span>)))<br></code></pre></td></tr></table></figure><ul><li>name-id: module的名字,上例是 <code>cake</code></li><li>initial-module-path: 初始化要导入的module, 上例是 <code>racket</code></li><li>provide : 可选的,也就是规定哪些东西是可以导出的,上例中 <code>print-cake</code> 会导 出,但是 <code>show</code> 是模块私有,<br>如果不提供 <code>provide</code> 那么所有的属性都是私有的, 所以一个模块必须指定 <code>provide</code> 才对导入者有意义</li></ul><p>声明一个模块并不会直接对模块的 <code>body</code> 部分求值,只有当使用 <code>require</code> 明确导 入该模块时才会求值</p><h3 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h3><p>一个文件只能包含一个顶层模块,这个模块可以通过 <code>module</code> 指定,也可以通 过 <code>lang lang-name</code> 来间接的指定,<br>那么在这个顶层模块中又可以定义子模块,比 如如下代码:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scheme">#lang racket<br>(<span class="hljs-name">module</span> zoo racket<br>        (<span class="hljs-name"><span class="hljs-built_in">provide</span></span> tiger)<br>        (<span class="hljs-name"><span class="hljs-built_in">define</span></span> tiger <span class="hljs-string">&quot;Tony&quot;</span>))<br><br>(<span class="hljs-name"><span class="hljs-built_in">require</span></span> <span class="hljs-symbol">&#x27;zoo</span>)<br><br>tiger<br></code></pre></td></tr></table></figure><p>上面的代码(假设文件名是park.rtk) <code>#lang racket</code> 指定了顶层模块, 而 <code>zoo</code> 是 一个子模块,<br>在顶层模块中可以直接通过 <code>(require &#39;zoo)</code> 来包含子模块, 如果是 在该文件以外,<br>你需要导入该文件的模块, 使用 <code>(require &quot;park.rtk&quot;)</code> 只会导入 顶层模块, 使用submode语法比如<br><code>(require (submod &quot;park.rtk&quot; zoo))</code> 就可以导 入子模块了</p><ol><li><p>module* :module*:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(module* name-id initial-module-path-or-#f<br>decl ...)<br></code></pre></td></tr></table></figure><p>使用 <code>module</code> 声明的子模块可以可以被父模块导入, 但是子模块不能导入父模块, 而恰恰相反,使用 <code>module*</code><br>声明的模块可以导入父模块, 可是父模块不能导入该子 模块, 如果指定 <code>#f</code> 作为默认导入模块,<br>那么父模块中的所有绑定在子模块中都可 见.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scheme">#lang racket<br><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">print-cake</span> n)<br>  (<span class="hljs-name">show</span> <span class="hljs-string">&quot;   ~a   &quot;</span> n <span class="hljs-literal">#\.</span>)<br>  (<span class="hljs-name">show</span> <span class="hljs-string">&quot; .-~a-. &quot;</span> n <span class="hljs-literal">#\|</span>)<br>  (<span class="hljs-name">show</span> <span class="hljs-string">&quot; | ~a | &quot;</span> n <span class="hljs-literal">#\space</span>)<br>  (<span class="hljs-name">show</span> <span class="hljs-string">&quot;---~a---&quot;</span> n <span class="hljs-literal">#\-</span>))<br><br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">show</span> fmt n ch)<br>  (<span class="hljs-name">printf</span> fmt (<span class="hljs-name"><span class="hljs-built_in">make-string</span></span> n ch))<br>  (<span class="hljs-name"><span class="hljs-built_in">newline</span></span>))<br><br>(<span class="hljs-name">module*</span> main <span class="hljs-literal">#f</span><br>         (<span class="hljs-name">print-cake</span> <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>在上面的 <code>main</code> 这个submodule中, 顶层模块的所有绑定都可见, 注意当一个<br>submodule的名字为main时,有一个特殊的地方,也就是说当前的文件作为执行文件时<br>(racket file-name.rtk),即便你没有使用 <code>(require &#39;main)</code> 语句, 这个子模块仍<br>然会运行,和python的&#x3D;ifmain&#x3D; 很类似,所以这个main模块可以写一些本模块的测试 代码</p></li><li><p>module+ :module+:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(module+ name-id<br>decl ...)<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(module* name-id #f<br>  decl ...)<br></code></pre></td></tr></table></figure><p>module+一般用来写 <code>test</code> 模块, 多个test模块会合并为一个test模块, 使用raco test<br>filename.rkt来运行测试代码</p></li></ol><h3 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h3><p>racket的源文件一般需要使用 <code>#lang lang-name</code> 这样的方式来指定语言,这个实际是一 个module的简写方式,比如<br><code>#lang racket</code> 等价于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">(module name racket<br>  decl ...)<br></code></pre></td></tr></table></figure><p>所以 <code>#lang racket</code> 的意思就是定义一个module, 该模块的名字一般继承自文件名, 然后将racket作为初始模块导入.</p><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><ol><li><p>如果是文件那么应该使用这样的语法:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">require</span></span> <span class="hljs-string">&quot;aa.rkt&quot;</span>)<br>(<span class="hljs-name"><span class="hljs-built_in">require</span></span> <span class="hljs-string">&quot;../aa.rkt&quot;</span>)<br>(<span class="hljs-name"><span class="hljs-built_in">require</span></span> <span class="hljs-string">&quot;../subdirectory/aa.rkt&quot;</span>)<br></code></pre></td></tr></table></figure><p>以当前文件的路径为当前路径,使用和shell类似的路径表达方式来确定需要导入的模 块的名字,记住要带扩展名</p></li><li><p>当前文件的子模块: <code>(require &#39;name)</code></p></li><li><p>标准模块: <code>(require racket)</code></p></li><li><p>子模块: <code>(require (submod &quot;aa.rkt&quot; submod-name))</code></p></li></ol><h3 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h3><ul><li>导出所有: <code>(provide (all-defined-out))</code></li><li>只导出通过require引入的绑定: <code>(provide (all-from-out))</code></li><li>导出除指定的外所有的绑定: <code>(provide (except-out name ...))</code></li><li>重命名: <code>(provide (rename-out [orgn-id export-id]))</code></li></ul><p>some example:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">provide</span></span> run run-all)<br>(<span class="hljs-name"><span class="hljs-built_in">provide</span></span> (<span class="hljs-name">all-defined-out</span>))<br></code></pre></td></tr></table></figure><h1 id="typed-racket"><a href="#typed-racket" class="headerlink" title="typed racket"></a>typed racket</h1><h2 id="sample-program"><a href="#sample-program" class="headerlink" title="sample program"></a>sample program</h2><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scheme">#lang typed/racket<br>(<span class="hljs-name">struct:</span> pt ([<span class="hljs-name">x</span> : Real] [<span class="hljs-name">y</span> : Real]))<br><br>(<span class="hljs-name">:</span> distance (<span class="hljs-name">pt</span> pt -&gt; Real))<br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">distance</span> p1 p2)<br>  (<span class="hljs-name"><span class="hljs-built_in">sqrt</span></span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> (<span class="hljs-name">sqr</span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> (<span class="hljs-name">pt-x</span> p2) (<span class="hljs-name">pt-x</span> p1)))<br>           (<span class="hljs-name">sqr</span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> (<span class="hljs-name">pt-y</span> p2) (<span class="hljs-name">pt-y</span> p1))))))<br></code></pre></td></tr></table></figure><h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><h3 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h3><ol><li>Number</li><li>Char</li><li>String</li><li>Boolean</li></ol><h3 id="Function-Type"><a href="#Function-Type" class="headerlink" title="Function Type"></a>Function Type</h3><p>(Number -&gt; Number) (String String -&gt; Number)</p><h3 id="Union-Type"><a href="#Union-Type" class="headerlink" title="Union Type"></a>Union Type</h3><p>当一个类型有几种变种时, 应该使用Union Type</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scheme">#lang typed/racket<br>(<span class="hljs-name">define-type</span> Tree (<span class="hljs-name">U</span> leaf node))<br>(<span class="hljs-name">struct:</span> leaf ([<span class="hljs-name">val</span> : Number]))<br>(<span class="hljs-name">struct:</span> node ([<span class="hljs-name">left</span> : Tree] [<span class="hljs-name">right</span> : Tree]))<br><br>(<span class="hljs-name">:</span> tree-height (<span class="hljs-name">Tree</span> -&gt; Integer))<br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">tree-height</span> t)<br>  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> [(<span class="hljs-name">leaf?</span> t) <span class="hljs-number">1</span>]<br>        [<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name"><span class="hljs-built_in">max</span></span> (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name">tree-height</span> (<span class="hljs-name">node-left</span> t)))<br>                   (<span class="hljs-name"><span class="hljs-built_in">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name">tree-height</span> (<span class="hljs-name">node-right</span> t))))]))<br><br></code></pre></td></tr></table></figure><p>上面的Tree就包含两种类型, Node与Leaf</p><h3 id="Recursive-Type"><a href="#Recursive-Type" class="headerlink" title="Recursive Type"></a>Recursive Type</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">define-type</span> BinaryTree (<span class="hljs-name">Rec</span> BT (<span class="hljs-name">U</span> Number (<span class="hljs-name">Pair</span> BT BT))))<br></code></pre></td></tr></table></figure><h3 id="Subtyping"><a href="#Subtyping" class="headerlink" title="Subtyping"></a>Subtyping</h3><p>任何类型都是Any的子类型.</p><h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">:</span> list-length (<span class="hljs-name">All</span> (<span class="hljs-name">A</span>) ((<span class="hljs-name">Listof</span> A) -&gt; Integer)))<br>(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">list-length</span> l)<br>  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> l)<br>      <span class="hljs-number">0</span><br>      (<span class="hljs-name">add1</span> (<span class="hljs-name">list-length</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> l)))))<br></code></pre></td></tr></table></figure><p>注意上面的 <code>All</code>.</p><h1 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h1>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lisp</tag>
      
      <tag>lang</tag>
      
      <tag>scheme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clojure笔记</title>
    <link href="/notes/clojure/"/>
    <url>/notes/clojure/</url>
    
    <content type="html"><![CDATA[<h1 id="Clojure-Forms"><a href="#Clojure-Forms" class="headerlink" title="Clojure Forms"></a>Clojure Forms</h1><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><ul><li>typical value: true, false</li><li>useful function:<ol><li>not</li><li>and</li><li>or</li></ol></li></ul><h2 id="Nil"><a href="#Nil" class="headerlink" title="Nil"></a>Nil</h2><ul><li>typical value: nil 只有false与nil会被计算为false,其它的都为true</li></ul><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><ul><li>typical value:  .̧̱..</li></ul><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul><li>typical value: 1 2</li><li>useful function:<ol><li>+, -, *</li><li>&#x2F;(分数形式),quot(商),rem(余数)</li><li>inc,dec</li><li>min, max</li><li>=<code>,&lt;,&lt;</code>,&gt;,&gt;&#x3D;</li><li>zero?,pos?,neg?,number?</li></ol></li></ul><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ul><li>typical value: user&#x2F;foo</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>typical value: “hello”</li><li>useful function:<ol><li>str: 拼接多个字符串</li><li>subs: 子字符串(0为开始下标)</li><li>string?</li><li>print &amp; println: 后者自动添加一个新行</li></ol></li></ul><h3 id="regex-regex"><a href="#regex-regex" class="headerlink" title="regex regex"></a>regex <span class="tag" data-tag-name="regex"><span class="smallcaps">regex</span></span></h3><ol><li>re-pattern:创建一个正则表达式, <code>(re-pattern &quot;[abcd]&quot;)</code> 等价于 #“[abcd]“,</li></ol><h2 id="KeyWord"><a href="#KeyWord" class="headerlink" title="KeyWord"></a>KeyWord</h2><ul><li>typical value: :tag :doc</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li>typical value: (+ 1 3) (println “foo”)</li></ul><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li>typical value: [1 2 3]</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li>typical value: {:key1 val1, :key2 val2 …} {“Lisp” “McCarthy”<br>“Clojure” “Hickey”}</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>typical value: #{:val1 :val2 …}</li></ul><h1 id="seq-operation"><a href="#seq-operation" class="headerlink" title="seq operation"></a>seq operation</h1><p>clojure的sequence都是不可变的.</p><ul><li>first: like car in scheme</li><li>rest: like cdr in scheme</li><li>cons: like cons in scheme (Construct)</li><li>conj: 将单个元素插入seq,对于list是插入到最前面,对于vector是插入最后面</li><li>into: 将后一个seq插入到前一个seq,对list是插入最前面,对vector是插入最后面</li></ul><h2 id="seq-library"><a href="#seq-library" class="headerlink" title="seq library"></a>seq library</h2><p>下面的函数对任何类型的sequence都有效, 而且这些操作除极少数外基本都返回 lazy sequence.</p><ul><li><p>empty? : same as null? in scheme.</p></li><li><p>seq : 如果coll为空则返回 nil, 否则返回一个seq.</p></li><li><p>range: (range start? end step?)</p><figure class="highlight clojure"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">range</span></span> <span class="hljs-number">5</span>)<br><span class="hljs-comment">;;=&gt; (0 1 2 3 4)</span><br></code></pre></td></tr></table></figure></li><li><p>repeat:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">(repeat 5 &quot;a&quot;)          =&gt; (&quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; )<br>(repeat &quot;a&quot;)            =&gt; return an infinite seq<br>(take 5 (repeat &quot;a&quot;))   =&gt; (&quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; )<br></code></pre></td></tr></table></figure></li><li><p>(iterate f x): f可以看做是一个后继函数,返回一个无限序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">(take 5 (iterate inc 1))         =&gt; (1 2 3 4 5)<br></code></pre></td></tr></table></figure></li><li><p>take: 从一个无限序列中抽取指定个数的元素组成序列</p></li><li><p>cycle:返回一个无限的序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">(take 10 (cycle (range 3)))    =&gt; (0 1 2 0 1 2 0 1 2 0)<br></code></pre></td></tr></table></figure></li><li><p>interleave:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">(interleave &#x27;(1 2 3) &#x27;(a b c) &#x27;(x y z))     =&gt; (1 a x 2 b y 3 c z)<br></code></pre></td></tr></table></figure></li><li><p>interpose:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">(interpose \, [&quot;aa&quot; &quot;bb&quot; &quot;cc&quot;])     =&gt; [&quot;aa&quot; \, &quot;bb&quot; \, &quot;cc&quot; \,]<br></code></pre></td></tr></table></figure></li><li><p>(join sep seq) : 返回将seq中的元素用sep分割后的字符串</p></li><li><p>list:生成一个list</p></li><li><p>vector: 生成一个vector</p></li><li><p>hash-set:</p></li><li><p>hash-map:</p></li><li><p>filter:</p></li><li><p>map:</p></li><li><p>reduce:</p></li><li><p>split-at:将一个seq根据index分割为2个seq</p></li><li><p>split-with: 将一个seq根据一个predictive function的返回值分割为2个seq,true<br>为一个seq,false为一个seq</p></li><li><p>every?</p></li><li><p>some</p></li><li><p>not-every?</p></li><li><p>not-any?</p></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="function-definition"><a href="#function-definition" class="headerlink" title="function definition"></a>function definition</h2><ol><li><p>匿名函数(fn) <code>(fn [x y] (+ x y))</code> 创建一个匿名函数, <code>fn</code> 和 <code>lambda</code> 类似,fn还有一个简<br>写形式 <code>#(+ %1 %2)</code>.如果只有一个参数,那么可以用 % 代替 %1</p></li><li><p>def: 可以将一个匿名函数与一个name关联起来,和 <code>scheme</code> 中的 <code>define</code> 类似</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">my-add</span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [x y] (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x y)))<br></code></pre></td></tr></table></figure></li><li><p>defn: 是def 与 fn 的简写</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">my-add</span> [x y] (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x y))<br></code></pre></td></tr></table></figure></li><li><p>参数的解构</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">my-add</span> [x y [a b]]<br>  (<span class="hljs-name"><span class="hljs-built_in">+</span></span> x y a b))<br>(<span class="hljs-name">my-add</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> [<span class="hljs-number">3</span> <span class="hljs-number">4</span>])<br><span class="hljs-comment">; =&gt; 10</span><br></code></pre></td></tr></table></figure></li><li><p>Arities(可以看做是函数多态) 根据参数的不同而执行不同的动作</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">square-or-multiply</span><br>  <span class="hljs-string">&quot;squares a single argument, multiplies two arguments&quot;</span><br>  ([] <span class="hljs-number">0</span>)<br>  ([x] (<span class="hljs-name"><span class="hljs-built_in">*</span></span> x x))<br>  ([x y] (<span class="hljs-name"><span class="hljs-built_in">*</span></span> x y)))<br></code></pre></td></tr></table></figure><p>这应该也是为什么clojure中doc string是放在函数名之后而不是参数名之后的原因</p></li><li><p>递归: 由于jvm的关系,clojure不会自动进行尾递归优化,在尾递归的地方,你应该明 确的使用 <code>recur</code><br>这个关键词,而不是函数名</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">defn</span> <span class="hljs-title">my-add</span> [x y]<br>  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> x)<br>    y<br>    (<span class="hljs-name">my-add</span> (<span class="hljs-name"><span class="hljs-built_in">dec</span></span> x) (<span class="hljs-name"><span class="hljs-built_in">inc</span></span> y))))<br><br>(<span class="hljs-keyword">defn</span> <span class="hljs-title">my-add</span> [x y]<br>  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> x)<br>    y<br>    (<span class="hljs-name"><span class="hljs-built_in">recur</span></span> (<span class="hljs-name"><span class="hljs-built_in">dec</span></span> x) (<span class="hljs-name"><span class="hljs-built_in">inc</span></span> y))))<br></code></pre></td></tr></table></figure><p>第一个不会进行尾递归优化,第二个会进行尾递归优化</p></li><li><p>loop:和 <code>recur</code> 配合可以实现和循环类似的效果</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">loop</span></span> [i <span class="hljs-number">10</span> j <span class="hljs-number">10</span>]<br>  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> i)<br>    j<br>    (<span class="hljs-name"><span class="hljs-built_in">recur</span></span> (<span class="hljs-name"><span class="hljs-built_in">dec</span></span> i) (<span class="hljs-name"><span class="hljs-built_in">inc</span></span> j))))<br></code></pre></td></tr></table></figure><p>和scheme中使用 let 创建一个函数很相似</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">let</span></span> loop ([<span class="hljs-name">i</span> <span class="hljs-number">10</span>] [<span class="hljs-name">j</span> <span class="hljs-number">10</span>])<br>  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">zero?</span></span> i)<br>      j<br>      (<span class="hljs-name">loop</span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> i <span class="hljs-number">1</span>) (<span class="hljs-name"><span class="hljs-built_in">+</span></span> j <span class="hljs-number">1</span>))))<br></code></pre></td></tr></table></figure></li><li><p>curry 只提供部分参数给函数,比如我们可以这样定义 <code>add3</code></p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">add3</span> (<span class="hljs-name"><span class="hljs-built_in">partial</span></span> + <span class="hljs-number">3</span>))<br>(<span class="hljs-name">add3</span> <span class="hljs-number">4</span>)<br><span class="hljs-comment">;=&gt; 7</span><br></code></pre></td></tr></table></figure><p>partial 接受有一个函数以及部分参数,返回一个函数</p></li><li><p>comp: 可以生成一个函数,f(g(x))等价于 <code>((comp f g) x)</code></p></li></ol><h2 id="基本控制结构"><a href="#基本控制结构" class="headerlink" title="基本控制结构"></a>基本控制结构</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><h3 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h3><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><h3 id="letfn"><a href="#letfn" class="headerlink" title="letfn"></a>letfn</h3><h2 id="模块与namespace"><a href="#模块与namespace" class="headerlink" title="模块与namespace"></a>模块与namespace</h2><ol><li><p>require: 导入clojure模块</p></li><li><p>use: 导入clojure模块,与require的区别是,use会将指定模块的名字导入当前的<br>namespace,所以在引用时就不需要添加模块名作为前缀,而require则需要,一般情况<br>下推荐use</p></li><li><p>import: 导入java的类</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">import</span></span> &#x27;java.util.Date)<br><span class="hljs-comment">; (new Date)</span><br>(<span class="hljs-name"><span class="hljs-built_in">import</span></span> &#x27;(<span class="hljs-name">java.util.regex</span> Pattern Matcher))<br><span class="hljs-comment">; only import Pattern and Matcher in java.util.regex</span><br></code></pre></td></tr></table></figure></li><li><p>ns:创建一个命名空间,ns是一个宏,所以后面的参数不需要quote,而且注意后面的<br>require,use,import是以keyword的形式给出</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">ns</span></span> com.example.library<br>  (<span class="hljs-symbol">:require</span> [clojure.contrib.sql <span class="hljs-symbol">:as</span> sql])<br>  (<span class="hljs-symbol">:use</span> (<span class="hljs-name">com.example</span> one two))<br>  (<span class="hljs-symbol">:import</span> (<span class="hljs-name">java.util</span> Date Calendar)<br>           (<span class="hljs-name">java.io</span> File FileInputStream)))<br></code></pre></td></tr></table></figure></li></ol><h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><p>ref</p></li><li><p>deref(@)</p></li><li><p>ref-set: 需要使用 dosync来避免竞争条件</p></li><li><p>dosync: 被dosync包裹的表达式要么全部执行成功,要么都不执行,并且保证每一步<br>都不出现竞争条件,和数据库的存储过程很类似,实现了ACI,数据库的存储过程一般<br>实现了ACID.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">current-track</span> (<span class="hljs-name"><span class="hljs-built_in">ref</span></span> <span class="hljs-string">&quot;Venus, the Bringer of Peace&quot;</span>))<br><span class="hljs-comment">;; -&gt; #&#x27;user/current-track</span><br>(<span class="hljs-keyword">def</span> <span class="hljs-title">current-composer</span> (<span class="hljs-name"><span class="hljs-built_in">ref</span></span> <span class="hljs-string">&quot;Holst&quot;</span>))<br><span class="hljs-comment">;; -&gt; #&#x27;user/current-composer</span><br>(<span class="hljs-name"><span class="hljs-built_in">dosync</span></span><br> (<span class="hljs-name"><span class="hljs-built_in">ref-set</span></span> current-track <span class="hljs-string">&quot;Credo&quot;</span>)<br> (<span class="hljs-name"><span class="hljs-built_in">ref-set</span></span> current-composer <span class="hljs-string">&quot;Byrd&quot;</span>))<br></code></pre></td></tr></table></figure></li><li><p>alter : <code>(alter ref update-fn &amp; args...)</code>, <code>@ref</code> 作为update-fn的第一个参<br>数(这也是为什么下面的代码要用conj代替cons的原因),args作为剩余的参数,alter<br>可以看作是dosync,ref-set,deref的简写</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">message</span> (<span class="hljs-name"><span class="hljs-built_in">ref</span></span> ()))<br>(<span class="hljs-keyword">defn</span> <span class="hljs-title">navie-add-message</span> [msg]<br>  (<span class="hljs-name"><span class="hljs-built_in">dosync</span></span> (<span class="hljs-name"><span class="hljs-built_in">ref-set</span></span> message (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> msg (<span class="hljs-name"><span class="hljs-built_in">deref</span></span> message)))))<br><span class="hljs-comment">;;; identical</span><br>(<span class="hljs-keyword">defn</span> <span class="hljs-title">add-message</span> [msg]<br>  (<span class="hljs-name"><span class="hljs-built_in">alter</span></span> message conj msg))<br></code></pre></td></tr></table></figure></li></ol><h2 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h2><p>atom和ref很类似,但是atom当你仅仅只是需要原子的更新单个值时,使用更简便.</p><ol><li>atom: <code>(def (atom ()))</code></li><li>deref(@)</li><li>reset!: 更新原子的值</li><li>swap! : <code>(swap! r update-fn &amp; args)</code> 用一个函数调用来生成新的值</li></ol><h1 id="Macro"><a href="#Macro" class="headerlink" title="Macro"></a>Macro</h1><h2 id="几个简写"><a href="#几个简写" class="headerlink" title="几个简写"></a>几个简写</h2><ol><li><p>反引号(`) : 和scheme相同</p></li><li><p>~, ~@ 和scheme的 , ,@ 的含义相同,之所以用 ~ 是因为clojure中 , 与空格等价</p></li><li><p>id# :在一个标识符背后加上 # 意味着生成一个唯一的symbol, 比如 foo# 实际可 能就是 foo_004<br>可以看作是let与gensym的等价物,这在避免符号捕捉时很有用.</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-keyword">defmacro</span> <span class="hljs-title">and</span><br>  ([] <span class="hljs-literal">true</span>)<br>  ([x] x)<br>  ([x &amp; rest]<br>     `(<span class="hljs-name"><span class="hljs-built_in">let</span></span> [and# ~x]<br>        (<span class="hljs-name"><span class="hljs-built_in">if</span></span> and#<br>          (<span class="hljs-name"><span class="hljs-built_in">and</span></span> ~@rest)<br>          and#))))<br></code></pre></td></tr></table></figure><p>注意上面的 and# 不需要使用 ~ 来求值,因为 and# 本身就是一个独一无二的符号</p></li></ol><h1 id="调用java"><a href="#调用java" class="headerlink" title="调用java"></a>调用java</h1><ol><li>new : 创建一个对象. <code>(new String)</code></li><li>. : <code>(. target name &amp; args)</code></li><li>set! : <code>(set! (. target name) value)</code></li></ol><p>上面的3个操作符已经足够,但是为了方便,还有以下几个操作符</p><ol><li><p>ClassName&#x2F;field: 只对静态变量或者方法有效</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clojure">Integer/MIN_VALUE<br><span class="hljs-comment">; =&gt; -2147483648</span><br>(<span class="hljs-name">Integer/parseInt</span> <span class="hljs-string">&quot;101&quot;</span>)<br><span class="hljs-comment">; =&gt; 101</span><br></code></pre></td></tr></table></figure></li><li><p>.method : <code>(.method object args)</code> 可以看做等价于 <code>(. object method args)</code>,<br>但是要记住 .method并不是真正的第一类函数对象,所以你不能直接将它传递给 map,filter这类函数</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">map</span></span> #(<span class="hljs-name">.toUpperCase</span> %) [<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-string">&quot;two&quot;</span> <span class="hljs-string">&quot;three&quot;</span>])<br><span class="hljs-comment">; =&gt; (&quot;ONE&quot; &quot;TWO&quot; &quot;THREE&quot;)</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lisp</tag>
      
      <tag>lang</tag>
      
      <tag>clojure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua笔记</title>
    <link href="/notes/lua/"/>
    <url>/notes/lua/</url>
    
    <content type="html"><![CDATA[<h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>实际上是一个hash表, 把python中dict与list杂揉到了一起,设计的并不好.</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight lua"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> tbl = &#123;aa=<span class="hljs-number">1</span>, bb=<span class="hljs-number">2</span>, <span class="hljs-string">&quot;l1&quot;</span>, <span class="hljs-string">&quot;l2&quot;</span>, <span class="hljs-string">&quot;l3&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(#tbl)    <span class="hljs-comment">-- return 3</span><br><span class="hljs-keyword">local</span> tbl = &#123;aa=<span class="hljs-number">1</span>, bb=<span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">print</span>(#tbl)    <span class="hljs-comment">-- return 0</span><br></code></pre></td></tr></table></figure><p>表初始化时如果你没有指定key, 那么默认使用数字为key, 所以”l1”, “l2”,”l3”的key 分别是1,2,3.<br>也就是说被当成了list, 我建议将dict, list明确的区分开来, 有一个长 度操作符#<br>来获得list的长度,它实际上是获得最大的数字key. 举个例子，如果一个<br>table的数字key有这些：1,2,3,4,6,7, 那么#操作符会返回4, 因为中间有一个空洞的关<br>系，#检查到5的时候发现为nil就停止了 #u操作符大致等价于下面的函数.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_len</span><span class="hljs-params">(tbl)</span></span><br>   <span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br>   <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tbl[i] <span class="hljs-keyword">then</span><br>         <span class="hljs-keyword">return</span> i<span class="hljs-number">-1</span><br>      <span class="hljs-keyword">end</span><br>      i = i+<span class="hljs-number">1</span><br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="遍历table"><a href="#遍历table" class="headerlink" title="遍历table"></a>遍历table</h2><p>pairs，ipairs都会返回一个迭代器，只是pairs会迭代所有的key，ipairs只会迭代数字key。<br>所以为了方便起见，最好使用pairs</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tbl) <span class="hljs-keyword">do</span><br>  dosomething()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="metatable"><a href="#metatable" class="headerlink" title="metatable"></a>metatable</h1><p>lua的每一个表或者userdata都可以有单独的元表, 其他类型的值则共享该类型的元表, 比如说所有的整数都拥有一个相同的整数类型的元表,<br>我们一般对表的元表比较感兴趣.</p><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><ol><li>__index: <strong>元表的__index属性可以为函数或者表</strong>, 给定表tbl以及键key,获得 value的流程如下:<ul><li>tbl[key]: 如果为nil, 也就是说key不在tbl中, 那么看下面</li><li>检查tbl的元表, 如果有元表且元表有__index属性, 并且__index属性的值是函数 或者表,那么看下面,<br>否则返回nil</li><li>如果__index属性是一个函数, 那么这样调用 __index(tbl, key)</li><li>如果__index属性是一个表, 那么返回__index[key]</li></ul></li><li>__newindex: <strong>元表的__newindex属性可以为函数或者表</strong>,只有对表中不存在的<br>index赋值时才会调用元表的__newindex方法.</li></ol><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="ENV-lua5-2"><a href="#ENV-lua5-2" class="headerlink" title="_ENV(lua5.2)"></a>_ENV(lua5.2)</h2><p>lua将每一个chunk转换为一个匿名函数, 匿名函数中的自由变量(也就是全局变量)会转 变为对表_ENV的引用,比如:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">var1 = var2 + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>很显然var1, var2是全局变量, 那么这个chunk实际会转换为这个样子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">_ENV</span> = <span class="hljs-built_in">_G</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span><br>   <span class="hljs-built_in">_ENV</span>.var1 = <span class="hljs-built_in">_ENV</span>.var2 + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>从上面的代码你可以看到, 全局变量的访问与赋值实际就是对_ENV表的相应key的访问与 修改,<br>这个_ENV实际就是为了实现静态作用域而必须和函数绑定到一起的环境,<br>如果没有 这个环境那么自由变量就只能在动态执行过程中决定,这就成了动态作用域, 默认情 况_ENV是被赋值为_G,<br>但是你可以修改_ENV, 同时匿名函数中的自由变量还有一个名字 叫 <strong>上值(upvalues)</strong>,<br>很显然var1, var2就是上值</p><h2 id="setfenv-x2F-getfenv"><a href="#setfenv-x2F-getfenv" class="headerlink" title="setfenv&#x2F;getfenv"></a>setfenv&#x2F;getfenv</h2><p>__ENV机制是lua5.2引入的, 在luajit中也没有实现, setfenv实际上也可以设置函数的 环境,<br>第一个参数是一个函数,也可以是数字,它代表当前栈上的函数,比如说1就代表目<br>前正在执行的函数.</p><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><p>可以使用表来模拟OOP的行为.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua">Account = &#123;<br>   balance=<span class="hljs-number">0</span>,<br>   withdraw = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self, v)</span></span><br>      <span class="hljs-built_in">self</span>.balance = <span class="hljs-built_in">self</span>.balance - v<br>   <span class="hljs-keyword">end</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account:new</span> <span class="hljs-params">(o)</span></span><br>   o = o <span class="hljs-keyword">or</span> &#123;&#125;<br>   <span class="hljs-comment">-- create object if user does not provide one</span><br>   <span class="hljs-built_in">setmetatable</span>(o, <span class="hljs-built_in">self</span>)<br>   <span class="hljs-built_in">self</span>.<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span><br>   <span class="hljs-keyword">return</span> o<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account:deposit</span> <span class="hljs-params">(v)</span></span><br>   <span class="hljs-built_in">self</span>.balance = <span class="hljs-built_in">self</span>.balance + v<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 等价,冒号是语法糖，可以看做是自动添加self</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Account.deposit</span> <span class="hljs-params">(self, v)</span></span><br>   <span class="hljs-built_in">self</span>.balance = <span class="hljs-built_in">self</span>.balance + v<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在new中创建一个表o, 同时将o的metatable设为self(也就是Account), 同时设置 self的__index属性,<br>这样o中不存在的属性都会去Account表中找. 若是新对象没有指定<br>balance值,那么Account中的balance会新对象的默认值.<br>同时注意冒号是一个语法糖, 也 就是说 <code>o:deposite(100)=等价于 =o.deposite(o, 100)</code>,</p><h1 id="package"><a href="#package" class="headerlink" title="package"></a>package</h1><p>lua中比较好的package设施应该满足以下几点:</p><ol><li>不要因为漏写local而污染全局环境</li><li>不要在每一个api前添加包名前缀</li></ol><p>推荐的做法如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 将模块用到的全局变量赋值给local变量</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">print</span> = <span class="hljs-built_in">print</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">error</span> = <span class="hljs-built_in">error</span><br><span class="hljs-keyword">local</span> ngx = ngx<br><span class="hljs-keyword">local</span> <span class="hljs-built_in">setmetatable</span> = <span class="hljs-built_in">setmetatable</span><br><br><span class="hljs-keyword">local</span> _M = &#123;&#125;<br><span class="hljs-comment">-- 修改当前chunk的匿名函数的环境为_M, 这样该chunk的所有全局变量都会变成_M的元素</span><br><span class="hljs-comment">-- 这样可以避免漏掉local导致的函数变成全局函数的问题.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">setfenv</span> <span class="hljs-keyword">then</span>                 <span class="hljs-comment">-- for lua5.1 and luajit</span><br>   <span class="hljs-built_in">setfenv</span>(<span class="hljs-number">1</span>, _M)<br><span class="hljs-keyword">elseif</span> <span class="hljs-built_in">_ENV</span> <span class="hljs-keyword">then</span>                <span class="hljs-comment">-- for lua5.2 or newer</span><br>   <span class="hljs-built_in">_ENV</span> = _M<br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;both setfenv and _ENV are nil...&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- private function</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">afunc</span><span class="hljs-params">()</span></span><br>   dosomething<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- public method</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">new</span><span class="hljs-params">()</span></span><br>   do_something<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- safety set, 禁止添加新属性</span><br><span class="hljs-keyword">local</span> module_mt = &#123;<br>   <span class="hljs-built_in">__newindex</span> = (<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(table, key, val)</span></span><br>         <span class="hljs-built_in">error</span>(<span class="hljs-string">&#x27;Attempt to write to undeclared variable &quot;&#x27;</span> .. key .. <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>                <span class="hljs-keyword">end</span>),<br>&#125;<br><br><span class="hljs-built_in">setmetatable</span>(_M, module_mt)<br><br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><h1 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h1><ol><li>chunk: chunk是lua执行代码的最小单位,一个chunk必定是一个block, 你可以认为<br>chunk是最上层的block,一般来说一个文件中的所有lua代码是一个chunk, 在交互环<br>境下每一行(前提是这一行是一个完整的语句)都是一个chunk</li><li>list的下标从1开始</li><li>lua的不等于是 ~&#x3D;, 不是 !&#x3D;</li><li>lua没有++,–以及+&#x3D;, -&#x3D; 这样的操作符,所以老老实实的写i&#x3D;i+1</li><li>lua的字符串拼接是 .. ,不是+, 它会自动将数字转换为字符串</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java笔记</title>
    <link href="/notes/java/"/>
    <url>/notes/java/</url>
    
    <content type="html"><![CDATA[<h1 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h1><h2 id="run-program"><a href="#run-program" class="headerlink" title="run program"></a>run program</h2><ol><li><p>in Terminal</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs example">javac Welcome.java<br>java welcome<br></code></pre></td></tr></table></figure></li></ol><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><p>OOP编程范式最核心的三大概念：继承，封装，多态。</p><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>建议使用域名的逆序来命名包, 比如有一个域名: example.com, 那么你就可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.testcode<br></code></pre></td></tr></table></figure><p>来申明一个文件属于 com.example.testcode包, 同时该文件要放入<br>com&#x2F;example&#x2F;testcode&#x2F;目录中.使用IDE可以很轻松的做到这一点.</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>java的所有继承都是公有继承,使用 <code>extends</code> 关键字.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> salary)</span>&#123;<br>                <span class="hljs-built_in">this</span>.name = name;<br>                <span class="hljs-built_in">this</span>.salary = salary;<br>        &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.salary;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">raiseSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> byPercent)</span>&#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">raise</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.salary * byPercent /<span class="hljs-number">100</span>;<br>                <span class="hljs-built_in">this</span>.salary += raise;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> salary)</span>&#123;<br>                <span class="hljs-built_in">super</span>(name, salary); <span class="hljs-comment">// super调用父类的构造方法</span><br>                <span class="hljs-built_in">this</span>.bonus = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">baseSalary</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.getSalary(); <span class="hljs-comment">// super调用父类的普通方法</span><br>                <span class="hljs-keyword">return</span> baseSalary + <span class="hljs-built_in">this</span>.bonus;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBonus</span><span class="hljs-params">(<span class="hljs-type">double</span> bonus)</span>&#123;<br>                <span class="hljs-built_in">this</span>.bonus = bonus;<br>        &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> bonus;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在类的方法中可以直接访问该类的所有实例的私有属性,所以在Employee的equals方法 中可以直接使用<br><code>other.name</code>,但是在子类的方法中不能直接访问父类的私有成员,所 以上例中 Manager 类中的<br><code>etSalary</code> 方法不能直接 <code>this.salary</code> 而必须用父类 的公有方法即 <code>super.getSalary()</code>,<br>Manager 中的构造函数也是同样的道理.super 有两个作用:一个是调用父类的方法,一个是调用父类的构造方法</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol><li><p>子类变量可以直接赋给父类变量,这样父类变量调用方法时会使用动态绑定,比如 如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(...);<br>e.getSalary();<br></code></pre></td></tr></table></figure><p>上面的getSalary调用的是 Manager的方法,而不是Employee的方法.这实际就是所 谓的 <strong>多态</strong>,<br>也就是说相同的编译时类型调用相同的方法可能呈现出不同的行为.这<br>里需要注意的是e只能调用Employee类拥有的方法，虽然这里的e是一个Manager实<br>例，但是它不能调用 <code>setBonus</code> 方法，如果你调用那么编译器会报错，这好理解， 因为编译时，e是一个Employee类型的变量.<br>而Employee类型很显然没有 <code>setBonus</code> 方法。</p></li><li><p>父类变量要赋给子类变量,则必须使用强制转化, 比如类 Manager 是 Employee 的子类, 那么:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(...);<br><span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> Manager)&#123;<br>    <span class="hljs-type">Manager</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (Manager) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般情况下使用 instanceof 来检查下会更保险.</p></li></ol><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object是所有类的超类,该类有有一些方法建议每一个类都重载:</p><ol><li><p>equals方法: 用来检测一个对象是否等于另一个对象,下面是一个推荐的实现方 式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br>    ....<br>    <span class="hljs-keyword">public</span> bool <span class="hljs-title function_">equals</span><span class="hljs-params">(Object otherObject)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == otherObject) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(otherObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(getClass() != otherObject.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Employee) otherObject;<br>        <span class="hljs-keyword">return</span> name.equals(other.name)<br>            &amp;&amp; salary == other.salary;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;<br>    ...<br>    <span class="hljs-keyword">public</span> bool <span class="hljs-title function_">equals</span><span class="hljs-params">(Object otherObject)</span>&#123;<br>        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">super</span>.equals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">Manager</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Manager) otherObject;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.bonus == other.bonus;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上所有的 <code>equals</code> 都可以用这种模式来定义, 但是对于子类, 比如manager<br>类就只需要调用父类的equals方法,然后在加入一些特定于Manager类的检测就好</p></li><li><p>toString方法: 用来返回类实例的字符串表示.该方法调试时非常方便</p></li><li><p>hashCode方法: 获取一个类实例的散列值</p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类不能实例化,它主要是用来被其它类继承的,实际上起的是一个占位的角色,大多<br>数时候,抽象类只会包含一系列的抽象方法,但是抽象类是可以包含实例域与普通的类<br>方法的,下面的代码展示了抽象类的用法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上一般抽象类主要用来作为创建其它类的模板。</p><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射(Reflection)"></a>反射(Reflection)</h2><p>虚拟机为每一个类型都维护了一个Class对象, 要获得Class对象有以下几种方法:</p><ol><li><p>如果T是任意的java类型(必须是类型不能是类实例),那么 T.class 就是Class对象. 比如<br>Employee.class就是上例中 Employee的Class对象, int.class就是int的 Class对象.</p></li><li><p>使用 getClass实例方法, 如果e 是一个Employee实例, 那么 e.getClass()就会返<br>回Employee类型的Class对象.</p></li><li><p>如果知道类的字符串表示, 那么可以使用 forName来获得Class 对象, 比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.util.Date&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><p>获得Class对象后, 就可以来获取类型的信息了.</p><ol><li><p>newInstance 获取一个新的实例,注意返回的是Object类型, 所以你需要进行类型 转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.util.Date&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cl.newInstance();<br><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Date) m;<br></code></pre></td></tr></table></figure></li></ol><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><ol><li><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">CompareTo</span><span class="hljs-params">(T otherObject)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>interface中的方法自动为public.</p></li><li><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Employee&gt;&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Employee other)</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想使用Arrays中的sort方法,那么应该实现 <code>Comparable</code> 接口.</p></li><li><p>接口的特性:接口不可以被实例化,但是可以申明变量,而且可以将实现了该接口的 类的实例赋给该变量, 而且可以使用 <code>instanceof</code><br>来测试一个实例所属的类是否 实现了该接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparable</span>();            <span class="hljs-comment">// 错误语法</span><br><br>Comparable x;<br><span class="hljs-type">Comparable</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(...)           <span class="hljs-comment">// Employee类实现了Comparable接口</span><br></code></pre></td></tr></table></figure></li><li><p>接口类型的变量只能调用接口中定义的方法，这和多态的情况是一样的，因为只有 这样才能通过编译时检查.</p></li></ol><h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><ol><li>java提供了八种基本类型(byte,short,int,long,char,boolean,float,double)这些类型<br>不是对象，但是java提供了包装对象，并且在适当的地方会自动的装箱和拆箱<br>(boxing,unboxing).java中所有的对象类型都是引用类型</li><li>=&#x3D;与equals： 前者在基本类型为数值并且值相等时有效，对引用类型只有两个引用指向 同一个对象时才相等。</li></ol><h1 id="exception-异常"><a href="#exception-异常" class="headerlink" title="exception(异常)"></a>exception(异常)</h1><p><img src="/static/img/exceptions.png"></p><p>所有的异常都是从 Throwable继承而来的,而且在下一层就立即分为2类: Error与 Exception,<br>Error是java运行时系统的内部错误, 这类错误程序员无能为力,只能让程<br>序尽可能安全的终止.Exception又分为两类: RuntimeException 与<br>IOException, RuntimeException主要有以下几种情况:</p><ol><li>错误的类型转换 (可以通过转换前使用instanceof检测类型来避免)</li><li>数组访问越界</li><li>访问空指针</li></ol><p>这些异常都是程序应该避免的,是程序设计者的失误导致的, 发生了这类异常那就意味<br>着程序不正确,应该花时间来修复而不是寄希望于catch来处理这些异常.</p><p>IOException是所有不属于RuntimeException的异常,这类异常应该通过try catch 这类 设施进行处理.<br>一个类方法如果要抛出异常,那么必须在定义的行显式的声明,比如下面 的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAnimation</span>&#123;<br>    ...<br>    <span class="hljs-keyword">public</span> Image <span class="hljs-title function_">loadImage</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> EOFException, MalformatURLException&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>loadImage有可能抛出两个异常,如果一个方法没有声明 throws语句,那么就不能抛出异<br>常.如果是重载父类的方法,那么该方法的throws申明必须和父类的方法一模一样,异常<br>处理的基本代码是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">catch</span>(MakformatURLException e)&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">catch</span>(IOException e)&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>多个catch可以捕获多种类型的异常, finally块的语句是无论如何都会执行的,所以可 以用来清理资源</p><h2 id="异常使用的建议"><a href="#异常使用的建议" class="headerlink" title="异常使用的建议"></a>异常使用的建议</h2><ol><li>如果一个方法中调用了一个能够抛出异常的方法,那么这时候有两个选择,一是如果 目前能够处理该异常, 那么就使用try<br>catch来捕获该异常.二是将该异常传递给该 方法的调用者, 那么你就应该在方法头上添加对应的<br>throws语句.如果是在重载父 类的方法,而父类的方法上没有该异常的 throws语句,那么你就必须在本方法中使 用 try<br>catch来捕获这个异常.</li><li>异常处理不能代替简单的测试,测试更高效</li><li>不要过分细分异常,比如不要一条语句一个 try catch,只要将逻辑上的多个语句包 进一个try catch就好</li><li>尽量使用异常来代替一些特殊的返回值,所以stack.pop()不要返回一个null,而应<br>该生成一个EmptyStackException异常.</li></ol><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ol><li>获得logger, 主要是使用 Logger类的 getLogger工厂方法, 该方法只有在logger 不存在时才创建</li><li>设置logger的level, 使用logger的setLevel方法,level有以下几种(优先级由高到 低):<ul><li>SEVERE</li><li>WARNING</li><li>INFO (默认)</li><li>CONFIG</li><li>FINE</li><li>FINER<br>上面的都是Level类的静态常量,logging只会记录优先级高于等于当前设置的level 的日志,比如默认的日志级别是 INFO,<br>那么就只会记录 SEVERE, WARNING, INFO三 个级别的日志,还有两个特殊的常量:Level.ON,<br>Level.OFF,前者会记录所有级别的 日志,后者不记录任何级别的日志</li></ul></li><li>Handler:确定日志都存储到什么地方,一个logger实例可以有多个handler,每个<br>handler也有自己的level,只有日志级别高于等于handler的level时,handler才会处<br>理<ul><li>ConsoleHandler: 直接控制台打印</li><li>FileHandler: 文件存储</li><li>SocketHandler: 写入socket, 比如日志服务器</li></ul></li><li>Filter:</li><li>Format: 默认logging可以将日志记录为文本与 xml, 如果你想记录为其它格式,可 以自定义 Format类, 同时<br>使用handler的 setFormator来安装.</li><li>记录日志,每一个level都有一个对应的方法来记录相应级别的日志,比如 <code>logger.severe</code>,<br><code>logger.warning</code> 等等, 同时还有一个 <code>logger.log</code> 方法,这 个方法需要你显式的指定日志级别.</li></ol><!-- end list --><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;com.mycompany.myapp&quot;</span>);<br>logger.setLevel(Level.FINE);<br>logger.setUseParentHandler(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 防止日志送入 父logger,因为这样会重复</span><br><span class="hljs-type">Handler</span> <span class="hljs-variable">hd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleHandler</span>();<br>hd.setLevel(Level.Fine);<br>logger.addHandler(hd);<br></code></pre></td></tr></table></figure><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol><li><p>将logger 命名为与主应用程序包一样的名字.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;com.mycompany.myproj&quot;</span>);<br></code></pre></td></tr></table></figure><p>同时为了方便可以将logger添加进类的静态域中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">Logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-string">&quot;com.mycompany.myproj&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h1 id="java标准库"><a href="#java标准库" class="headerlink" title="java标准库"></a>java标准库</h1></li></ol><h2 id="java-lang-默认导入"><a href="#java-lang-默认导入" class="headerlink" title="java.lang(默认导入)"></a>java.lang(默认导入)</h2><h3 id="java-lang-String-字符串"><a href="#java-lang-String-字符串" class="headerlink" title="java.lang.String(字符串)"></a>java.lang.String(字符串)</h3><p>字符串是不可变的.所以修改会返回一个新的字符串</p><ul><li><ul><li>可以拼接字符串</li></ul></li><li><p>equals: 检测两个字符串是否相等, <strong>不能用&#x3D;&#x3D;</strong>.</p></li><li><p>String toLowerCase()</p></li><li><p>String toUpperCase()</p></li><li><p>String trim()</p></li><li><p>int length()</p></li><li><p>boolean startsWith(String prefix)</p></li><li><p>String substring(int start [, int end]) 不包含end指向的字符</p></li><li><p>String replace</p></li><li><p>format: 静态方法</p></li></ul><!-- end list --><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaaa&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1 + <span class="hljs-string">&quot;bbbb&quot;</span>;        <span class="hljs-comment">// s2 = &quot;aaaabbbb&quot;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s2.length();    <span class="hljs-comment">// len = 8</span><br><span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> s2.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// newStr = &quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><h3 id="java-lang-StringBuilder"><a href="#java-lang-StringBuilder" class="headerlink" title="java.lang.StringBuilder"></a>java.lang.StringBuilder</h3><p>该类表示的字符串可变,主要是为了效率考虑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuider</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuider</span>();<br>builder.append(<span class="hljs-string">&quot;hello&quot;</span>);<br>builder.append(<span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">completeString</span> <span class="hljs-operator">=</span> builder.toString();<br></code></pre></td></tr></table></figure><h3 id="java-lang-Math"><a href="#java-lang-Math" class="headerlink" title="java.lang.Math"></a>java.lang.Math</h3><p>各种数学函数以及变量, 都是静态函数以及变量</p><ul><li>Math.PI: 圆周率</li><li>Math.E: 自然对数</li><li>Math.sin, Math.cos, Math.floor etc</li></ul><h3 id="java-lang-System"><a href="#java-lang-System" class="headerlink" title="java.lang.System"></a>java.lang.System</h3><h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><h3 id="java-util-Date-Time"><a href="#java-util-Date-Time" class="headerlink" title="java.util.Date(Time)"></a>java.util.Date(Time)</h3><h3 id="java-util-GregorianCalendar-日历"><a href="#java-util-GregorianCalendar-日历" class="headerlink" title="java.util.GregorianCalendar(日历)"></a>java.util.GregorianCalendar(日历)</h3><h3 id="java-util-ArrayList"><a href="#java-util-ArrayList" class="headerlink" title="java.util.ArrayList"></a>java.util.ArrayList</h3><h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><p>java的集合大体上分为Set，List，Map三类。集合类型的元素必须是引用类型，而不能是基 本类型，但是一般java会自动装箱</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust笔记</title>
    <link href="/notes/rust/"/>
    <url>/notes/rust/</url>
    
    <content type="html"><![CDATA[<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>String, Array和Vector都可以使用 &amp;v[1..4]这样的语法获得slice,字符串的slice的类型是&amp;str， 其它类型的slice是&amp;[T], 只是名字不同，内部都是一个指针加上长度。</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ss</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">ss_slice</span> = &amp;ss[<span class="hljs-number">1</span>..];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ss_slice</span> = &amp;ss_slice[<span class="hljs-number">1</span>..] <span class="hljs-comment">// 等价于 &amp;ss[2..]</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr_slice</span> = &amp;arr[<span class="hljs-number">1</span>..];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v_slice</span> = &amp;v[<span class="hljs-number">1</span>..];<br><br><span class="hljs-comment">// 这里会隐式调用arr.into_iter(), 所以val是值，并且会获得所有权</span><br><span class="hljs-comment">// 如果要val为引用，那么必须显式的指定arr.iter()或者arr.iter_mut()</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> arr &#123;<br><br>&#125;<br><span class="hljs-comment">// 默认也会调用arr_slice.into_iter(), 但是这里val是引用(&amp;T), 这是slice的into_iter的正常行为。当然这里也可以明确使用iter()来返回引用。</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> arr_slice &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：&amp;str不能使用for in 遍历，它没有实现Iterator。可以先调用as_bytes转换成&amp;[u8]</p><h2 id="dot-operator"><a href="#dot-operator" class="headerlink" title="dot operator"></a>dot operator</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ref_s</span> = &amp;&amp;s;  <br>l = ref_s.<span class="hljs-title function_ invoke__">len</span>(); <span class="hljs-comment">// 等价于 (***ref_s).len()</span><br></code></pre></td></tr></table></figure><p>在进行方法调用时，不管是多少层都引用会被编译器还原成对应的值，然后根据参数定义(self, &amp;self, &amp;mut self)决定是传值还是传引用。</p><h2 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h2><p>Deref主要是为了智能指针引入的trait，它的行为都是为了服务智能指针，如果不是智能指针不建议实现Deref，除了常见Box，Rc外，String，Vector等都是实现了Deref的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target;<br>&#125;<br></code></pre></td></tr></table></figure><p>If <code>T</code> implements <code>Deref&lt;Target = U&gt;</code>, and x is a value of type <code>T</code>, then:</p><ol><li>In immutable contexts, <code>*x</code> (where <code>T</code> is neither a reference nor a raw pointer) is equivalent to <code>*Deref::deref(&amp;x)</code>.</li><li>Values of type <code>&amp;T</code> are coerced to values of type <code>&amp;U</code></li><li><code>T</code> implicitly implements all the (immutable) methods of the type <code>U</code>.</li></ol><p>在需要&amp;str, &amp;[T]的地方之所以能直接传String，Array，Vector的引用就是因为它们实现了Deref，所以根据规则2，它的类型会自动转换</p><h2 id="AsRef"><a href="#AsRef" class="headerlink" title="AsRef"></a>AsRef</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    email: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-comment">// obviously</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">AsRef</span>&lt;User&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">as_ref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;User &#123;<br>        <span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Privilege</span> &#123;<br>    <span class="hljs-comment">// imagine different moderator privileges here</span><br>&#125;<br><br><span class="hljs-meta">#[derive(Default)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Moderator</span> &#123;<br>    user: User,<br>    privileges: <span class="hljs-type">Vec</span>&lt;Privilege&gt;,<br>&#125;<br><br><span class="hljs-comment">// since moderators are just regular users</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">AsRef</span>&lt;User&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Moderator</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">as_ref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;User &#123;<br>        &amp;<span class="hljs-keyword">self</span>.user<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_user</span>&lt;U: <span class="hljs-built_in">AsRef</span>&lt;User&gt;&gt;(user: U) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user</span> = user.<span class="hljs-title function_ invoke__">as_ref</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user</span> = User::<span class="hljs-title function_ invoke__">default</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">moderator</span> = Moderator::<span class="hljs-title function_ invoke__">default</span>();<br>    <br>    <span class="hljs-title function_ invoke__">takes_user</span>(&amp;user);<br>    <span class="hljs-title function_ invoke__">takes_user</span>(&amp;moderator); <span class="hljs-comment">// yay</span><br>&#125;<br></code></pre></td></tr></table></figure><p>takes_user能接受User对象以及Moderator对象，因为它们都实现了AsRef，并且返回了&amp;User, 而takes_user的参数类型是AsRef<User>.</p><h2 id="impl-Trait-vs-dyn-Trait"><a href="#impl-Trait-vs-dyn-Trait" class="headerlink" title="impl Trait vs dyn Trait"></a>impl Trait vs dyn Trait</h2><p><a href="https://www.ncameron.org/blog/dyn-trait-and-impl-trait-in-rust/">https://www.ncameron.org/blog/dyn-trait-and-impl-trait-in-rust/</a></p><p>简单点说，<code>impl Trait</code> 在编译时就确定了具体类型, 它会像泛型参数一样展开生成具体类型的函数副本(单态化)，所以基本没有多余开销（静态分发），但是<code>dyn Trait</code> 则不然, 内部实际上是用一个虚拟表来dispatch 函数调用(动态分发）。也就是说一个变量对应多种类型。</p><p>优缺点：</p><ol><li>impl Trait只能存在于函数的签名中，其它地方不能使用，比如你不能用这种语句定义变量：<code>let v: impl T;</code></li><li>dyn Trait只能使用<code>&amp;dyn trait</code>或者 <code>Box&lt;dyn trait&gt;</code>这种形式。</li><li>impl Trait可以使用多个Trait，比如 <code>impl T1+T2</code> 但是dyn Trait不行</li><li>dyn Trait 可以在一个变量中存储多个不同的具体类型，比如一个函数返回 dyn Trait, 那么函数体可以返回多个不同的具体类型，而impl Trait则只能返回相同的具体类型。这主要是因为impl Trait是要展开成具体类型的。</li><li>要使用 dyn Trait， 那对应的trait必须是对象安全的(object safe), object safe的条件如下<ol><li>trait的方法不能返回Self类型</li><li>trait不能有泛型参数</li></ol></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-keyword">Self</span>&gt;;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Foo</span> &#123; ... &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Baz</span> &#123; ... &#125;<br><br><span class="hljs-comment">// 1. 作为函数参数</span><br><span class="hljs-comment">// 作为函数参数，impl Trait实际就是泛型参数，所以下面两个是等价的</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(b1: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Bar</span>, b2: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Bar</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>&lt;B1: Bar, B2: Bar&gt;(b1: B1, b2: B2) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(b: &amp;<span class="hljs-keyword">dyn</span> Bar) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span><br><br><span class="hljs-comment">// 2. 作为函数返回值</span><br><span class="hljs-comment">// T的类型由f的调用者指定，也就是说调用者知道T的具体类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>&lt;T: Bar&gt;(...) <span class="hljs-punctuation">-&gt;</span> T<br><br><span class="hljs-comment">// impl T 的具体类型由f的函数体推导出来, f的调用者不知道 impl T的具体类型。</span><br><span class="hljs-comment">// 注意f不能返回不同的具体类型, 比如body中有if语句，那么两个分支返回的具体类型必须一样。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(...) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">T</span><br><br><span class="hljs-comment">// 可以返回不同的具体类型。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(...) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Bar&gt;<br></code></pre></td></tr></table></figure><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Box::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>)]);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rc</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>)]);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rf</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>)]);<br><br>    <span class="hljs-comment">// Box只能有一个所有者, 也就是说对于一个指向的数据只能有一个Box有效</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b1</span> = b; <span class="hljs-comment">// 此行以后b就无效了</span><br><br>    <span class="hljs-comment">// Rc可以有多个所有者, 内部有引用计数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rc1</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;rc); <span class="hljs-comment">// rc和rc1都是有效的.</span><br><br>    <span class="hljs-comment">// RefCell可以在不可变的上下文进行修改, 比如要修改对象的某个属性，但是只能获得&amp;self, 无法获得&amp;mut self，那么就可以把对应的属性定义成RefCell.</span><br>    <span class="hljs-comment">// 注意：只能获得1个可变引用或者无限多个不可变引用，规则是一样的，只是这里是运行时检查。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rf1</span> = rf.<span class="hljs-title function_ invoke__">borrow</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rf1_mut</span> = rf.<span class="hljs-title function_ invoke__">borrow_mut</span>(); <span class="hljs-comment">// rf1和rf1_mut不能同时存在</span><br>&#125;<br></code></pre></td></tr></table></figure><p>标准库中实现了智能指针的类型：</p><ol><li>Box<T></li><li>Vec<T>, String</li><li>Rc<T>, Arc<T></li><li>Cell<T>, RefCell<T></li><li>RwLock, Mutex</li></ol><p>RefCell, RwLock, Mutex都实现了内部可变性。</p><h2 id="ref关键字"><a href="#ref关键字" class="headerlink" title="ref关键字"></a>ref关键字</h2><p>主要用于pattern match中，如果match后v的类型是T，那么用ref v去match,那么v的类型就是&amp;T。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;str1&quot;</span>), String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;str2&quot;</span>)];<br><span class="hljs-comment">// v的类型是&amp;String，注意这里v2中的元素的所有权仍然会转移出去,</span><br><span class="hljs-comment">// 你可以认为v2中的元素变成了一个个匿名对象，而v指向匿名对象的引用。</span><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">ref</span> v <span class="hljs-keyword">in</span> v2 &#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, v);<br>&#125;<br><span class="hljs-comment">// v的类型是&amp;&amp;String.</span><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">ref</span> v <span class="hljs-keyword">in</span> v2.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, v);<br>&#125;<br><span class="hljs-comment">// v的类型是String，但是这里很多时候是非法，因为如果里面的元素没实现Copy Trait，那么这里就有编译错误。</span><br><span class="hljs-keyword">for</span> &amp;v <span class="hljs-keyword">in</span> v2.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生命周期规则"><a href="#生命周期规则" class="headerlink" title="生命周期规则"></a>生命周期规则</h2><p>第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo&lt;’a&gt;(x: &amp;’a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo&lt;’a, ‘b&gt;(x: &amp;’a i32, y: &amp;’b i32)，依此类推。</p><p>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo&lt;’a&gt;(x: &amp;’a i32) -&gt; &amp;’a i32。</p><p>第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 &amp;self 或 &amp;mut self，说明是个对象的方法(method)(译者注： 这里涉及rust的面向对象参见17章), 那么所有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp笔记</title>
    <link href="/notes/cpp/"/>
    <url>/notes/cpp/</url>
    
    <content type="html"><![CDATA[<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>默认构造函数只有当你没有定义构造函数的时候才会自动生成，一旦你一提供了构造函数， 那么你也应该提供默认的构造函数。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol><li>如果所有的类成员都是public的，那么使用struct，否则使用class。</li><li>仿函数(重载 operate())使用struct。</li></ol><h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><h3 id="concepts"><a href="#concepts" class="headerlink" title="concepts"></a>concepts</h3><ol><li>直接初始化：</li><li>拷贝初始化：一般使用等号的都是拷贝初始化。而且在下列场景也会有拷贝初始化<ul><li>将一个对象作为实参传递给非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>标准库容器初始化或者调用insert或push时。<br>拷贝初始化是使用拷贝构造函数实现的。</li></ul></li></ol><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs example">class_name ( const class_name &amp; ) &#123;...&#125;       (1)<br>class_name ( const class_name &amp; ) = default;  (2)<br>class_name ( const class_name &amp; ) = delete;   (3)<br></code></pre></td></tr></table></figure><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><h3 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h3><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数包含一个函数体和一个析构部分，首先执行函数体，接着就销毁所有的成员，成员 按初始化顺序的逆序销毁。 <strong>析构部分是隐式的</strong>.</p><p>不要在函数体中销毁成员, 因为这是析构部分的任务，有一个例外是指针成员，析构部分不<br>会对指针调用delete，所以你可能需要在析构函数体中delete。智能指针实际上是类，它有<br>析构函数，所以析构部分可以很好的处理他，在函数体中你不用操心。</p><p>调用析构函数的场景：</p><ol><li>变量离开作用域被销毁</li><li>当一个对象被销毁时，其成员也会被销毁</li><li>容器被销毁或者调用erase，clear，之类的函数删除元素时，被删除的元素都会被析构</li><li>对指针进行delete，那么它指向的对象会被析构。</li></ol><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><h1 id="Code-Style"><a href="#Code-Style" class="headerlink" title="Code Style"></a>Code Style</h1><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ol><li><strong>类型命名</strong> (类，结构体，枚举)使用驼峰命名,每个单词首字母均大写, 不包含下划线</li><li><strong>变量名</strong> 一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用</li><li><strong>常量命名</strong> 驼峰命名，在前面加 k 前缀， eg: <code>kDaysInAWeek</code>.</li><li><strong>函数命名</strong> 常规函数使用驼峰命名，getter&#x2F;setter函数必须和类成员名字匹配， 如果 类有一个 <code>field_</code><br>的成员，那么getter和setter分别为： <code>field()</code> 和 <code>set_field</code>.</li><li>namespace用小写字母命名, 并基于项目名称和目录结构</li></ol><h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><h2 id="Mix-C-and-C"><a href="#Mix-C-and-C" class="headerlink" title="Mix C and C++"></a>Mix C and C++</h2><p>主要是通过 <code>extern &quot;C&quot;</code> 来实现，他主要是用来抑制C++的名称混淆(name mangle)的。</p><ol><li><p>c调用C++的库：常规的做法时是提供一个wrapper，你应该在C++中提供一个头文件 (c_api.h),<br>这个头文件要严格按照C的语法编写，同时在需要C调用的函数前应该添加上 <code>extern &quot;C&quot;</code>, 因为这个头文件会同时被C编译器和C++编译器调用，所以需要如下的代 码：</p><div class="code-wrapper"><pre><code class="hljs">#ifdef __cplusplus#define EXTERN_C extern &quot;C&quot;#endif</code></pre></div><p>有了头文件，你接着需要在一个C++文件中(eg:c_api.cpp)实现头文件中定义的这些函数。 注意实现时是否加上 <code>extern &quot;C&quot;</code> 是可选的。</p></li><li><p>C++中调用C库： 你只需要通过 <code>extern &quot;C&quot; void c_func()</code> 来声明就好，接着你就可 以调用 <code>c_func</code><br>了。</p></li></ol><h2 id="Profile-x2F-Debug"><a href="#Profile-x2F-Debug" class="headerlink" title="Profile&#x2F;Debug"></a>Profile&#x2F;Debug</h2><h3 id="gperftools"><a href="#gperftools" class="headerlink" title="gperftools"></a>gperftools</h3><ol><li><p>install</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">sudo apt-get install google-perftools libgoogle-perftools-dev<br>go get github.com/google/pprof<br></code></pre></td></tr></table></figure></li><li><p>cpu profile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">LD_PRELOAD=/usr/lib/libprofiler.so CPUPROFILE=cpu_profile ./prog<br></code></pre></td></tr></table></figure></li><li><p>heap profile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">LD_PRELOAD=/usr/lib/libtcmalloc.so HEAPPROFILE=heap_profile ./cbmc<br></code></pre></td></tr></table></figure></li><li><p>visualization</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">pprof --gv cpu_profile cbmc<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记</title>
    <link href="/notes/python-note/"/>
    <url>/notes/python-note/</url>
    
    <content type="html"><![CDATA[<h1 id="python的编码规范"><a href="#python的编码规范" class="headerlink" title="python的编码规范"></a>python的编码规范</h1><ol><li>用4个空格缩进</li><li>每一行不超过80个字符,当一行超过80个字符时,可以用,当对一个二元操作符断行时,应该将操作符留在 上一行,<br>对于函数定义以及调用,那么根据括号来对齐.</li><li>模块内容的顺序：<ul><li>模块说明和docstring</li><li>import</li><li>__all_<sub>(optional)</sub></li><li>globals and constants</li><li>其他定义</li></ul></li><li>一行只导入一个模块(不推荐 import sys, os)</li><li>模块导入顺序: 标准库, 第三方库, 自己编写的库. 三者之间用空行分割, 而且三者应该紧挨着模块字符串的后面</li><li>模块级别的函数定义, 类定义用2个空行分割, 类方法用一个空行分割</li><li>空格的添加:<ul><li><p>二元操作的两边各放一个空格, 但是对于有多个操作符的情况,可以只在低优先级 的操作符两边放空格</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs python">i = i + <span class="hljs-number">1</span><br>submitted += <span class="hljs-number">1</span><br>x = x*<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>hypot2 = x*x + y*y<br>c = (a+b) * (a-b)<br></code></pre></td></tr></table></figure></li><li><p>标点符号的后面放空格,前面不要放空格,在(, {, [之后以及), }, ]之前不要放空格,函数调用时函数名与左括号之间<br>不要放空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs example">Yes: spam(ham[1], &#123;eggs: 2&#125;)<br>No:  spam( ham[ 1 ], &#123; eggs: 2 &#125; )<br>No:  spam (ham[1], &#123;eggs:2&#125;)<br><br>Yes: if x == 4: print x, y; x, y = y, x<br>No:  if x == 4 : print x , y ; x , y = y , x<br><br>Yes: spam(1)<br>No:  spam (1)<br><br>Yes: dict[&#x27;key&#x27;] = list[index]<br>No:  dict [&#x27;key&#x27;] = list [index]<br></code></pre></td></tr></table></figure></li><li><p>不要在用于指定关键字参数 (keyword argument) 或默认参数值的 ‘&#x3D;’ 号周围使用空格。</p></li></ul></li><li>命名<ul><li>模块名与包名: 全部用小写字母, 模块名可以添加下划线来增加可读性, 包名不建议添加下划线,名字尽量短一点,因<br>为有些文件系统对文件长度有要求</li><li>类名: 使用驼峰命名法,如果是内部类,则在前面加一个下划线</li><li>异常名: 异常是类, 所以使用驼峰命名法,但是必须有Error后缀</li><li>函数名: 必须是小写字母, 用下划线去增加可读性</li><li>类方法: 和函数名相同, 对于non-public函数, 可以在前面加一个下划线, 前面加两个下划线主要是避免与子类命名<br>冲突(一般用户命名变量不推荐使用)</li><li>常量名: 全部大写, 用下划线分割增加可读性</li></ul></li></ol><h1 id="python-文件处理"><a href="#python-文件处理" class="headerlink" title="python 文件处理"></a>python 文件处理</h1><p>open打开文件时的选项：</p><ul><li><p>w, w+: 如果文件已存在，那么二者都会将文件内容清除</p></li><li><p>r+: 如果写文件，那么会从当前位置覆盖写，而不是插入，当用该模式打开文件，读 入文件内容，然后用覆盖该文件时应使用如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;r+&#x27;</span>) <span class="hljs-keyword">as</span>  f:<br>    content = f.read()<br>    new_content = do_something()<br>    f.seek(<span class="hljs-number">0</span>)<br>    f.write(new_content)<br>    f.truncate()                <span class="hljs-comment"># 删除当前读写位置到文件末尾的内容</span><br></code></pre></td></tr></table></figure></li><li><p>b: 在python2中，linux指定与不指定问题不大，但是建议对于二进制文件比如图片还<br>是指定该选项比较好，避免移植到windows出现问题，在python3中，对于文本文件，<br>如果不指定该选项，那么会返回unicode string， 而如果指定该选项则返回byte string,<br>所以对于二进制文件,你必须指定b</p></li></ul><p>遍历一个文件夹的所有文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path<br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> os.path <span class="hljs-keyword">import</span> join, getsize<br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(<span class="hljs-string">&#x27;python/Lib/email&#x27;</span>):<br>    <span class="hljs-keyword">for</span> afile <span class="hljs-keyword">in</span> files:<br>        full_name = os.path.join(root, afile)<br>        do_something(full_name)<br></code></pre></td></tr></table></figure><h1 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h1><ol><li>if, for, while等不会创建新的作用域, 也就是说它们不同于c中block structure.</li><li>每一个模块会创建一个模块作用域</li><li>每一个函数(包括嵌套定义的函数) 都创建一个函数作用域</li><li>在一个作用域内第一次赋值会创建一个新的 <strong>绑定</strong>, 以后对该变量的赋值都是对该 绑定的 <strong>修改</strong>.</li><li>在内层作用域可以引用外层作用域的变量, 但是你不能修改外层作用域的变量, 因为<br>你在在内层作用域一旦对该变量使用赋值,那么就是创建一个新的绑定,<br>所以为了改 变模块作用域中的变量你必须使用global来申明, 但是你永远也不能在内层函数中改<br>变外层函数的变量(当然你可以通过subscript或者attribute來修改可变对象的值,<br>只是这是引用的关系, 和作用域关系不大),这是python设计的不够好的地方.</li></ol><h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><ul><li>X&#x2F;Y: python2中的行为和C语言类似，3&#x2F;2&#x3D;1, 3&#x2F;2.0&#x3D;1.5;<br>在python3中，这是真除法，也就是会一直保留小数位,3&#x2F;2<br>&#x3D; 1.5</li><li>X&#x2F;<em>Y: 在python2以及3中都是floor除法，也就是取整数区间的左边边界，5&#x2F;&#x2F;2 &#x3D; 2, 5&#x2F;</em>-2 &#x3D; -3</li></ul><h2 id="一些内置函数的解释"><a href="#一些内置函数的解释" class="headerlink" title="一些内置函数的解释"></a>一些内置函数的解释</h2><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>获得对象的所有属性,也就是顶层的那些names</p><h2 id="globals-And-lolcals"><a href="#globals-And-lolcals" class="headerlink" title="globals And lolcals"></a>globals And lolcals</h2><ol><li><code>globals()</code>: 返回一个字典,字典包括当前模块(也就是调用 <code>globals()</code> 的模块) 的所有模块级属性, 同时还包括<br><code>__builtins__</code> 属性, 还包括几个特殊变量 <code>__file__, __package__, __doc__</code>.</li><li>locals(): 这个只返回局部空间(比如函数的局部变量)的变量与值的字典,注意这个字典不能修改,如果强行修改会引发<br>严重后果,比如解释器崩溃</li></ol><h2 id="getattr-getattr-getattribute"><a href="#getattr-getattr-getattribute" class="headerlink" title="getattr,__getattr__,__getattribute__"></a>getattr,__getattr__,__getattribute__</h2><ol><li><p><code>__getattr__</code> 只有在属性不存在时才调用,该方法用的多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, obj</span>):<br>        self.obj = obj<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-keyword">if</span> name.startswith(<span class="hljs-string">&quot;__&quot;</span>) <span class="hljs-keyword">and</span> name.endswith(<span class="hljs-string">&quot;__&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(ClassName, self).__getattr__(name)<br>        dosomething()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(ClassName, self).__getattr__(name)<br></code></pre></td></tr></table></figure><p><strong>在该函数中不要使用不存在的属性，因为这会导致循环递归</strong>, 该函数实现不正确很<br>容易导致copy，pickle之类的模块出现循环递归。因为copy，pickle之类的模块在创<br>建新对象的过程大体时这样的：</p><ol><li>调用 <code>__new__</code> 创建一个新对象</li><li>调用 <code>__setstate_</code> 来设置对象状态</li></ol><p>第一步并没有调用 <code>__init__</code>, 所以很多属性(比如obj)是不存在的，一旦你在 <code>__getattr__</code> 使用了<br><code>__init__</code> 中创建的属性，并且你又没有定义 <code>__setstate__</code> 的话，那么第二步就会导致循环递归。 避免循环递归的<br>方式有以下几种：</p><ol><li><p>是过滤掉 <code>__xxx__</code> 这样的属性,就像示例中那样。这样 <code>__setstate__</code> 之类的属性就被过滤掉了</p></li><li><p>定义 <code>__setstate__</code>, 这样第二步就不会进去 <code>__getattr__</code></p></li><li><p>在 <code>__getattr__</code> 的开头过滤掉你所使用的属性。 比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):<br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;obj&quot;</span>:<br>        <span class="hljs-keyword">raise</span> AttributeError()<br></code></pre></td></tr></table></figure></li></ol></li><li><p>__getattribute__是每一次obj.attr时都会调用,所以它可以拦截所有的属性查询, 用的很少</p></li><li><p>getattr: 原型getattr(object, name[, default]), getattr(x,<br>‘foobar’)等价于x.foobar优势就在于getattr可以<br>使用字符串,注意如果是获得类实例的方法,那么self参数就可以忽略了,只需要传入除self之外的其它参数就好</p></li></ol><h2 id="import-接字符串而不是name"><a href="#import-接字符串而不是name" class="headerlink" title="__import_(接字符串而不是name)"></a>__import_<sub>(接字符串而不是name)</sub></h2><p>原型： __import_<sub>(name[, globals[, locals[, fromlist[,<br>level]]]])</sub></p><ul><li>fromlist： 指定需要从name中导入的属性名，一般而言也就是from module1 import attr1,<br>attr2…中的 attr1,attr2… <strong>这个参数一般需要指定</strong></li><li>level: 指定使用绝对导入还是相对导入，-1是默认会同时尝试二者，0是绝对导入，正数是相当于加几个. ,比如如果<br>为1,那就是加一个.也就是当前目录，如果是2,那就是加两个点，在当前模块的父目录中导入，和import中的相<br>对导入语法类似</li></ul><!-- end list --><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># snippet 1</span><br><span class="hljs-keyword">from</span> spam.ham <span class="hljs-keyword">import</span> eggs, sausage <span class="hljs-keyword">as</span> saus<br><br><span class="hljs-comment"># snippet 2</span><br>_temp = <span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;spam.ham&#x27;</span>, <span class="hljs-built_in">globals</span>(), <span class="hljs-built_in">locals</span>(), [<span class="hljs-string">&#x27;eggs&#x27;</span>, <span class="hljs-string">&#x27;sausage&#x27;</span>], -<span class="hljs-number">1</span>)<br>eggs = _temp.eggs<br>saus = _temp.sausage<br></code></pre></td></tr></table></figure><p>两段代码等价, __import__接的是字符串</p><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器的基本形式"><a href="#装饰器的基本形式" class="headerlink" title="装饰器的基本形式"></a>装饰器的基本形式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_deco</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> _deco<br><br><span class="hljs-meta">@deco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面的@deco 等价于 myfunc &#x3D; deco(myfunc), 这就是装饰器的本质所在,<br>注意_deco必须与myfunc有相同的参数,因为 装饰后调用myfunc实际是调用_deco,<br>当然_deco可以使用*args, **kargs这样的可变参数</p><h2 id="使用类作为装饰器-推荐的做法"><a href="#使用类作为装饰器-推荐的做法" class="headerlink" title="使用类作为装饰器(推荐的做法)"></a>使用类作为装饰器(推荐的做法)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">deco</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br><br><span class="hljs-meta">@deco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>myfunc &#x3D; deco(myfunc) 所以myfunc就是一个deco类的实例，然后myfunc(*args,<br>**kwargs),实际就是调用类实例 的__call__方法</p><h2 id="使用类作为装饰器装饰类方法"><a href="#使用类作为装饰器装饰类方法" class="headerlink" title="使用类作为装饰器装饰类方法"></a>使用类作为装饰器装饰类方法</h2><p>下面的代码也可以装饰非类方法,也就是装饰普通函数,也就意味着下面的代码可以替代2,因为如果装饰的是普通函数,<br>那么会直接调用该函数,所以不会触发descriptor的__get__方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">deco</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>        self.func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, obj, objtype</span>):<br>        <span class="hljs-keyword">import</span> functools<br>        <span class="hljs-keyword">return</span> functools.partial(self.__call__, obj)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">    @deco</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>这与2最大的区别就是使用了descriptor，也就是__get__, 之所以这么写是因为，如果像2一样，那么就没有给myfunc<br>传递self参数，所以python会报缺少参数的错误，下面解释一下代码运行的流程，deco装饰后，myfunc变成一个deco的<br>类实例，注意deco定义了__get__,<br>所以myfunc就变成了一个descriptor对象，当你使用test_obj.myfunc(*args,<br>**kwargs)调用的时候，也就触发了test_obj.myfunc的属性搜索，那么根据descriptor的规则，就变成了<br>myfunc.__get_<sub>(test_obj)</sub>,该函数返回已将test_obj绑定到myfunc.<span class="underline"><span class="underline">call</span>_的第一个参数的partial<br>函数，接着这个 函数在接受*args,<br>**kwargs参数，总之就是通过descriptor将test_obj传递给了__call_</span>,从而消除了缺少self的问题</p><h2 id="给装饰器添加参数"><a href="#给装饰器添加参数" class="headerlink" title="给装饰器添加参数"></a>给装饰器添加参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">arg</span>):<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">_deco</span>(<span class="hljs-params">func</span>):<br>         <span class="hljs-keyword">def</span> <span class="hljs-title function_">__deco</span>():<br>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before %s called [%s].&quot;</span> % (func.__name__, arg))<br>             func()<br>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after %s called [%s].&quot;</span> % (func.__name__, arg))<br>         <span class="hljs-keyword">return</span> __deco<br>     <span class="hljs-keyword">return</span> _deco<br><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-string">&quot;mymodule&quot;</span></span>)</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-string">&quot;module2&quot;</span></span>)</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc2</span>():<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc2() called.&quot;</span>)<br>myfunc()<br> myfunc2()<br></code></pre></td></tr></table></figure><p>需要给装饰器加参数.那么就给多添加一个嵌套函数, 这个参数可以是类以及其它对象</p><h2 id="functools模块"><a href="#functools模块" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li><p>wraps: 这个装饰器可以确保函数在装饰后属性的一致,比如上面的例子 myfunc&#x3D;deco(myfunc), 那么此时<br>myfunc的__name__,<br>__doc__等属性都不在是原myfunc的值了,而是_deco的值,每一次装饰之后这些函数对象的元信<br>息都丢失的话,那么这显然是一个大问题,而wraps可以用来应付这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">     @functools.wraps(<span class="hljs-params">func</span>)</span><br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">_deco</span>():<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>         func()<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br>    <span class="hljs-keyword">return</span> _deco<br><span class="hljs-meta">@deco</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br></code></pre></td></tr></table></figure><p>@functools.wraps(func)这行代码可以保证,通过装饰器调用后,函数__name__,<br>__doc__仍然和原来的函数一致</p></li><li><p>partial: 有时候你知道一个函数的一部分参数,这个时候你可以先绑定这些参数,绑<br>定这些参数之后会返回一个partial对象,你可以当这个对象就是一个以绑定了一些参<br>数的函数,就是函数式语言中的curry,partial大体上等于以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">func, *args, **keywords</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">newfunc</span>(<span class="hljs-params">*fargs, **fkeywords</span>):<br>        newkeywords = keywords.copy()<br>        newkeywords.update(fkeywords)<br>        <span class="hljs-keyword">return</span> func(*(args + fargs), **newkeywords)<br>    newfunc.func = func<br>    newfunc.args = args<br>    newfunc.keywords = keywords<br>    <span class="hljs-keyword">return</span> newfunc<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="迭代器的基本知识"><a href="#迭代器的基本知识" class="headerlink" title="迭代器的基本知识"></a>迭代器的基本知识</h2><p>迭代器对象是序列对象的一般化,每一个迭代器对象都有一个next方法,该方法每调用一次都会返回下一个元素,当没有元素<br>可返回时要触发StopIteration异常,这就是迭代对象的实质了</p><h2 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h2><p>从大多数方面看生成器函数和普通函数一致,它们二者最大的不同时,普通函数是直接通过return返回一个值,而生成器函<br>数是通过yield返回一个迭代器对象,所以每一个生成器函数调用后都是返回一个迭代器对象,这是本质的区别</p><h2 id="for循环的迭代过程"><a href="#for循环的迭代过程" class="headerlink" title="for循环的迭代过程"></a>for循环的迭代过程</h2><p>for item in obj语句的执行过程其实是这样</p><ol><li>先运行iter(obj) 获得迭代器对象 iter_obj</li><li>重复的调用iter_obj.next() 直到出现StopIteration异常</li><li>如果上述两步已成功,那么for循环就结束了,如果上述两步没成功,这意味着obj不支持迭代协议,那么for就会尝试使用<br>下标来遍历那么会使用下标来遍历,也就是从0开始每一轮循环都对下标加一,而且每一轮循环都使用obj[i]<br>来访问元 素,直到触发异常</li></ol><h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><p>基本模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">with exp as name:<br>    body<br></code></pre></td></tr></table></figure><p>先对exp求值得到val，然后调用val的__enter__ 方法，最后将val绑定到name，接着运<br>行body，在要退出body时运行val的__exit__方法。File对象已经自带了这两个特殊方法，<br>所以打开文件时，with用的很多。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块的_X与__all__: 当调用from XX import * 时, 如果指定了__all__, 那么就只导<br>入__all__中的名字,如果没指定__all__,那么导入所有除了以下划线开头的全部模块级 名字, 也就是说不会导入<br>_X 这样的名字</p><h2 id="absolute-import"><a href="#absolute-import" class="headerlink" title="absolute import"></a>absolute import</h2><p>只导入 <code>sys.path</code> 指定的路径下的模块，一般来说sys.path的第一项就是 <strong>作为入口 被执行的脚本的所在的目录</strong>,<br>比如你在命令行执行 <code>python aa.py</code> 那么第一项就是 <code>aa.py</code> 所在的目录. 绝对导入的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> foo<br><span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">import</span> aaa <span class="hljs-comment"># xxx 不能以 . 开头</span><br></code></pre></td></tr></table></figure><p>上面的这种语法在Py2,py3中是不同的：</p><ul><li>py3： 是绝对导入，也就是说只搜索sys.path</li><li>py2: 行为比较混淆，它会同时搜索当前文件(包含import语句的文件，不是入口执行<br>文件)所在目录的模块，同时也会搜索sys.path,这很容易造成包内部的模块覆盖掉<br>sys.path的模块</li></ul><p><strong>为了兼容性，建议使用 from<br><span class="underline"><span class="underline">future</span></span><br>import absolute_import</strong> 来统一该语法的 行为。</p><h2 id="relative-import"><a href="#relative-import" class="headerlink" title="relative import"></a>relative import</h2><p>相对导入必须使用from xxx import yyy 的形式, 而且xxx必须以点号开头, import xxx 的形式都是绝对导入,<br>相对导入需要以下的语法:对于如下的一个目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs example">package/<br> __init__.py<br> subpackage1/<br>     __init__.py<br>     moduleX.py<br>     moduleY.py<br> subpackage2/<br>     __init__.py<br>     moduleZ.py<br> moduleA.py<br><br></code></pre></td></tr></table></figure><p>假设在moduleX.py or subpackage1&#x2F;__init__.py中，那么下列的相对导入是合法的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .moduleY <span class="hljs-keyword">import</span> spam<br><span class="hljs-keyword">from</span> .moduleY <span class="hljs-keyword">import</span> spam <span class="hljs-keyword">as</span> ham<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> moduleY<br><span class="hljs-keyword">from</span> ..subpackage1 <span class="hljs-keyword">import</span> moduleY<br><span class="hljs-keyword">from</span> ..subpackage2.moduleZ <span class="hljs-keyword">import</span> eggs<br><span class="hljs-keyword">from</span> ..moduleA <span class="hljs-keyword">import</span> foo<br><span class="hljs-keyword">from</span> ...package <span class="hljs-keyword">import</span> bar<br><span class="hljs-keyword">from</span> ...sys <span class="hljs-keyword">import</span> path<br></code></pre></td></tr></table></figure><p>一个点代表当前文件所在的目录，两个点代表当前文件所在目录的父目录，以此类推，<br>注意相对导入使用__name__属性实现的，所以对于执行模块必须小心，因为他的__name__属<br>性是__main__, 所以这些模块中不能使用相对导入</p><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="基本OOP代码示例"><a href="#基本OOP代码示例" class="headerlink" title="基本OOP代码示例"></a>基本OOP代码示例</h2><p>类,类的实例和模块都只是一个命名空间,命名空间的属性都可以修改,所以非常灵活,对于基于类的对象而言,可以使用dir内 置函数来查看命名空间,<br><strong>类与类的实例都是对象,二者都是使用字典对象实现的命名空间,二者的__dict__属性基本就是命名空间 字典</strong>, 看如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    a Test Class</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    val1 = <span class="hljs-number">1</span><br>    val2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, arg1, arg2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.arg1 = arg1<br>        self.arg2 = arg2<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span> self.arg1, self.arg2<br><br>obj1 = Test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">dir</span>(Test)<br><span class="hljs-built_in">print</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">dir</span>(obj1)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__doc__&#x27;, &#x27;__format__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__module__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;display&#x27;, &#x27;val1&#x27;, &#x27;val2&#x27;]<br></code></pre></td></tr></table></figure><p>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__doc__&#x27;, &#x27;__format__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__module__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;arg1&#x27;, &#x27;arg2&#x27;, &#x27;display&#x27;, &#x27;val1&#x27;, &#x27;val2&#x27;]<br></code></pre></td></tr></table></figure><p>val1, val2,<br><span class="underline"><span class="underline">init</span></span>,<br>display都是类Test本身的属性, 而arg1, arg2就是类实例(obj1)的属性,实际上self产生的就是 类实例对象的属性,<br>当然类的实例也会继承 类的属性</p><h2 id="属性搜索树"><a href="#属性搜索树" class="headerlink" title="属性搜索树"></a>属性搜索树</h2><p>当调用obj.attr时,python有一个属性的搜索过程,比如下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D2</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D3</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>(D1, D2):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span>(<span class="hljs-title class_ inherited__">D3</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(C1, C2):<br>    <span class="hljs-keyword">pass</span><br><br>a1 = B()<br>a2 = B()<br></code></pre></td></tr></table></figure><p>上面的代码会构成一颗属性搜索树:</p><p><img src="/static/img/attribute-search-tree.png"></p><p>因为类本身也是对象,所以类本身也有属性,类的属性就是类的方法,以及类的变量, 比如当调用a1.x时,那么搜索的过程就 是这样的: a1, B,<br>C1, D1, D2, C2, D3注意这是深度优先搜索,python的经典类与新式类都是这种搜索模式，但是新式类 有一个diamond<br>pattern，也就是钻石模式，这种模式下有一个以上的超类会通往相同的更高层次的超类，这时候会使用<br>广度优先搜索(只是有相同超类的那一部分)，举个例子：</p><p><img src="/static/img/diamond-pattern.png"></p><p>如上图所示，如果C2有个w属性，D2也有个w属性，那么当使用a1.w进行属性搜索时，如果使用深度优先搜索，那么会得到 D2.w，<br>但是C2是D2的子类，并且重载了w属性，这种情况下应该用子类的属性也就是C2的w属性，钻石继承就是为这种情<br>况准备的，在这种情况下，在C1,D2, C2会使用广度优先算法搜索，这样就可以先得到C2.w<br>.这个特例需要注意</p><h2 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h2><h3 id="is-a"><a href="#is-a" class="headerlink" title="is a"></a>is a</h3><p>如何现实中两个事物是is a的关系，那么就应该用继承，比如teacher is a person，那么Teacher就应该继承Person</p><h3 id="has-a"><a href="#has-a" class="headerlink" title="has a"></a>has a</h3><p>比如一个商店有商品，有营业员，有顾客，那么商店与商品，营业员，顾客就是has a的关系，这时候应该使用组合，也<br>就是说商店是一个容器，在该容器对象的构造函数中创建营业员对象，创建商品对象，创建顾客对象，具体到python就<br>是在__init__中创建这些对象</p><h2 id="常见的运算符重载"><a href="#常见的运算符重载" class="headerlink" title="常见的运算符重载"></a>常见的运算符重载</h2><ol><li><span class="underline"><span class="underline">getattr</span></span><br><span class="underline"><span class="underline">setattr</span>__使用obj.attr时如果该属性obj中没有attr属性，这时会调用__getattr_</span>,<br>__setattr___会 拦截所有的属性赋值，也就是obj.attr &#x3D;<br>val这样的语句都等价于obj.__setattr__<sub>(‘attr’,<br>val)</sub>，这是 和__getattr__不同的地方，要特别注意</li><li><span class="underline"><span class="underline">getitem</span></span><br><span class="underline"><span class="underline">setitem</span>_</span><br>当出现x[i], x[i] &#x3D; val, 会分别调用上述方法， 当使用for 迭代时会先尝试__iter__,<br>如果行不通，那么就使用索 引，也就是用不断递增的索引调用__getitem__,<br>直到出现IndexError</li><li><span class="underline"><span class="underline">iter</span></span><br>必须返回一个迭代器对象，一个拥有next方法的对象就是迭代器对象，如果使用for 在该对象上迭代，它会先使用<br>iter内置函数来调用__iter__<br>方法获得迭代器对象，然后重复的调用该迭代器对象的next方法，直到该next方法产生<br>StopIteration异常。</li><li><span class="underline"><span class="underline">call</span></span><br>将类实例作为函数调用时就是使用的该方法，比如obj是一个类实例，那么obj(‘a’, ‘b’)等价于<br>obj.__call_<sub>(‘a’,’b’)</sub>,这是一个很常用的方法</li></ol><h2 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h2><p>任何对象只要定义了__get__,<br><span class="underline"><span class="underline">set</span></span>,<br>__del__三者之一，那么就是descriptor，这<br>是一份不错的<a href="http://docs.python.org/2/howto/descriptor.html">tutorial</a>，<br>示例代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RevealAccess</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;A data descriptor that sets and returns values</span><br><span class="hljs-string">       normally and prints a message logging their access.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initval=<span class="hljs-literal">None</span>, name=<span class="hljs-string">&#x27;var&#x27;</span></span>):<br>        self.val = initval<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, obj, objtype</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Retrieving&#x27;</span>, self.name<br>        <span class="hljs-keyword">return</span> self.val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, obj, val</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Updating&#x27;</span> , self.name<br>        self.val = val<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    x = RevealAccess(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;var &quot;x&quot;&#x27;</span>)<br>    y = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs example">&gt;&gt;&gt; m = MyClass()<br>&gt;&gt;&gt; m.x<br>Retrieving var &quot;x&quot;<br>10<br>&gt;&gt;&gt; m.x = 20<br>Updating var &quot;x&quot;<br>&gt;&gt;&gt; m.x<br>Retrieving var &quot;x&quot;<br>20<br>&gt;&gt;&gt; m.y<br>5<br></code></pre></td></tr></table></figure><p>上例中 m.x<br>是一个descriptor，因为它是RevealAccess的类实例，而该类定义了__get__与__set__,所以<br>m.x 实际上等价 于 x.__get_<sub>(m)</sub></p><h1 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h1><p>在python中类也是对象，生成instance的叫class，生成class的就叫metaclass。type就是<br>python中内建的一个metaclass</p><h1 id="python异常"><a href="#python异常" class="headerlink" title="python异常"></a>python异常</h1><p>只说明基于类的异常, 老版的python中基于字符串的异常不考虑</p><h2 id="try-…-except语句"><a href="#try-…-except语句" class="headerlink" title="try … except语句"></a>try … except语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs example">try:<br>    main-block<br>except class1:<br>    handler1<br>except class2, instance:<br>    handler2<br>except (class3, class4):<br>    handler3<br>except (class5, class6), instance:<br>    handler4<br>except:<br>    handler5<br>else:<br>    else-block finally: finally-block<br></code></pre></td></tr></table></figure><p>python2.5以后版本才可以else,finally混在一起,执行try 中语句块时如果没有出现异常,那么就执行else 语句块,如果出<br>现了异常,那么就从上到下的匹配ecxept子句,最后执行第一个匹配的except 语句块, finally是无论是否发生异常,以及无<br>论是否捕捉了异常都会执行的</p><h2 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h2><p>raise语句的几种形式</p><ol><li>raise : 重新触发上一次产生的异常</li><li>raise instance : 触发为name的异常</li><li>raise class, instance : 和2类似,只是data是额外数据</li></ol><p><strong>上述的instance应该是一个异常类的实例</strong>,目前第二种最常用,为了兼容raise instance还有以下的几种衍生形式</p><ul><li>raise class : 等同于 raise class()</li><li>raise class, arg :等同于raise class(arg)</li><li>raise class, (arg1, arg2,…) : 等同于raise class(arg1, arg2,…)</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常都是类, exceptions must be old-style classes or derived from<br>BaseException.也就是说,要么是老式类,要么<br>是BaseException的子类,实践中用户自定义的类最好继承于Exception,并且必须以Error结尾,<br><strong>注意except语句是基于超 类匹配的</strong></p><h1 id="python中文处理"><a href="#python中文处理" class="headerlink" title="python中文处理"></a>python中文处理</h1><p>中文处理一直是一个比较棘手的问题,各种乱码一直让程序员苦不堪言,这里主要介绍 python中文处理的一般原则,<br>先介绍几个基本概念(强烈建议看看这篇<a href="http://nedbatchelder.com/text/unipain.html">文章</a>):</p><ol><li>unicode: 简单点说你可以将unicode看成一种映射,地球上的每一个符号都在unicode 中有一个数(准确的说叫code<br>point)与之对应</li><li>utf8, utf16: 刚刚说了地球上的每一个符号在unicode中有一个数与之对应,那么这 个数如何存储在计算机上呢?utf8,<br>utf16, utf32就是存储策略</li><li>big5, gb2312等: 这些都是各个地区自行发明的双字节码,也就是两个字节代表一个 符号</li></ol><p>python字符处理的基本概念:</p><ol><li>byte string: 字节流, utf8,utf16, gb2312等编码后得到的string都是字节流,通过<br>decode方法可以得到unicode string</li><li>unicode string: unicode字符串的每一个字符都是一个code point, 它可以通过<br>encode方法转换为各种byte string</li></ol><p>因此python中文处理的实质就是在byte string与unicode string之间来回转换, 因为<br>python解释器在解释python源文件时,也是需要编码信息的,所以在文件的前两行必须指<br>定编码信息(coding:utf8), <strong>指定的编码必须与python源文件保存时的编码一致</strong></p><p>python2与python3的区别:</p><ol><li><p>python2中字面字符串是byte string, 而3中是unicode string</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ss = <span class="hljs-string">&#x27;你好&#x27;</span>                     <span class="hljs-comment"># python2为byte string, python3为unicode string</span><br>ss = <span class="hljs-string">u&#x27;你好&#x27;</span>                    <span class="hljs-comment"># python2得到unicode string</span><br>ss = <span class="hljs-string">b&#x27;你好&#x27;</span>                    <span class="hljs-comment"># python3得到byte string</span><br></code></pre></td></tr></table></figure></li><li><p>对二者名称不同</p><table><thead><tr><th>category</th><th>python2</th><th>python3</th></tr></thead><tbody><tr><td>byte string</td><td>str</td><td>bytes</td></tr><tr><td>unicode string</td><td>unicode</td><td>str</td></tr></tbody></table></li><li><p>读取文件时,python2得到byte string, 而python3调用open时如果指定了b则得到 byte string,<br>如果没有指定b, 那么就会使用local.getpreferredencoding()返回的<br>编码方式来decode,然后得到unicode string.<br>python3中调用open时有一个可选参数 来指定解码方式..</p></li><li><p>混合时的处理方式不同,如一个byte string与一个unicode string相加,那么python2<br>会使用sys.getdefaultencoding()返回的编码方式来decode那个byte string, 然后<br>与unicode string相加得到一个unicode string,但是python3会返回异常因为<br>python3不允许二者混合.</p></li></ol><h1 id="一些很诡异的问题"><a href="#一些很诡异的问题" class="headerlink" title="一些很诡异的问题"></a>一些很诡异的问题</h1><h2 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">gg = <span class="hljs-literal">None</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">aa=&#123;&#125;</span>):<br>    <span class="hljs-built_in">print</span> aa<br>    <span class="hljs-keyword">global</span> gg<br>    gg = aa<br><br>test()<br>gg[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-string">&quot;world&quot;</span><br>test()<br></code></pre></td></tr></table></figure><p>第一次调用test, aa是{}, 第二次调用就是{“hello”: “world”}了, 所以默认参数可是 可变对象时,要特别注意,<br>一定要确定是否需要使用copy.</p><h1 id="一些标准库的使用说明"><a href="#一些标准库的使用说明" class="headerlink" title="一些标准库的使用说明"></a>一些标准库的使用说明</h1><h2 id="python-正则表达式"><a href="#python-正则表达式" class="headerlink" title="python 正则表达式"></a>python 正则表达式</h2><p>python的正则表达式是通过re这个标准库支持的,这是一篇写的不错的<a href="https://www.evernote.com/shard/s89/sh/8d66ae55-5f2e-4a68-b11d-c8ae8ad3de56/00bfb7913d34061da0083d8286ff1592">文章</a>,<br>我可耻的用evernote保存下来 了,上面有原文章的连接.</p><h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>和log4j类似,先说几个基本概念</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>Logger: 用户程序主要调用的就是该类的实例的方法</li><li>Handler:　指定日志应该保存到何处，比如console,file等等.</li><li>Filters: 指定过滤条件,他可以确定哪些日志输出</li><li>Formatters: 确定日志格式的</li></ol><h3 id="logger层次关系"><a href="#logger层次关系" class="headerlink" title="logger层次关系"></a>logger层次关系</h3><p>获得logger一般使用 <code>logging.getLogger</code> 这个api, 它会接受一个name参数, name 如果不指定那么获得root<br>logger, 假设如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br>root = logging.getLogger()<br>logger1 = logging.getLogger(<span class="hljs-string">&quot;aa&quot;</span>)<br>logger2 = logging.getLogger(<span class="hljs-string">&quot;aa.bb&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>root是所有logger的父logger</strong>, 所以root是logger1的父logger, logger1又是<br>logger2的父logger, 实际上就是将logger像python的模块那样建立层次结构, 子<br>logger的消息会传递给父logger, 所以你运行这行代码<br><code>logger2.info(&quot;hello..&quot;)</code>, 那么消息也会传递到logger1, root,<br>如果这两个logger的设置允许输出消息,那么该<br>消息可能logger2,logger1,root分别输出</p><h3 id="日志输出的过程"><a href="#日志输出的过程" class="headerlink" title="日志输出的过程"></a>日志输出的过程</h3><p>假设你运行 <code>logger.info(&quot;hello&quot;)</code>, 那么这条消息如何输出呢?</p><ol><li>如果logger的level比info高,那么不输出, 如果有注册的filter返回false那么不 输出.</li><li>将消息发送给注册在logger上的所有handler,有handler来局定消息如何处理</li><li>对单个handler而言,如果hander的level比info高,那么不输出,有注册的filter返<br>回false那么不输出,否则就输出</li></ol><p><strong>不管logger是否输出该消息,该消息都会发往父logger.</strong></p><h3 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h3><ol><li>logging.basicConfig: 用来设置root logger的handler, 如果发现handler已设置,那<br>么什么也不做.</li><li>logging.getLogger: 用来创建logger, 如果参数为空,那么返回root logger.</li></ol><p>logger对象的方法:</p><ol><li><code>logger.debug(msg, *args, **kwargs)</code>: msg是字符串,其中可以包含%s, %d这样 的格式化信息,<br>args包含提供给msg的字符格式化参数, kwags中有两个key会检查:<ul><li>exc_info: 如果为True, 那么logger会调用 <code>sys.exc_info</code> 来获得一个记录异 常信息的三元组,<br>接着就会将三元组记录的异常调用栈记录进日志, 注意 <strong>只在 except语句块中有效</strong>, 因为你必须在处理异常时,<br>sys.exc_info才能获得调用栈. 当然你可以明确的指定一个三元组, 而不是简单的指定True, 这样logger就会使<br>用你指定的三元组的异常信息,而不是调用 <code>sys.exc_info</code> 来获得, 因此也就 不存在只在except块有效的限制.</li><li>extra: 指定参数来初始化log record, 可以用它来修改本条日志的一些格式</li></ul></li><li>logger.info</li><li>logger.warning</li><li>logger.error</li><li>logger.critical</li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>threading是一个更高层的模块，它使用更加方便，所以一般情况都是使用该模块</p><ol><li><p>threading.Thread: 要创建一个线程，那么需要先创建threading.Thread的子类，并且重写它的run方法，每一个<br>Thread对象都要调用start方法，该方法启动线程，该线程会运行该对象的run方法 daemon：<br>如果已经没有活动的non-daemon(daemon&#x3D;False)线程的话,<br>整个进程都会退出,所以经常将子线程的daemon 设为True,并且子线程做成一个while<br>True的死循环,这样如果主线程退出,那么整个进程都会退出,那些死循环的子线 程自然也会退出</p></li><li><p>Queue: 同步队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Queue <span class="hljs-keyword">import</span> Queue<br>q = Queue()<br><span class="hljs-comment"># thread1</span><br>item = q.get()<br>do_something(item)<br>q.task_done()<br><br><span class="hljs-comment"># main thread</span><br>q.join()<br></code></pre></td></tr></table></figure><p>实际上task_done就是将内部的计数器减一, 而put会将内部的计数器加1,然后join会测试如果内部的计数器为0就返<br>回,不为0就阻塞</p></li></ol><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>字典的子类，可以用于统计可迭代对象中重复元素出现的次数,这是<a href="http://docs.python.org/2/library/collections.html#counter-objects">文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>cn_str = Counter(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-built_in">print</span> cn_str<br><br>cn_list = Counter([<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>])<br><span class="hljs-built_in">print</span> cn_list<br><br>cn_dict = Counter(cats=<span class="hljs-number">4</span>, dogs=<span class="hljs-number">8</span>)<br><span class="hljs-built_in">print</span> cn_dict<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">Counter(&#123;&#x27;l&#x27;: 3, &#x27;o&#x27;: 2, &#x27; &#x27;: 1, &#x27;e&#x27;: 1, &#x27;d&#x27;: 1, &#x27;h&#x27;: 1, &#x27;r&#x27;: 1, &#x27;w&#x27;: 1&#125;)<br>Counter(&#123;&#x27;blue&#x27;: 3, &#x27;red&#x27;: 2, &#x27;green&#x27;: 1&#125;)<br>Counter(&#123;&#x27;dogs&#x27;: 8, &#x27;cats&#x27;: 4&#125;)<br></code></pre></td></tr></table></figure><p>Counter除了有dict的方法外，还有几个特有的方法</p><ol><li>elements(): 返回可迭代对象，比如调用cn_list.elements() 就会返回[‘red’, ‘blue’,<br>‘red’, ‘green’, ‘blue’, ‘blue’]</li><li>most_common([n]) : 根据字典色value从大到小排出n个item组成一个list</li></ol><h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h3><p>可以从左边或者右边添加或者删除元素,这是<a href="http://docs.python.org/2/library/collections.html#deque-objects">文档</a><br>,主要有append,appendleft(单个元素),extend,extendleft(可迭代对 象),pop, popleft等等</p><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>提供了一个default_factory属性,通过初始化defaultdict实例时对该属性赋值,那么以后如果出现key不存在的情况,不<br>会出现KeyError,而是调用这个默认工厂函数,然后返回该工厂函数的返回值,这是<a href="http://docs.python.org/2/library/collections.html#defaultdict-objects">文档</a><br>,这是几段代码示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs example"># 以list 作为default_factory<br>&gt;&gt;&gt; s = [(&#x27;yellow&#x27;, 1), (&#x27;blue&#x27;, 2), (&#x27;yellow&#x27;, 3), (&#x27;blue&#x27;, 4), (&#x27;red&#x27;, 1)]<br>&gt;&gt;&gt; d = defaultdict(list)<br>&gt;&gt;&gt; for k, v in s:<br>...     d[k].append(v)<br>...<br>&gt;&gt;&gt; d.items()<br>[(&#x27;blue&#x27;, [2, 4]), (&#x27;red&#x27;, [1]), (&#x27;yellow&#x27;, [1, 3])]<br><br># 以整数作为default_factory<br>&gt;&gt;&gt; s = &#x27;mississippi&#x27;<br>&gt;&gt;&gt; d = defaultdict(int)<br>&gt;&gt;&gt; for k in s:<br>...     d[k] += 1<br>...<br>&gt;&gt;&gt; d.items()<br>[(&#x27;i&#x27;, 4), (&#x27;p&#x27;, 2), (&#x27;s&#x27;, 4), (&#x27;m&#x27;, 1)]<br></code></pre></td></tr></table></figure><h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>一个tuple的子类,可以给tuple的每一项添加一个名字,以后就可以通过 X.y这样的方式来访问了,看代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Point = namedtuple(<span class="hljs-string">&#x27;Point&#x27;</span>, [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>], verbose=<span class="hljs-literal">False</span>)<br>p = Point(<span class="hljs-number">11</span>, y=<span class="hljs-number">22</span>)<br><span class="hljs-built_in">print</span> p<br><br>s = p[<span class="hljs-number">0</span>] + p[<span class="hljs-number">1</span>]                 <span class="hljs-comment"># like normal tuple</span><br><span class="hljs-built_in">print</span> s<br><br>s = p.x + p.y<br><span class="hljs-built_in">print</span> s<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">Point(x=11, y=22)<br>33<br>33<br></code></pre></td></tr></table></figure><p>上述代码代表一个点,点有x,y两个值,要访问点的x,可以通过p.x 或者 <code>p[0]</code> (也就是和普通的tuple一样)</p><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>OrderedDict是dict的子类,它会记住key插入的顺序,默认的dict是会排序的, 比如下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br>l = [(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>)]<br>d = <span class="hljs-built_in">dict</span>(l)<br><span class="hljs-built_in">print</span> d<br><br>od = OrderedDict(l)<br><span class="hljs-built_in">print</span> od<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;f&#x27;: 2&#125;<br>OrderedDict([(&#x27;b&#x27;, 3), (&#x27;f&#x27;, 2), (&#x27;a&#x27;, 1)])<br></code></pre></td></tr></table></figure><p>popitem(last&#x3D;True): last为True,那么就是LIFO, 比如上例就是先弹出(a, 1) 然后(f, 2),<br>如果last为False,那么就 是FIFO</p><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><ul><li>dump(self, obj, file) 将对象序列化到文件</li><li>dumps(self, obj) 会返回序列化的字符串</li><li>load(file) 从文件加载对象</li><li>loads(str) 从字符串加载对象</li></ul><!-- end list --><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br>d = &#123;<span class="hljs-string">&#x27;tag&#x27;</span>:<span class="hljs-string">&#x27;django&#x27;</span>&#125;<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;aa.pickle&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    pickle.dump(d, fp)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;aa.pickle&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    d = pickle.load(fp)<br></code></pre></td></tr></table></figure><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>和pickle类似,也是dump,dumps,load,loads这几个接口(以s结尾的就是字符串,否则就<br>是文件),json模块默认只能encode与decode python的内置类型，比如数字，字符串，<br>list，tuple，dict等，如果你要endcode自定义的类，那么你需要扩展，代码示例如下：</p><script src="https://gist.github.com/yuyang0/6945963.js"></script><p>调用的时候直接使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<br>    <span class="hljs-string">&#x27;status&#x27;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-built_in">list</span>(comments),<br>&#125;<br><br>json.dumps(d, cls=CustomTypeEncoder,<br>           user=request.user)<br></code></pre></td></tr></table></figure><p>cls参数指定用来encode的class，后面的user参数用来向自定义的encoder中添加额外<br>的参数，可以在自定义的encoder的init函数中获取，可以参见上面的encoder的代码</p><h2 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h2><p>文档中的示例代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> HTMLParser <span class="hljs-keyword">import</span> HTMLParser<br><br><span class="hljs-comment"># create a subclass and override the handler methods</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHTMLParser</span>(<span class="hljs-title class_ inherited__">HTMLParser</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_starttag</span>(<span class="hljs-params">self, tag, attrs</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Encountered a start tag:&quot;</span>, tag<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_endtag</span>(<span class="hljs-params">self, tag</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Encountered an end tag :&quot;</span>, tag<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_data</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Encountered some data  :&quot;</span>, data<br><br><span class="hljs-comment"># instantiate the parser and fed it some HTML</span><br>parser = MyHTMLParser()<br>parser.feed(<span class="hljs-string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&#x27;</span><br>            <span class="hljs-string">&#x27;&lt;body&gt;&lt;h1&gt;Parse me!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出:该库的使用方法就是在类中处理starttag, endtag, data(标签中间的文本)<br>然后调用feed方法就好,实际是一个流式html解析器</p><h1 id="一些第三方库的使用方法"><a href="#一些第三方库的使用方法" class="headerlink" title="一些第三方库的使用方法"></a>一些第三方库的使用方法</h1><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>python的标准库中的urllib,urllib2的接口并不好用,requests的接口更简洁一致,这是官方<a href="http://docs.python-requests.org/en/latest/">文档</a></p><ol><li><p>get requests.get(url, **kwargs)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br>r = requests.get(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>, params=payload)<br></code></pre></td></tr></table></figure></li><li><p>post requests.post(url, data&#x3D;None, **kwargs)</p><ul><li>data: 是要post的数据</li><li>kwargs: 可以使用headers &#x3D; {….}指定http request header</li></ul><!-- end list --><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br>headers = &#123;<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br><br>r = requests.post(url, data=json.dumps(payload), headers=headers)<br><br></code></pre></td></tr></table></figure></li><li><p>put requests.put(url, **kwargs)</p></li><li><p>response object</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><span class="hljs-built_in">print</span> r.text<br><span class="hljs-built_in">print</span> r.url<br><span class="hljs-built_in">print</span> r.encoding<br><span class="hljs-built_in">print</span> r.status_code                    <span class="hljs-comment"># response status code(eg:200)</span><br><span class="hljs-built_in">print</span> r.headers                        <span class="hljs-comment"># a dict</span><br><span class="hljs-built_in">print</span> r.headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>]        <span class="hljs-comment"># response headers</span><br><span class="hljs-built_in">print</span> r.cookies[<span class="hljs-string">&#x27;example_cookie_name&#x27;</span>] <span class="hljs-comment"># cookies</span><br><span class="hljs-built_in">print</span> r.json()                         <span class="hljs-comment">#  built-in json function</span><br><br><span class="hljs-built_in">print</span> r.request.headers         <span class="hljs-comment"># http request headers</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>从github安装包 pip install git+<a href="git://github.com/yourname/package.git">git://github.com/yourname/package.git</a> 或者pip<br>install git+<a href="https://github.com/yourname/package.git">https://github.com/yourname/package.git</a></p><h2 id="pyquery"><a href="#pyquery" class="headerlink" title="pyquery"></a>pyquery</h2><p>一个使用jquery语法的html解析器,非常方便,比BeautifulSoup好用,这是它的<a href="http://pythonhosted.org/pyquery/index.html">文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">form pyquery <span class="hljs-keyword">import</span> PyQuery<br>html = <span class="hljs-string">&#x27;&lt;html&gt;&lt;title&gt;hello world&lt;/title&gt;&lt;/html&gt;&#x27;</span><br>d = PyQuery(html, parser = <span class="hljs-string">&#x27;html&#x27;</span>)<br>d(<span class="hljs-string">&#x27;title&#x27;</span>).text()<br></code></pre></td></tr></table></figure><p>在调用PyQuery时尽量指定parser, 因为默认判断有时会出错,比如用xml的parser去解析html会得到不正确的结果.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">d = PyQuery(html, parser = <span class="hljs-string">&#x27;html&#x27;</span>)<br><span class="hljs-comment"># selector</span><br>d(<span class="hljs-string">&#x27;body&#x27;</span>)<br>d(<span class="hljs-string">&#x27;div#header&#x27;</span>)<br>d(<span class="hljs-string">&#x27;div.class ul&#x27;</span>)<br>d(<span class="hljs-string">&#x27;meta[name=keywords]&#x27;</span>) <span class="hljs-comment">#attribute</span><br><br>links = d(<span class="hljs-string">&#x27;div.links a&#x27;</span>)<br><span class="hljs-comment"># 该处应使用下标,而不是for link in links</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(links)):<br>    <span class="hljs-built_in">print</span> links.eq(i).attr(<span class="hljs-string">&#x27;href&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="watchdog"><a href="#watchdog" class="headerlink" title="watchdog"></a>watchdog</h2><p>看门狗,用来监控文件系统改变,这是<a href="http://pythonhosted.org/watchdog/">文档</a>, 基本使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> watchdog.observers <span class="hljs-keyword">import</span> Observer<br><span class="hljs-keyword">from</span> watchdog.events <span class="hljs-keyword">import</span> LoggingEventHandler<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    event_handler = LoggingEventHandler()<br>    observer = Observer()<br>    observer.schedule(event_handler, path=<span class="hljs-string">&#x27;.&#x27;</span>, recursive=<span class="hljs-literal">True</span>)<br>    observer.start()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        observer.stop()<br>    observer.join()<br></code></pre></td></tr></table></figure><p>关键的部分有两个:</p><ol><li>recursive&#x3D;True,默认是False,如果不指定那么那么就不会监控子目录</li><li>event_handler:这个是文件系统事件的处理对象,可以自己继承watchdog.events.FileSystemEventHandler,<br>然后重载<a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_created">on_create</a>d,<br><a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_deleted">on_deleted</a>,<br><a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_modified">on_modified</a>,<br><a href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_moved">on_moved</a>,</li></ol><h2 id="rauth"><a href="#rauth" class="headerlink" title="rauth"></a>rauth</h2><p>一个Oauth库,这是<a href="https://rauth.readthedocs.org/en/latest/">文档</a>, 这是一份示例<br><a href="https://gist.github.com/yuyang0/5949932">代码</a>, 基本上照着流程走就OK了</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>流行的就是pytest了，tox可以测试代码在不同环境下(py2.7, py3.5, flake8 etc..)是否 能通过,<br>它可以自动测试这些环境，很方便, 这些工具的配置比较乱</p><ul><li>tox: 配置文件: <code>tox.ini</code></li><li>pytest: 配置文件: <code>pytest.ini</code>, <code>tox.ini</code>, <code>setup.cfg</code></li><li>pytest-cov: 配置文件 <code>setup.cfg</code></li><li>pep8: 配置文件　&#x3D;tox.ini&#x3D;, <code>setup.cfg</code></li><li>flake8: 配置文件　&#x3D;tox.ini&#x3D;, <code>setup.cfg</code></li></ul><p><strong>我的建议是tox的配置放在tox.ini中，其它的都放在setup.cfg中</strong></p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>tox.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs example">[tox]<br>envlist = py27, py35, pypy, flake8<br><br>[testenv]<br>commands = &#123;envpython&#125; setup.py test<br>deps = -rrequirements.txt<br><br>[testenv:flake8]<br>basepython=python<br>deps=flake8<br>commands=flake8 setup.py tests<br><br>[testenv:pypy]<br>basepython=pypy<br></code></pre></td></tr></table></figure><p>setup.cfg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs example">[metadata]<br>description-file = readme.md<br><br>[aliases]<br>test=pytest<br><br># pytest-cov configuration<br>[coverage:run]<br>omit =<br>    gmesos/api.py<br>    gmesos/deployment.py<br><br># pytest configuration (pytest&gt;3.0)<br>[tool:pytest]<br>testpaths = tests<br>addopts = --cov=gmesos --cov-report term-missing<br><br># pep8 configuration<br>[pep8]<br>exclude = gmesos/interface.py<br>max-line-length = 160<br><br># flake8 configuration<br>[flake8]<br>exclude = gmesos/interface.py,venv/<br>max-line-length = 160<br>ignore= F401<br></code></pre></td></tr></table></figure><h1 id="常用工具的使用方法"><a href="#常用工具的使用方法" class="headerlink" title="常用工具的使用方法"></a>常用工具的使用方法</h1><h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><p>这是一份不错的<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs.html">tutorial</a></p><ol><li>virtualenv venv</li><li>source venv&#x2F;bin&#x2F;activate</li><li>deactivate</li></ol><p>virtualenvwrapper可以对virtualenv进行一定的增强</p><ol><li><p>install</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>sudo pip install virtualenvwrapper<br>export WORKON_HOME=~/envs<br>source /usr/local/bin/virtualenvwrapper.sh<br><br></code></pre></td></tr></table></figure></li><li><p>mkvirtualenv my_env 在WORKON_HOME中创建一个名为my_env虚拟环境</p></li><li><p>workon my_env 切换到my_env环境</p></li><li><p>deactivate</p></li><li><p>lssitepackages</p></li><li><p>lsvirtualenv</p></li><li><p>rmvirtualenv my_env</p></li></ol><p>和zsh的整合： 安装virtualenvwrapper插件，然后在每一个仓库中放一个.venv文件，文件的内容 是你创建的env的名字</p><h2 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h2><p>ipython是一个增强的python interpreter,有许多有趣的功能</p><ol><li>magic function 以 % 或者 %% 开头的都是magic function,其中<ul><li>以%开头会将本行余下的部分作为一个参数传递给该命令,如果%automagic为on(默认), 那么可以省略前面的 %, 可以<br>使用 %lsmagic 来列出有多少这种命令.</li><li>以%%开头的命令不仅会将本行余下的部分作为参数,本行下面独立的行也会作为参数</li></ul></li><li>TAB补全, 可以补全内置的函数,模块以及变量文件名等等</li><li>%run命令: 该命令可以用来运行脚本(实际是把所有的属性导入当前的namespace,和import功能类似),测试脚本时用该<br>命令,而不是import,因为该命令可以让改动立即生效,有以下几个选项:<ul><li>t: 可以用来获得脚本的运行时间</li><li>p: 性能分析,会列出程序中每个函数调用的时间, %prun命令与该选项功能相似,但是它是对一条python命令或者一个函数调<br>用进行性能测试</li><li>d: 调试,激活pdb,并在开始处暂停,和gdb类似</li></ul></li><li>剖析对象,给定一个对象,观察这个对象的文档,函数定义以及源代码,有以下命令<ul><li>%pdoc: print doc string</li><li>%pdef: print definition of function</li><li>%psource: print source code</li><li>%pfile: get file of this object</li></ul></li><li>调试: %pdb命令会打开或关闭在任何未捕捉的异常点调用pdb调试器的功能, 如果该功能打开了,那么遇到任何未捕捉的<br>异常,会自动调用调试器,这样就可以打印异常点的变量值,执行代码了</li><li>运行shell命令: !开头,比如 !ping <a href="http://www.baidu.com/">www.baidu.com</a> ,可以将shell命令的输出赋给python变量, 比如<br>output &#x3D; !ping www..baidu.com, 那么output就会是ping的输出</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>lang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang笔记</title>
    <link href="/notes/golang/"/>
    <url>/notes/golang/</url>
    
    <content type="html"><![CDATA[<h1 id="go代码规范"><a href="#go代码规范" class="headerlink" title="go代码规范"></a>go代码规范</h1><ol><li>使用驼峰命名法, 私有名字以小写字母开头，公有名字以大写字母开头, 也就是说 <strong>小写<br>字母开头，那么只在本包内可见，大写字母开头才能在包外可见</strong></li><li>大括号不要换行</li><li>包名最好文件夹名相同, 并且为小写</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量的声明主要有两种方法</p><ol><li>var x type</li><li>x :&#x3D; val</li></ol><p>使用var声明引用变量是不会分配内存的，因此到底需不需要调用make来初始化则视情况而 定,<br><strong>map需要调用make来初始化，slice不需要</strong>.<br>这是因为即使是一个空的map，也需要一 些额外的内存来存储信息,<br>slice则不需要。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)      <span class="hljs-comment">// ok</span><br><br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-type">int</span><br>m[<span class="hljs-string">&quot;aa&quot;</span>] = <span class="hljs-number">1</span>           <span class="hljs-comment">// error</span><br><br><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-type">int</span><br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>m[<span class="hljs-string">&quot;aa&quot;</span>] = <span class="hljs-number">1</span>           <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><p>go引用提供了很多基本类型，这些基本类型分为两类：值类型和引用类型。 <strong>map，channel， slice,interface,<br>function，method是引用类型，其它的包括array，struct都是值类型</strong>. 这两种类型的不同在函数调用时会表现出不同。</p><h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>只能赋值给 <strong>指针</strong> 和 <strong>引用</strong> 类型的变量. 实践中主要用来指示slice，map，interface<br>是未初始化的值。虽然nil和空的slice和map有很多相似之处，比如调用len会返回0，但是<br>他们并不是一回事。看下面的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> slice []<span class="hljs-type">int</span>            <span class="hljs-comment">// slice == nil 返回true</span><br>slice = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)     <span class="hljs-comment">// slice == nil 返回false</span><br><br><span class="hljs-keyword">var</span> mm <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>      <span class="hljs-comment">// mm == nil 返回true</span><br>mm = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)  <span class="hljs-comment">// mm == nil返回false</span><br></code></pre></td></tr></table></figure><p><strong>slice, map, interface只能与nil进行比较</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ss []<span class="hljs-type">int</span><br>ss == <span class="hljs-literal">nil</span>          <span class="hljs-comment">// ok</span><br>ss == []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;  <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>只能取值true，false。不能通过其它类型转换为bool，所以 <code>aa:=bool(1)</code> 这样的语句是 错误的。</p><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>可以取值int, uint, int8,int16,int32, int64, uint8(byte), uint16, uint32,<br>uint64. int, uint是平台相关的，可能为32或者64位。</p><h2 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h2><p>可以为float32或者float64，浮点不能使用&#x3D;&#x3D;来直接比较相等，可以使用math包的 <code>Fdim</code> 来处理</p><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>可以为byte或者rune(rune和int32是等价的)，前者是字节或者是unicode</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>go中字符串不可变</strong>, go中的字符串实际就是utf8编码的字节流，所以如果存储的全部是英<br>文字符那么他和字节流(<code>[]byte</code>)没什么两样，但是如果有汉字，那么需要注意，因为一个<br>汉字在utf8中需要3到4个字节，所以你可能需要使用 <code>[]rune(s)</code> 转换成unicode字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span> <span class="hljs-comment">// 声明一个字符串变量</span><br>str = <span class="hljs-string">&quot;Hello world&quot;</span> <span class="hljs-comment">// 字符串赋值</span><br>ch := str[<span class="hljs-number">0</span>] <span class="hljs-comment">// 取字符串的第一个字符</span><br>fmt.Printf(<span class="hljs-string">&quot;The length of \&quot;%s\&quot; is %d \n&quot;</span>, str, <span class="hljs-built_in">len</span>(str))<br>fmt.Printf(<span class="hljs-string">&quot;The first character of \&quot;%s\&quot; is %c.\n&quot;</span>, str, ch)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;    <span class="hljs-comment">//遍历字节</span><br>  fmt.Println(i, str[i])<br>&#125;<br><span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> str &#123;           <span class="hljs-comment">//遍历unicode</span><br>  fmt.Println(i, ch)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><p>这个包包括了很多字符串格式化的命令。这个包的函数命名有一些规律</p><ol><li>开头<ul><li>E： 会返回一个error值</li><li>F: 会将得到的字符串写入一个io.Writer中</li><li>S：会将得到的字符串返回</li><li>无：将得到的字符写入标准输出</li></ul></li><li>结尾<ul><li>f: 意味着需要一个格式字符串</li><li>ln: 会在末尾追加一个换行符</li></ul></li></ol><p>如果没有格式字符串那么就以默认的形式显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs example">fmt.Errorf(format, args...)           // 返回一个错误值<br>fmt,Fprintf(writer, format, args...)  //向writer写入字符串<br>fmt.Printf(format, args...)           //向os.Stdout写入字符串<br>fmt.Sprintf(format, args...)       //返回一个字符串<br></code></pre></td></tr></table></figure><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p>标准库中的strings包含了许多常见的字符串处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Split(ss, sep)<br>strings.SplitAfter(ss, sep)    <span class="hljs-comment">//保留分隔符</span><br>strings.Join(xs, sep)          <span class="hljs-comment">//使用sep将xs的元素连接成字符串</span><br>strings.ToLower(s)<br>strings.ToUpper(s)<br>strings.ToTitle(s)<br><br>strings.Trim(s, t)<br>strings.TrimLeft(s, t)<br>strings.TrimRight(s, t)<br><br>strings.HasPrefix(s, p)<br>strings.HasSuffix(s, t)<br><br>strings.Index(s, t)<br></code></pre></td></tr></table></figure><h3 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h3><p>这个包可以将字符串和其它类型进行转换</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个定长的序列，创建了长度就不能更改了。在go中切片远比数组通用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">[length]Type<br>[length]Type&#123;val1, val2, ..., valN&#125;<br>[...]Type&#123;val1, val2, ... , valN&#125;<br><br><span class="hljs-keyword">var</span> [<span class="hljs-number">32</span>]<span class="hljs-type">byte</span> <span class="hljs-comment">// 长度为32的数组，每个元素为一个字节</span><br><span class="hljs-keyword">var</span> [<span class="hljs-number">2</span>*N] <span class="hljs-keyword">struct</span> &#123; x, y <span class="hljs-type">int32</span> &#125; <span class="hljs-comment">// 复杂类型数组</span><br><span class="hljs-keyword">var</span> [<span class="hljs-number">1000</span>]*<span class="hljs-type">float64</span> <span class="hljs-comment">// 指针数组</span><br><span class="hljs-keyword">var</span> [<span class="hljs-number">3</span>][<span class="hljs-number">5</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 二维数组(3行5列)</span><br><span class="hljs-keyword">var</span> [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">float64</span> <span class="hljs-comment">// 等同于[2]([2]([2]float64))</span><br><br>aa := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;  <span class="hljs-comment">// 1, 2, 3, 4, 5</span><br>aa := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;           <span class="hljs-comment">// 1, 2, 0, 0, 0</span><br>aa := [...]<span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125; <span class="hljs-comment">//1, 2, 3, 4, 5</span><br>aa := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>:<span class="hljs-number">1</span>, <span class="hljs-number">3</span>:<span class="hljs-number">2</span>, <span class="hljs-number">4</span>:<span class="hljs-number">3</span>&#125;    <span class="hljs-comment">//0, 0, 1, 2, 3</span><br>aa := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>:<span class="hljs-number">1</span>, <span class="hljs-number">3</span>:<span class="hljs-number">2</span>, <span class="hljs-number">4</span>:<span class="hljs-number">3</span>&#125;    <span class="hljs-comment">//0, 0, 1, 2, 3</span><br></code></pre></td></tr></table></figure><h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片(slice)"></a>切片(slice)</h2><p>切片是引用类型，在标准库中，所有的api都使用切片，创建切片和创建数组最大的区别是， 数组必须在[]中指定长度，切片则一直是空的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]Type, length, capacity)<br><span class="hljs-built_in">make</span>([]Type, length)<br>[]Type&#123;&#125;<br>[]Type&#123;val1, val2, ..., valN&#125;   <span class="hljs-comment">// 四种创建切片的方法，都没有在[]中指定大小</span><br><br><span class="hljs-keyword">var</span> slice1 []<span class="hljs-type">int</span>       <span class="hljs-comment">// 若你不知道切片的长度，这样声明最合适，不要用make</span><br>slice1 := []<span class="hljs-type">int</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>slice2 := arr[:]                <span class="hljs-comment">//从数组创建，语法和python类似</span><br>slice3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)        <span class="hljs-comment">// 5个元素的切片，都初始化为0</span><br>slice3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)    <span class="hljs-comment">// 5个元素的切片，都初始化为0,同时预留10个元素的空间</span><br>newSlice := <span class="hljs-built_in">append</span>(slice1, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>)<br>newSlice := <span class="hljs-built_in">append</span>(slice1, slice2...)<br><br><span class="hljs-keyword">for</span> idx, val := <span class="hljs-keyword">range</span> slice &#123;     <span class="hljs-comment">// 遍历</span><br>  <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过切片语法从字符串，数组，切片来创建切片，语法是python切片语法的子集，记住 是左闭右开就是了。<br><strong>特别要注意make函数的第二个参数，该参数指定了slice的初始长度，<br>也就是调用len返回的值,所以你创建新的空slice时，这个值应为0</strong>.</p><h2 id="字典-map"><a href="#字典-map" class="headerlink" title="字典(map)"></a>字典(map)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> aa <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-type">int</span>           <span class="hljs-comment">//声明</span><br>bb := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-type">int</span>)       <span class="hljs-comment">//声明并赋值</span><br>cc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment">//指定初始容量</span><br>cc[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">10</span>                   <span class="hljs-comment">//添加key1</span><br><span class="hljs-built_in">delete</span>(cc, <span class="hljs-string">&quot;key1&quot;</span>)                 <span class="hljs-comment">//删除key1</span><br>value, ok := myMap[<span class="hljs-string">&quot;1234&quot;</span>]        <span class="hljs-comment">//查找key1</span><br><span class="hljs-keyword">if</span> ok &#123; <span class="hljs-comment">// 找到了</span><br>  <span class="hljs-comment">// 处理找到的value</span><br>&#125;<br><span class="hljs-built_in">len</span>(cc)                           <span class="hljs-comment">// cc包含的键值对的个数</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> cc &#123;            <span class="hljs-comment">// 遍历map</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channel是goroutine之间的通信方式, 它是线程安全的,但是要注意,如果你传递的指针,那 么它仍然有可能出现竞争条件</p><ol><li><p>channel应该由发送端来关闭</p></li><li><p>使用如下的代码来测试channel是不是已经关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">e, ok := &lt;- channel<br><span class="hljs-keyword">if</span> ok &#123;<br>  <span class="hljs-comment">// get a item</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// channel is closed.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果channel没有关闭，而且也没有元素可读，那么上面的代码会 <strong>阻塞</strong>.要不阻塞的测<br>试，只能使用带default的select。</p></li><li><p>使用range遍历一个channel的时候, 如果channel已经关闭,那么range会终止.</p></li><li><p>channel的超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> err := &lt;-c:<br>  <span class="hljs-comment">// use err and reply</span><br><span class="hljs-keyword">case</span> &lt;-time.After(timeoutNanoseconds):<br>  <span class="hljs-comment">// call timed out</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>quit channel是通知goroutine退出的最佳方式，在需要退出的时候close掉channel，这<br>样任何goroutine只要使用这样的代码测试就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- quitChan:<br>  <span class="hljs-comment">// quit</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭的channel上调用任意多次 <code>&lt;-</code> 都不会阻塞，所以不要使用带buffer的channel。</p></li></ol><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><h3 id="interface-1"><a href="#interface-1" class="headerlink" title="interface{}"></a>interface{}</h3><p>type assertion(类型断言)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> anything <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;hello&quot;</span><br>aString := anything.(<span class="hljs-type">string</span>)              <span class="hljs-comment">// unsafe, may panic</span><br><span class="hljs-keyword">if</span> aString, ok := anything.(<span class="hljs-type">string</span>); ok &#123; <span class="hljs-comment">// safe, check ok</span><br>  doSomething<br>&#125;<br><span class="hljs-comment">// if you are not sure, use type switch</span><br><span class="hljs-keyword">switch</span> v := anything.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>  fmt.Println(v)<br><span class="hljs-keyword">case</span> <span class="hljs-type">int32</span>, <span class="hljs-type">int64</span>:<br>  fmt.Println(v)<br><span class="hljs-keyword">case</span> SomeCustomType:<br>  fmt.Println(v)<br><span class="hljs-keyword">default</span>:<br>  fmt.Println(<span class="hljs-string">&quot;unknown&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><ol><li>append： 添加元素到切片, 使用 <code>aa=append(aa, ele)</code> 的语法。将一个切片追加到另 一个切片 <code>s1 = append(s1, s2...)</code> 也就是要放省略号。</li><li>close： 关闭通道</li><li>make：用来创建slice，map，channel。可以指定长度和容量</li><li>delete：从map中删除项</li><li>len：获得数组，slice，map的长度以及channel缓冲区中元素的个数.</li></ol><h1 id="go工程管理"><a href="#go工程管理" class="headerlink" title="go工程管理"></a>go工程管理</h1><ol><li>自己编写的package的名字一般要和文件夹一样(go允许二者不一样，但是为了避免混淆， 建议一样)，但是main<br>package的文件夹一般不取main</li><li>import指令是用来导入包的，导入的时候使用的是包所在文件夹的名字，而在代码中使<br>用该包的时候使用的package的名字，所以为了避免混乱，应该让文件夹的名字和包名一<br>致，可以使用相对导入，如果使用绝对导入，那么go就会去 <code>$GOPATH/src</code> 的目录下面 找</li><li>go build 也要指定一个main package，main package可以使用绝对路径和相对路径，含 义和第一条一样,<br>记住这里的main package是文件夹名。一般使用这样的命令来编译： <code>go build -o ./main main_package_dirname</code></li><li>也可以直接使用go run来运行代码。后面应该接main函数所在的那个文件的文件名。</li><li>go get 可以用来从github或者bitbucket上下载代码，你只需要指定代码仓库的地址就 可以了，举个例子 <code>go get github.com/yuyang0/gt-go-sdk</code> 就会将代码下载到<br><code>$GOPATH/src/github.com/yuyang0/gt-go-sdk</code> 中, 所以你就可以导入这个包了</li></ol><h1 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h1><p>这个是go语言的发射机制,它主要是用来获取interface下面值的type与value的, reflect包 有两个类型Type和Value.</p><ol><li>Type: 这个是用来代表值的类型的</li><li>Value: 这个是用来代表值的.</li></ol><h1 id="Cgo"><a href="#Cgo" class="headerlink" title="Cgo"></a>Cgo</h1><h2 id="注意事项-高能预警"><a href="#注意事项-高能预警" class="headerlink" title="注意事项(高能预警)"></a>注意事项(高能预警)</h2><ol><li><p>import “C” 的上面不能有空行, 也就说这一行要和注释紧挨着.</p></li><li><p>cgo不支持调用C语言中可变参数的函数, 所以你不能调用 <code>C.printf</code> 这类的函数</p></li><li><p>cgo创建结构体时一般会有对齐,所以在初始化结构体时要注意, 必须显式的指定值对应的name.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">   struct  &#123;</span><br><span class="hljs-comment">       char *name;</span><br><span class="hljs-comment">       int age;</span><br><span class="hljs-comment">       int height;</span><br><span class="hljs-comment">   &#125;person_t;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-keyword">type</span> Person C.person_t<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// error: too few values in struct initializer</span><br>  p1 := Person&#123;C.CString(<span class="hljs-string">&quot;Giorgis&quot;</span>), <span class="hljs-number">30</span>, <span class="hljs-number">6</span>&#125;<br>  <span class="hljs-comment">// correct</span><br>  p2 := Person&#123;name:C.CString(<span class="hljs-string">&quot;Giorgis&quot;</span>), age:<span class="hljs-number">30</span>, height:<span class="hljs-number">6</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>p1因为对齐的存在会编译报错.</p></li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>go可以很方便的和C语言交互，为了相互调用必须对数据类型进行转换，也就是在C的类型和<br>go的类型之间相互转换。整数字面值不需要使用C.int转换，所以在需要使用C.int的地方可<br>以直接使用1,2,3等，nil和NULL也不需要转换, 也就是说需要NULL的c函数可以直接给它传 递nil, 一个C函数如果返回NULL,<br>也可以让它与nil直接比较, 但是字符串字面值需要转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs example">bool --&gt; C.bool<br>char --&gt;  C.char --&gt;  byte<br>signed char --&gt;  C.schar --&gt;  int8<br>unsigned char --&gt;  C.uchar --&gt;  uint8<br>short int --&gt;  C.short --&gt;  int16<br>short unsigned int --&gt;  C.ushort --&gt;  uint16<br>int --&gt;  C.int --&gt;  int<br>unsigned int --&gt;  C.uint --&gt;  uint32<br>long int --&gt;  C.long --&gt;  int32 or int64<br>long unsigned int --&gt;  C.ulong --&gt;  uint32 or uint64<br>long long int --&gt;  C.longlong --&gt;  int64<br>long long unsigned int --&gt;  C.ulonglong --&gt;  uint64<br>float --&gt;  C.float --&gt;  float32<br>double --&gt;  C.double --&gt;  float64<br>void * -&gt; unsafe.Pointer<br></code></pre></td></tr></table></figure><p><strong>特别注意指针</strong>, 因为golang类型系统的关系,指针转换基本都必须先转换成 <code>unsafe.Pointer</code>,<br>然后在将该指针转换成你想要的指针,要将go指针转换为c指针(*int –&gt;<br>*C.int) 需要这样的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ig <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>(*C.<span class="hljs-type">int</span>)(unsafe.Pointer(&amp;ig))<br></code></pre></td></tr></table></figure><p>对于C中需要void*的场景,只需要将指针转换成 <code>unsafe.Pointer</code> 就好, 所以对于 <code>free</code> 应该这样调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">gs := <span class="hljs-string">&quot;hello world&quot;</span><br>cs := C.CString(gs)<br>C.free(unsafe.Pointer(cs))<br></code></pre></td></tr></table></figure><h2 id="go中引用C"><a href="#go中引用C" class="headerlink" title="go中引用C"></a>go中引用C</h2><p>C中的名称都可以使用“C”这个“包”访问到</p><ol><li><p>类型：C.int, C.float, *C.int 代表C中的int，foat以及int*，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdint.h&gt;</span><br><span class="hljs-comment">int ic = 5;</span><br><span class="hljs-comment">unsigned int uic = 7;</span><br><span class="hljs-comment">int16_t is = 12345;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;reflect&quot;</span><br>  <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> ig <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><br>  igc := <span class="hljs-type">int</span>(C.ic)   <span class="hljs-comment">// C int ==&gt; Go int</span><br><br>  icg := C.<span class="hljs-type">int</span>(ig)   <span class="hljs-comment">// Go int ==&gt; C int</span><br><br>  icp := (*C.<span class="hljs-type">int</span>)(unsafe.Pointer(&amp;ig)) <span class="hljs-comment">// Go int pointer ==&gt; C int pointer</span><br><br>  uigc := <span class="hljs-type">uint</span>(C.uic)  <span class="hljs-comment">// C uint ==&gt; Go uint</span><br><br>  i64t := <span class="hljs-type">int16</span>(C.is)  <span class="hljs-comment">// C short ==&gt; Go short</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>string对于string因为C的原因需要特殊处理, C string是不会被GC回收的，所以你要调 用 <code>defer C.free(unsafe.Pointer(x))</code> 来回收内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">    char* cstring = &quot;C string example&quot;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>  <span class="hljs-keyword">var</span> gstring <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Go string example&quot;</span><br><br>  <span class="hljs-comment">//Go to C String, Output: *C.char</span><br>  cs := C.CString(gstring)<br>  <span class="hljs-keyword">defer</span> C.free(unsafe.Pointer(cs))<br>  fmt.Println(cs)<br><br>  <span class="hljs-comment">//C to Go String, Output: string</span><br>  gs := C.GoString(C.cstring)<br>  fmt.Println(gs)<br><br>  <span class="hljs-comment">//C string, length to Go string</span><br>  gs2 := C.GoStringN(C.cstring, (C.<span class="hljs-type">int</span>)(<span class="hljs-built_in">len</span>(gs)))<br>  fmt.Println(gs2)<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数：可以直接引用，C.printf, C.sqrt 等等, 只是你需要将参数转换成C的形式, 当<br>调用C函数,你可以返回多个值,一个是C函数的返回值,一个根据errno封装的error对象,<br>这在调用一些系统调用时非常有用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">n, err := C.sqrt(<span class="hljs-number">-1</span>)<br>_, err := C.voidFunc()<br></code></pre></td></tr></table></figure><p>即便是C中的void函数也可以返回两个值, 当然这种情况下第一个值是没有意义的.</p></li><li><p>struct 看代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">    struct Person &#123;</span><br><span class="hljs-comment">        char *name;</span><br><span class="hljs-comment">        int age;</span><br><span class="hljs-comment">        int height;</span><br><span class="hljs-comment">        int weight;</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> p C.struct_Person<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>  person := p&#123;C.CString(<span class="hljs-string">&quot;Giorgis&quot;</span>), <span class="hljs-number">30</span>, <span class="hljs-number">6</span>, <span class="hljs-number">175</span>&#125;<br>  fmt.Println(person)<br>  fmt.Println(C.GoString(person.name))<br>  fmt.Println(person.age)<br>  fmt.Println(person.height)<br>  fmt.Println(person.weight)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Tips-best-practice"><a href="#Tips-best-practice" class="headerlink" title="Tips(best practice)"></a>Tips(best practice)</h1><ol><li><p>处理错误时避免多重嵌套，先处理错误的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-comment">// handle error</span><br>&#125;<br><span class="hljs-comment">// do soamething</span><br></code></pre></td></tr></table></figure></li><li><p>尽量避免重复，可以定义一些一次性的类型来更好的组织代码</p></li><li><p>使用type switch来处理type cast</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x := v.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>  fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, x)<br><span class="hljs-keyword">case</span> <span class="hljs-type">int64</span>:<br>  fmt.Print(x)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>命名应该尽可能的短小，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span>  db<br><span class="hljs-keyword">type</span> DB <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// some fields</span><br>&#125;<br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *DB &#123;<br><br>&#125;<br><span class="hljs-comment">//bad</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDB</span><span class="hljs-params">()</span></span> *DB &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>因为有包名，所以就不需要在New后面加个DB的后缀了。</p></li><li><p>大型的包最好组织成多个文件，这样可以使文档以及测试更模块化。</p></li><li><p>在库以及API中间尽量不要使用并发，应该让调用者来决定是否需要在单独的goroutine中运行</p></li><li><p>尽量使用channel或者一个带有channel的类型来在goroutine之间来通信。</p></li><li><p>避免goroutine泄露，也就说goroutine永久的block，一直不退出，这实际上也是一种资 源泄露，通过buffered<br>channel或者quit channel可以避免。quit channel是更通用的 做法</p></li></ol><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><h2 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h2><p>先看一段错误代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>  s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>    wg.Add(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">defer</span> wg.Done()<br>      fmt.Print(s[i])<br>    &#125;()<br>  &#125;<br>  wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码有很大可能出现index out of range的错误，对于for loop需要记住一点：</p><ol><li><code>for exp &#123;body&#125;</code> 这样的表达式中, <code>exp</code> 中创建的变量在所有迭代中是共享的，也就<br>是说是同一个变量，但是body中创建的变量是不共享的。你可以认为exp中创建的变量的<br>作用域是for表达式所在的作用域，而不是body所在的作用域</li></ol><p>所以上面的例子中i是共享的，所以对i的修改会传递到所有的goroutine中，因为goroutine<br>的启动会有一点延迟，所以等goroutine启动开始运行时i很可能已被修改成了5，自然就会<br>出现index out of range的错误，正确的做法:</p><ol><li><p>将i作为参数传递给goroutine的那个匿名函数。</p></li><li><p>在body创建一个新的变量,eg</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>  s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>    i := i<br>    wg.Add(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">defer</span> wg.Done()<br>      fmt.Print(s[i])<br>    &#125;()<br>  &#125;<br>  wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>匿名函数中使用上层作用域的变量要谨慎</strong>.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL笔记</title>
    <link href="/notes/sql/"/>
    <url>/notes/sql/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL基本知识与常用代码"><a href="#SQL基本知识与常用代码" class="headerlink" title="SQL基本知识与常用代码"></a>SQL基本知识与常用代码</h1><h2 id="conventions"><a href="#conventions" class="headerlink" title="conventions"></a>conventions</h2><ol><li>SQL 不区分大小写,但是惯例是SQL的关键字要大写, 所有的列名,表名,数据库名都 用小写.</li><li>每一条SQL语句后加分号;</li><li>SQL不区分空格,所以为了可读性,可以把Sql语句分成多行.</li></ol><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs example">mysql –h hostname -P port –u username –p password.<br></code></pre></td></tr></table></figure><h2 id="增加新用户"><a href="#增加新用户" class="headerlink" title="增加新用户"></a>增加新用户</h2><ul><li><p>grant 权限 on 数据库.* to 用户名称@登陆主机 identified 密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span>, <span class="hljs-keyword">update</span>, <span class="hljs-keyword">delete</span><br><span class="hljs-keyword">on</span> books.<span class="hljs-operator">*</span><br><span class="hljs-keyword">to</span> <span class="hljs-keyword">user</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;1234&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="database相关"><a href="#database相关" class="headerlink" title="database相关"></a>database相关</h2><ul><li>create database 数据库名; (创建数据库)</li><li>show databases; (显示所有数据库)</li><li>use dbname; (改变当前数据库)</li></ul><h2 id="SHOW"><a href="#SHOW" class="headerlink" title="SHOW"></a>SHOW</h2><ul><li>SHOW DATABASES;</li><li>SHOW TABLES;</li><li>SHOW COLUMNS FROM tbname; (显示数据表tbname的结构)</li><li>DESCRIBE tbname; (等价于 show columns from tbname;)</li><li>SHOW STATUS; (显示数据库的基本信息)</li><li>SHOW GRANTS [username]; (显示当前用户或username的权限)</li><li>SHOW CREATE DATABASE dbname; (显示创建数据库dbname的sql语句)</li><li>SHOW CREATE DATABASE tbname; (显示创建数据表tbname的sql语句)</li></ul><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>select用来检索数据, 检索时至少要指定两条信息:</p><ol><li><p>你要检索什么(field name)</p></li><li><p>从哪里检索(database name)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs example">SELECT  列1,列2  FROM  表名<br>SELECT  表1.列1, 表2. 列2  FROM  表1, 表2（多张表中选取）<br>SELECT  *  FROM  表名<br>SELECT  DISTINCT  列2   FROM  表名       (去除重复)<br></code></pre></td></tr></table></figure></li></ol><p>同时还可以指定一些过滤规则与排序规则, 这一般是通过子句实现的:</p><ol><li>ORDER BY 列1, 列2 [DESC|ASC] : <strong>必须在where子句后,在limit子句前.</strong></li><li>LIMIT num : 用来指定最多返回多少条记录.必须在order by子句之后.</li><li>WHERE 子句: 指定过滤条件(尽量在数据库层面过滤数据,而不要在语言层面(如 php,python)过滤数据),<br>因为数据库过滤效率较高, 而且也可以避免不必要的数据 在数据库服务端到数据库客户端的传输<ol><li><p>WHERE 列名 操作符 值</p><p>对应的列如果是整数那么值就不要引号,如果是字符串那么值就加单引号.</p><p>操作符有:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>operator</td><td>meaning</td></tr><tr><td><code>,&gt;,&gt;</code>,&lt;,&lt;&#x3D;, &lt;&gt;, !&#x3D;</td><td>等于,大于..etc(!&#x3D;, &lt;&gt;都是不等于的意思)</td></tr><tr><td>BETWEEN</td><td>介于指定值之间</td></tr><tr><td>IN</td><td>枚举(可以看做是OR的简写)</td></tr><tr><td>NOT</td><td>MySQL只允许NOT出现在IN, BETWEEN, EXISTS之前, 也就是NOT IN, NOT BETWEEN, NOT EXISTS</td></tr><tr><td>LIKE</td><td>使用通配符来匹配字段,性能不是很高,所以慎用</td></tr><tr><td>REGEX</td><td>使用正则表达式来匹配字段,性能也不是很高,所以慎用</td></tr></tbody></table><ul><li><p>LIKE: 模式必须匹配整个列,而不是一列的一部分</p><ul><li>%: 代表任意字符出现任意次数</li><li>_: 代表单个字符</li></ul><p>通配符要尽量少用,特别是不要放在模式的开头,因为那非常慢.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%anvil%&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>REGEX: 和一般的正则表达式差不多</p></li></ul><!-- end list --><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- (greater than)</span><br><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- (not equal)</span><br><span class="hljs-keyword">SELECT</span> vend_id, prod_name<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-operator">!=</span> <span class="hljs-number">1003</span>;<br><span class="hljs-comment">-- (between)</span><br><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">5</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- (in)</span><br><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br><span class="hljs-comment">-- NOT IN</span><br><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></td></tr></table></figure></li><li><p>逻辑联结词 AND, OR</p><p>可以用来连接多个过滤条件,必要时要加小括号来分组.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-number">1003</span> <span class="hljs-keyword">AND</span> prod_price <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- OR</span><br><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-number">1001</span> <span class="hljs-keyword">OR</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-number">1002</span>;<br></code></pre></td></tr></table></figure></li><li><p>创建计算字段:</p><p>假设一个订单表包含一个price字段以及一个quantity字段, 那么为了计算总价,就 可以用下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> price,<br>    quantity,<br>    price<span class="hljs-operator">*</span>quantity <span class="hljs-keyword">AS</span>  expanded_price<br><span class="hljs-keyword">FROM</span> orderitems<br></code></pre></td></tr></table></figure><p>那么上面的 <code>expanded_price</code> 字段并不存在于数据表中, 而是根据已有字段 计算出来的, 对于数字字段可以使用<br>+,-,*,&#x2F;. 对于字符串字段可以使用 <strong>拼 接</strong> (<strong>MySQL用Concat, 其它数据库一般用 ||或+</strong>),<br>删除空格(RTrim, LTrim, Trim).</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Concat(RTrim(vend_name), <span class="hljs-string">&#x27;(&#x27;</span>, RTrim(vend_country), <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">AS</span><br>vend_title<br><span class="hljs-keyword">FROM</span> vendors<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> vend_name;<br></code></pre></td></tr></table></figure></li><li><p>函数</p><ul><li><p>字符串函数(Upper, Lower, LTrim, RTrim, Trim, Substring …)</p></li><li><p>日期,时间函数(Now, Curdate, Curtime, Year, Month, Day…)</p><p>日期的格式应该是: yyyy-mm-dd</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_id, order_num<br><span class="hljs-keyword">FROM</span> orders<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">Date</span>(order_date) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2005-09-01&#x27;</span>;<br><span class="hljs-comment">-- orders in 2005-09</span><br><span class="hljs-keyword">SELECT</span> cust_id, order_num<br><span class="hljs-keyword">FROM</span> orders<br><span class="hljs-keyword">WHERE</span> <span class="hljs-type">Date</span>(order_date) <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;2005-09-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;2005-9-30&#x27;</span>;<br><span class="hljs-comment">-- identical(better version)</span><br><span class="hljs-keyword">SELECT</span> cust_id, order_num<br><span class="hljs-keyword">FROM</span> orders<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">Year</span>(order_date) <span class="hljs-operator">=</span> <span class="hljs-number">2005</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">Month</span>(order_date) <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure></li><li><p>数值处理函数: Abs, Sin, Cos 等等</p></li></ul></li><li><p>聚集函数: AVG, COUNT, MAX, MIN, SUM.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num_items,<br>    <span class="hljs-built_in">MIN</span>(prod_price) <span class="hljs-keyword">AS</span> price_min,<br>    <span class="hljs-built_in">MAX</span>(prod_price) <span class="hljs-keyword">AS</span> price_max,<br>    <span class="hljs-built_in">AVG</span>(prod_price) <span class="hljs-keyword">AS</span> price_avg<br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p>结果类似于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example">+-----------+-----------+-----------+-----------+<br>| num_items | price_min | price_max | price_avg |<br>|-----------+-----------+-----------+-----------|<br>|        14 |      2.50 |     55.00 | 16.133571 |<br>+-----------+-----------+-----------+-----------+<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="联接"><a href="#联接" class="headerlink" title="联接"></a>联接</h2><h3 id="内联接-等值联接"><a href="#内联接-等值联接" class="headerlink" title="内联接(等值联接)"></a>内联接(等值联接)</h3><p>vendors表存储制造商信息,其主键为vend_id, products表存储产品信息,其中有一个 外键<br>vend_id指向vendors表.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> vend_name, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> vendors, products<br><span class="hljs-keyword">WHERE</span> vendors.vend_id <span class="hljs-operator">=</span> products.vend_id;<br></code></pre></td></tr></table></figure><p>上例可以这样理解,先使用下面这两条语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> vend_name <span class="hljs-keyword">FROM</span> vendors;<br><span class="hljs-keyword">SELECT</span> prod_name, prod_price <span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p>进行检索, 然后把二者的结果集进行自由组合(笛卡尔积), 紧接着将这些结果中 <code>vendors.vend_id &lt;&gt; products.vend_id</code> 的结果剔除掉.</p><p>等价的形式是:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> vend_name, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> vendors <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> products<br><span class="hljs-keyword">ON</span> vendors.vend_id <span class="hljs-operator">=</span> products.vend_id;<br></code></pre></td></tr></table></figure><p>INNER JOIN 是推荐的写法.</p><h3 id="自联接"><a href="#自联接" class="headerlink" title="自联接"></a>自联接</h3><p>联接的两个表是同一个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> p1.prod_id, p1.prod_name<br><span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">AS</span> p1, products <span class="hljs-keyword">AS</span> p2<br><span class="hljs-keyword">WHERE</span> p1.vend_id <span class="hljs-operator">=</span> p2.vend_id<br>    <span class="hljs-keyword">AND</span> p2.prod_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;DTNTR&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>一个select 返回的结果作为另外一条select 的条件.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_id, amount<br><span class="hljs-keyword">FROM</span> orders<br><span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(amount) <span class="hljs-keyword">from</span> orders);<br></code></pre></td></tr></table></figure><p>子查询常用的场景有两个： 通过 WHERE IN</p><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><ol><li>必须是两条或者两条以上select语句</li><li>每个select语句必须包含相同的列,表达式或者汇集函数.</li><li>列数据类型必须兼容</li></ol><!-- end list --><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> vend_id, prod_id, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-operator">&lt;=</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> vend_id, prod_id, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">1001</span>, <span class="hljs-number">1002</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> vend_id, prod_price;<br></code></pre></td></tr></table></figure><h2 id="INSERT-增"><a href="#INSERT-增" class="headerlink" title="INSERT(增)"></a>INSERT(增)</h2><ul><li><p>插入一条记录,省略列名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">INSERT INTO 表名  VALUES(val1, val2 ...)<br></code></pre></td></tr></table></figure></li><li><p>插入一条记录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">INSERT INTO 表名 (列1，列2 ...) VALUES (val1, val2 ...)<br></code></pre></td></tr></table></figure></li><li><p>插入多条记录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">INSERT INTO 表名 (列1，列2 ...)  VALUES (val1, val2 ...), (val1, val2 ...)<br></code></pre></td></tr></table></figure></li></ul><h2 id="DELETE-删"><a href="#DELETE-删" class="headerlink" title="DELETE(删)"></a>DELETE(删)</h2><ul><li>delete from 表名称 where 列名称&#x3D;值</li><li>delete from 表名称 (删除所有行，但是保留表)</li><li>delete * from 表名称 (删除所有行，但是保留表)</li><li>truncate table 表名 (删除所有行,效率更高)</li></ul><h2 id="UPDATE-改"><a href="#UPDATE-改" class="headerlink" title="UPDATE(改)"></a>UPDATE(改)</h2><p>更新数据表某一列或者多列(<strong>特别要注意where子句</strong>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">UPDATE 表名 SET 列名=新值  WHERE 列名=某值<br></code></pre></td></tr></table></figure><h2 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h2><p>创建表,基本语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs example">create  table  表名<br>(<br>列名1   数据类型 [NULL | NOT NULL] [约束],<br>列名2   数据类型 [NULL | NOT NULL] [约束],<br>...<br>)<br></code></pre></td></tr></table></figure><p>尽量指定NULL或者NOT NULL, 一般约束是可选的</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>字符串类型</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>CHAR</td><td>1~255个字符长度的定长字符串,长度必须创建时指定</td></tr><tr><td>ENUM</td><td>枚举,值只能是预定义集合中的某一个</td></tr><tr><td>LONGTEXT</td><td></td></tr><tr><td>MEDIUMTEXT</td><td></td></tr><tr><td>SET</td><td>预定义集合中的0个或者多个串</td></tr><tr><td>TEXT</td><td>最长 64k 的变长字符串</td></tr><tr><td>TINYTEXT</td><td></td></tr><tr><td>VARCHAR</td><td>长度可变,最长不超过255个字节</td></tr></tbody></table><p>用的较多的就是: CHAR, VARCHAR, TEXT. 在sql语句中对于字符串值要用引号.</p></li><li><p>数值类型(如果确定为非负数,可以在类型前加 UNSIGNED)</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>BIT</td><td>位字段, 1~64位</td></tr><tr><td>BIGINT</td><td></td></tr><tr><td>BOOLEAN(或BOOL)</td><td>布尔(0或者1)</td></tr><tr><td>DECIMAL(或DEC)</td><td>精度可变的浮点</td></tr><tr><td>DOUBLE</td><td>双精度浮点</td></tr><tr><td>FLOAT</td><td>单精度浮点</td></tr><tr><td>INT(或INTEGER)</td><td>整数</td></tr><tr><td>MEDIUMINT</td><td></td></tr><tr><td>REAL</td><td></td></tr><tr><td>SMALLINT</td><td></td></tr></tbody></table><p>用的较多的就是: INT, BOOLEAN, DOUBLE, FLOAT. 在sql中数值类型不要加引号.</p></li><li><p>时间日期类型</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>DATE</td><td>日期,格式为: YYYY-MM-DD</td></tr><tr><td>TIME</td><td>格式为: HH:MM:SS</td></tr><tr><td>DATETIME</td><td>DATE和TIME的组合</td></tr><tr><td>TIMESTAMP</td><td>功能和DATETIME相同,但范围较小</td></tr><tr><td>YEAR</td><td>年份,2位数字则范围是: 1970~2069, 4为数字则范围:1901~2155</td></tr></tbody></table><p>用的较多的是 DATETIME, DATE, TIME这三个类型.</p></li><li><p>二进制类型</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>BLOB</td><td>64kb</td></tr><tr><td>MEDIUMBLOB</td><td>16mb</td></tr><tr><td>LONGBLOB</td><td>4GB</td></tr><tr><td>TINYBLOB</td><td>255个字节</td></tr></tbody></table><p>用的较多的就是: BLOB</p></li></ol><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li>NOT NULL: 应该紧挨着类型的后面.</li><li>PRIMARY KEY：主键，不用再指定unique。</li><li>UNIQUE：字段必须唯一, <strong>但是字段可以为NULL</strong>. 也就是说UNIQUE不会检查 NULL值.可<br>以指定多个字段,也就是说规定指定字段的组合必须唯一.</li><li>FOREIGN KEY:外键</li><li>CHECK：值范围，eg：check（Id&gt;0）.</li><li>DEFAULT: 默认值，default ‘yangyu’, <strong>MySQL不接受函数作为默认值</strong>.</li><li>AUTO_INCREMENT：通常对主键。</li></ul><h2 id="INDEX-索引"><a href="#INDEX-索引" class="headerlink" title="INDEX(索引)"></a>INDEX(索引)</h2><ul><li>创建索引：CREATE INDEX indexname ON tablename (column [ASC|DESC], …);</li><li>删除索引：DROP INDEX indexname ON tablename;</li></ul><h2 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h2><ul><li>删除表 : drop table 表名</li><li>删除数据库: drop database 数据库名</li></ul><!-- end list --><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">DROP DATABASE|INDEX|PROCEDURE|TABLE|TRIGGER|USER|VIEW itemname;<br></code></pre></td></tr></table></figure><h2 id="ALTER-修改表结构"><a href="#ALTER-修改表结构" class="headerlink" title="ALTER(修改表结构)"></a>ALTER(修改表结构)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs example">ALTER TABLE tablename<br>(<br>    ADD     column         datatype [NULL | NOT NULL] [CONSTRAINTS],<br>    CHANGE  column column  datatype [NULL | NOT NULL] [CONSTRAINTS],<br>    DROP    column,<br>    ...<br>);<br></code></pre></td></tr></table></figure><ul><li><p>增加列: alert table 表名 add 列名 数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> vendors<br><span class="hljs-keyword">ADD</span> vend_phone <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure></li><li><p>删除列: ALTER TABLE 表名 DROP column 列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> vendors<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> vend_phone;<br></code></pre></td></tr></table></figure></li><li><p>修改列: ALTER TABLE 表名 CHANGE COLUMN 列名 数据类型</p></li><li><p>定义外键:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> products<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> fk_products_vendors<br><span class="hljs-keyword">FOREIGN</span> KEY(vend_id) <span class="hljs-keyword">REFERENCES</span> vendors(vend_id);<br></code></pre></td></tr></table></figure><p>从products.vend_id 到 vendors.vend_id的外键.</p></li></ul><h2 id="存储过程-MySQL-5-1"><a href="#存储过程-MySQL-5-1" class="headerlink" title="存储过程(MySQL 5.1)"></a>存储过程(MySQL 5.1)</h2><p>可以看做是SQl语言中的自定义函数. 也就是把一系列的 SQL 语句打包成一个自定义函 数,然后通过这个函数名来调用这一系列的SQL语句.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> ordertotal(<br>        <span class="hljs-keyword">IN</span> onumber <span class="hljs-type">INT</span>,<br>        <span class="hljs-keyword">IN</span> taxable <span class="hljs-type">BOOLEAN</span>,<br>        <span class="hljs-keyword">OUT</span> ototal <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">8</span>, <span class="hljs-number">2</span><br>) COMMENT <span class="hljs-string">&#x27;Obtain order total, optional adding tax&#x27;</span><br><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">-- declare variable for total</span><br>    <span class="hljs-keyword">DECLARE</span> total <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">-- declare tax percentage</span><br>    <span class="hljs-keyword">DECLARE</span> taxrate <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">-- Get the order toltal</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">Sum</span>(item_price<span class="hljs-operator">*</span>quantity)<br>    <span class="hljs-keyword">FROM</span> orderitems<br>    <span class="hljs-keyword">WHERE</span> order_num <span class="hljs-operator">=</span> onumber<br>    <span class="hljs-keyword">INTO</span> total;<br>    <span class="hljs-comment">-- Is this taxable?</span><br>    IF taxable <span class="hljs-keyword">THEN</span><br>        <span class="hljs-keyword">SELECT</span> total<span class="hljs-operator">+</span>(total<span class="hljs-operator">/</span><span class="hljs-number">100</span><span class="hljs-operator">*</span>taxrate) <span class="hljs-keyword">INTO</span> total<br>    <span class="hljs-keyword">END</span> IF;<br><br>    <span class="hljs-keyword">SELECT</span> total <span class="hljs-keyword">INTO</span> otatol;<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><p>IN 代表输入参数, OUT代表输出参数.</p><p>调用存储过程(参数要以 @ 开头):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> ordertotal(<span class="hljs-number">20005</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">@total</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@total</span>;<br></code></pre></td></tr></table></figure><h2 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h2><p>MySQL的 <code>MySAIM</code> 存储引擎不支持事务, <code>InnoDB</code> 支持事务, MySQL5.5的默认引擎是 InnoDB.</p><p>为了保证数据库数据在逻辑上的一致性,有一些操作应该打包执行,也就是说这些SQL语<br>句要么全部执行成功,要么一条都不执行,不能出现一部分执行成功,而另外一部分执行<br>失败的情况.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> orderitems <span class="hljs-keyword">WHERE</span> order_num <span class="hljs-operator">=</span> <span class="hljs-number">20010</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> order_num <span class="hljs-operator">=</span> <span class="hljs-number">20010</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>在 <code>START TRANSACTION</code> 与 <code>COMMIT</code> 之间的 SQL 语句被打包成一个事务.</p><h2 id="从文件创建数据表"><a href="#从文件创建数据表" class="headerlink" title="从文件创建数据表"></a>从文件创建数据表</h2><ul><li>mysql –u -p root &lt; file.sql</li></ul><h1 id="数据库设计的三大范式："><a href="#数据库设计的三大范式：" class="headerlink" title="数据库设计的三大范式："></a>数据库设计的三大范式：</h1><ul><li>第一范式：字段不可分，</li><li>第二范式：有主键，非主键字段要依赖主键字段只要数据列里面的内容出现重复，就 意味着应该将表拆分，拆分形成的表必须用外键关联起来。</li><li>第三范式：非主键字段不能相互依赖，也就是说表中的每一列必须与主键直接相关而<br>不能间接相关。与主键没有直接关系的数据列必须清除（创建一个表来存放他们）。</li></ul><h1 id="数据库的常用模式"><a href="#数据库的常用模式" class="headerlink" title="数据库的常用模式"></a>数据库的常用模式</h1><h2 id="主扩展模式"><a href="#主扩展模式" class="headerlink" title="主扩展模式"></a>主扩展模式</h2><p>比如说公司有不同类型的员工，如设计师，程序员，PM等，那么可以先建一个员工表，<br>这个表存放所有类型的员工都有的属性，如姓名，性别，入职时间等等等，然后在设计<br>师一个表，程序员一个表，PM一个表，但是这些表都与员工表关联</p><h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>一张表的一条记录对应另一张表的多条记录。也就是一对多 eg：论坛的板块表与帖子表就是这种关系，而帖子表与回复表也是这种关系</p><h2 id="名值模式"><a href="#名值模式" class="headerlink" title="名值模式"></a>名值模式</h2><h2 id="多对多模式"><a href="#多对多模式" class="headerlink" title="多对多模式"></a>多对多模式</h2><p>一本书可以有多个作者，一个作者也可以写多本书，所以书目信息表与作者信息表就是<br>多对多关系，那么设计时通常是在加入一个关联表，也就是通过3个表来表示这种关系</p><h1 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h1><ol><li>LIKE 很慢, 所以一般情况下,最好使用 full text.</li><li>绝不要检索比需求多的数据, 所以不要使用 SELECT * 这样的语句.</li><li>如果where中有很多的 OR 条件, 那么使用 UNION将其分拆为多条 select 语句会看 到明显的性能改善.</li><li>在插入数据频繁的场景下, 应该删除外键, 在应用层面检查约束就可以了, 因为插入 频繁时,外键会明显降低性能.</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>sql</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C备忘</title>
    <link href="/notes/c-dev-skill/"/>
    <url>/notes/c-dev-skill/</url>
    
    <content type="html"><![CDATA[<h1 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h1><p>一个内存泄露的检查工具。</p><h1 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h1><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>安装debug的符号表, 先使用 <code>cat /proc/version_signature</code> 获得内核版本, 不要使 用 <code>uname -r</code>,<br>因为它有时候获得的内核版本不准, 然后去<a href="http://ddebs.ubuntu.com/pool/main/l/linux/">这里</a><br>下载相应的包, 比如 linux mint17内核版本是 Ubuntu 3.13.0-24.47-generic 3.13.9,<br>而且是64位机器,<br>那么就要下载linux-image-3.13.0-24-generic-dbgsym_3.13.0-24.47_amd64.ddeb这个<br>包, 接着使用 <code>sudo dpkg -i xx</code> 安装, 然后 <code>sudo apt-get install systemtap</code></p><h2 id="脚本语言相关"><a href="#脚本语言相关" class="headerlink" title="脚本语言相关"></a>脚本语言相关</h2><p>systemtap脚本的基本单元是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs example">probe   event &#123;statements&#125;<br></code></pre></td></tr></table></figure><p>基本规则就是一旦触发了event,那么就执行后面的statements, 脚本中可以有多条 probe,<br>statements又叫handler或者body.</p><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>event主要有这几类:</p><ol><li><p>syscall.XXX: 监听系统调用, 后面加上return就是监听系统调用返回,可以使用通 配符.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">probe syscall.open &#123; &#125;<br>probe syscall.open.return &#123; &#125;<br>probe syscall.* &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>vfs.XXX: 监听文件系统的事件</p></li><li><p>kernel.function(“function”): 监听内核函数, 比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example">probe kernel.function(&quot;sys_open&quot;) &#123; &#125;<br>probe kernel.function(&quot;sys_open&quot;).return &#123; &#125;<br><br>probe kernel.function(&quot;*@net/socket.c&quot;) &#123; &#125;<br>probe kernel.function(&quot;*@net/socket.c&quot;).return &#123; &#125;<br></code></pre></td></tr></table></figure><p>后两行会监听net中socket.c中所有函数的调用与返回.</p></li><li><p>kernel.trace(“tracepoint”):</p></li><li><p>module(“module”).function(“function”):　监听指定模块的指定函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">probe module(&quot;ext3&quot;).function(&quot;*&quot;) &#123; &#125;<br>probe module(&quot;ext3&quot;).function(&quot;*&quot;).return &#123; &#125;<br></code></pre></td></tr></table></figure></li><li><p>begin: systemtap启动时会触发, 如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs example">probe begin &#123;<br>    printf(&quot;hello world&quot;)<br>    exit()<br>&#125;<br></code></pre></td></tr></table></figure><p>启动时执行一次,打印hello world就退出</p></li><li><p>end: 结束时执行一次</p></li><li><p>time.xxx(): 定时器, 时间到了就会运行, xxx可以是s, ms, us, ns, hz, jiffies</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">probe timer.s(4) &#123;<br>  printf(&quot;hello world\n&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><p>每4秒打印hello world.</p></li></ol><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><h1 id="链接相关"><a href="#链接相关" class="headerlink" title="链接相关"></a>链接相关</h1><ol><li>ldd可以用来检查运行时的动态链接库错误,它可以提示你哪些库没有找到.</li></ol><h1 id="奇淫技巧"><a href="#奇淫技巧" class="headerlink" title="奇淫技巧"></a>奇淫技巧</h1><h2 id="0长度数组-GNU-C"><a href="#0长度数组-GNU-C" class="headerlink" title="0长度数组(GNU C)"></a>0长度数组(GNU C)</h2><p>看代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">str</span>&#123;</span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">0</span>];  <span class="hljs-comment">/* c99应该这样 char s[] */</span><br>&#125;;<br><span class="hljs-type">int</span> len = <span class="hljs-number">10</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">str</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> str) + (len+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>p-&gt;len = len;<br></code></pre></td></tr></table></figure><p>s实际上是不占空间的, 它可以h看作是一个占位符, p-&gt;s 会自动指向紧挨着结构体的 内存地址, 如果使用指针,不仅会多占用4字节的空间,<br>而且必须手动的给该指针赋值.注 意该特性是GNU C的扩展,C99可以用可变长度的数组,但是这有一些限制,比如不能对结<br>构体调用sizeof(因为长度无法确定).</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aa</span> &#123;</span><br>    <span class="hljs-type">int</span> lock;<br>    <span class="hljs-comment">/* other field */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aa</span> <span class="hljs-title">S</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">LOCK</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (__sync_lock_test_and_set(&amp;(S.lock),<span class="hljs-number">1</span>)) &#123;&#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">UNLOCK</span><span class="hljs-params">()</span> &#123;<br>    __sync_lock_release(&amp;(S.lock));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码实现了一个简单的同步机制, 利用GNU C的原子操作.这些原子操作只能对 int, long, long<br>long以及这些类型的无符号版本使用,</p><ol><li>原型: <code>type __sync_lock_test_and_set (type *ptr, type value, ...)</code>, 先获<br>得*ptr当前值,然后将ptr指向的值设为value</li><li>原型: <code>void __sync_lock_release (type *ptr, ...)</code>, 将*ptr设为0.</li></ol><p>完整的列表在<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html">这里</a></p><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><h2 id="EPOLL"><a href="#EPOLL" class="headerlink" title="EPOLL"></a>EPOLL</h2><ol><li>水平触发(LT): 如果内核通知应用层某一个文件描述符已经就绪，而如果应用层此后<br> 一直没有完整的处理该描述符（没有读取完相应的数据或者没有写入任何数据），那<br> 么内核会不断地通知应用层该文件描述符已经就绪。这就是所谓的水平触发：只要条<br> 件满足，那内核就会触发一个事件（只要文件描述符对应的数据没有被读取或者写入，那内核就不断地通知你）<strong>该模式用的多</strong></li><li>边沿触发(ET): 内核只是在文件描述符的状态发生变换的时候才进行通知。这就意味着在大多数情况下，当内核通知某个读描述符就绪 后，除非该读描述符内部缓冲区的所有数据已经完全被读取从而使得就绪状态发生了变化 否则内核不会发出任何新的通知，会永远沉默下去</li></ol><h2 id="hugepages"><a href="#hugepages" class="headerlink" title="hugepages"></a>hugepages</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">echo &quot;default_hugepagesz=1G hugepagesz=1G hugepages=4&quot; &gt; /etc/default/grub<br>sudo update-grub<br></code></pre></td></tr></table></figure><h1 id="Makefile相关"><a href="#Makefile相关" class="headerlink" title="Makefile相关"></a>Makefile相关</h1><p>make运行makefile分为两步</p><ol><li>扫描整个makefile，把所有的include的makefile都包含进来，进行必要的变量替换，接着生成依赖图</li><li>根据依赖图来执行动作</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>makefile中的变量和C里面的宏很类似，就是直接原样替换</p><ol><li><p>定义: 两种定义方法，一种可以使用后面定义的变量（&#x3D;），一种不可以(:&#x3D;)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">var = $(AA)aaaa<br>var := $(AA) bb<br></code></pre></td></tr></table></figure></li><li><p>变量的优先级是：</p><ul><li>命令行指定的变量优先级最高: 它会使makefile内部对同一变量的赋值无效，也就<br>是说只要命令行指定了，那么就以命令行为准，当然makefile中的变量使用了<br>override关键字，那么makefile中的赋值会覆盖命令行的定义。</li><li>makefile内部的赋值创建的变量其次</li><li>运行make时的环境变量：环境变量在命令行没有指定该变量时会成为该变量的默认<br>值,可以通过export，unexport来为makefile中运行的shell命令设置或者清除环境<br>变量。</li></ul></li></ol><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li>Reactor： 实际就是事件循环，libev，tornado都是这一类</li><li>Actor：万物都是actor，可以理解为一系列的轻量级进程，他们只能通过消息来通信，代表语言是erlang</li><li>CSP：一系列轻量级的进程，进程间通过channel来通信，等待channel的消息时，进程会 挂起，代表语言是go</li></ol><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><h2 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example">gdb prog                        # 1<br>gdb prog core                   # 2<br>gdb prog 1234                   # 3 (二者等价)<br>gdb -p 1234<br>gdb --args gcc -O2 -c foo.c     # 4<br></code></pre></td></tr></table></figure><ol><li>直接启动gdb调试prog</li><li>调试prog程序产生的core文件</li><li>调试一个正在运行的进程, 使用 <code>-p</code> 参数可以让你忽略prog。</li><li>使用–args将参数传递给要调试的程序</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>shell xxx：　执行shell命令， 比如 <code>shell ls</code> 就会显示当前目录的文件</li><li>help： 显示帮助</li><li>cd&#x2F;pwd: 改变&#x2F;打印当前的工作目录。</li><li>run(r)： 直接运行程序直到遇到第一个断点，如果没有断点，那么就运行到程序结 束</li><li>start: 和run的区别是该命令会停在main的入口处。。</li><li>dir： 添加一个目录到gdb的source path， 该路径是用来查找源文件的，比如调试<br>python时，如果你要进入python解释器的源码，那么你就要自己获得一份源码，同时<br>使用dir命令将源码位置添加到source path。</li></ol><h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><h3 id="调试python"><a href="#调试python" class="headerlink" title="调试python"></a>调试python</h3><ol><li>获得一份python源码</li><li>使用如下命令 <code>gdb -ex r --args python test.py</code> 运行脚本</li><li>使用dir命令将源码位置添加到source path： <code>dir /path/to/source/Python</code> 注<br>意我们添加的目录是源码顶层目录下的python子目录。</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>lang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑</title>
    <link href="/notes/logic/"/>
    <url>/notes/logic/</url>
    
    <content type="html"><![CDATA[<h1 id="形式系统"><a href="#形式系统" class="headerlink" title="形式系统"></a>形式系统</h1><h2 id="concepts"><a href="#concepts" class="headerlink" title="concepts"></a>concepts</h2><h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>形式系统的一致性就是说系统没有矛盾,从语法上说, P 与 ¬ P 不能在系统中都可证, 从语义上说存在一种解释满足所有的定理,也就是说使定理为真(也就是真陈述), 如果至少有一个经解释后的定理是假陈述,那么形式系统就出现了不一致性. 上述的一致性实际是形式系统(带上解释)同外部世界的一致性, 但是还有一种内部一致性说的是 系统中的定理解释之后应该是相容的,这种情况下并不是说一定要定理是真陈述, 只要 这些陈述能相容就可以了。</p><p>一致性不单是形式系统的性质,它还依赖于对形式系统提出的解释, 有可能一种解释下 形式系统是不一致的, 而另一种解释下形式系统就是一致的, 同理,不一致性也不是任何形式系统的固有性质,有可能只是没有为形式系统找到好的解释。</p><p>假设集合A是形式系统的定理集, 集合B是外部系统中真陈述翻译成形式系统的wff后组 成的集合, 那么一致性会确保A是B的子集.<br>而完全性则确保B是A的子集, 所以如果一 个形式系统既是一致的又时完全的,那么集合A与集合B是相等的.</p><h3 id="Completeness"><a href="#Completeness" class="headerlink" title="Completeness"></a>Completeness</h3><p><strong>完全性</strong>: 所有真的(在某个想象的世界里)且可表示成系统的 wff 的陈述都是该形式 系统的定理.</p><p><strong>不完全性</strong>:形式系统的定理集之外有真陈述, 也就是说非定理集中存在至少一个 wff 被解释之后是真陈述</p><h3 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h3><p>如果 P 与 ¬ P 都不是形式系统的定理, 那么 P 就在该形式系统内是不可判定的</p><h3 id="Decision-procedure"><a href="#Decision-procedure" class="headerlink" title="Decision procedure"></a>Decision procedure</h3><p>形式系统判定过程用来确定一个 wff 是否是一个定理. 形式系统的公理必须拥有判定 过程, 也就是说你必须保证开始时是正确的.<br>一个形式系统可以没有判定过程. 一般 来说如果形式系统的推导规则只有加长规则, 那么该形式系统拥有判定过程.</p><p>集合的判定过程是用来确定一个元素是否属于一个集合, 如果一个集合拥有一个能行 的判定过程,那么该集合是可判定集合(decidable set)</p><h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><p>两个复杂结构之间不同部分可以相互映射, 那么这就是一种同构. 对于形式系统来说, 一般是给系统某种 <strong>解释</strong>, 这种情况下形式系统中的每一个符号都与一个词对应, 而 且从上层来说形式系统中的定理解释之后应该是真陈述. 比如pq系统, 可以这样解释:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs example">q     &lt;=&gt;    等于<br>p     &lt;=&gt;    加<br>-     &lt;=&gt;    1<br>--    &lt;=&gt;    2<br>---   &lt;=&gt;    3<br>      ...<br></code></pre></td></tr></table></figure><h3 id="递归-递归可枚举"><a href="#递归-递归可枚举" class="headerlink" title="递归, 递归可枚举"></a>递归, 递归可枚举</h3><p>二者的关系就像图形(正空间)和它的衬底(负空间).</p><ul><li>递归可枚举(r.e.): 又称为部分递归集, 任何形式系统的定理集都是递归可枚举集, 更一般的说,<br>该集合的元素都可以通过推理规则从起点(公理)生成出来.(正空间是 图形).</li><li>递归: 如果一个集合与它的补集都是递归可枚举的, 那么该集合是递归的(一幅画的 正空间与负空间都是图形 ).</li></ul><p>存在非递归的递归可枚举集</p><h3 id="logic-system"><a href="#logic-system" class="headerlink" title="logic system"></a>logic system</h3><p>一个形式系统外加一个语义, 也就是给形式系统中形式语言的句子赋予真值</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Formal systems in mathmatics consist of the following elements:</p><ol><li>A finite set of <strong>symbols</strong> (ie. the alphabet), that can be used to<br>construct formulas</li><li>A <strong>grammar</strong> which tells well-formed formulas(abbreviated <strong>wff</strong>)<br>are constructed out of the symbols in the alphabet, it is usually<br>required that there is a decision procedure for deciding whether a<br>formula is well formmed or not</li><li>A set of <strong>axioms</strong> or axiom schemate each axiom will be a wff.</li><li>A set of <strong>inference rules</strong>.</li></ol><p>规则2用来生成合式公式(良构公式), 规则3是公理,规则4用来推导系统中的定理. 要注 意这里说的定理和通常意义的定理不同.</p><h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><h3 id="pq形式系统"><a href="#pq形式系统" class="headerlink" title="pq形式系统"></a>pq形式系统</h3><ol><li><p>symbols: p, q, -</p></li><li><p>grammar: 一组短杠开头紧接着一个q, 又是一组短杠, 在接着是p, 最后以一组短杠 结尾, 该语法生成的字符串叫<br><strong>合式公式</strong> 也叫 <strong>良构串</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">str ::= SqSpS<br>S   ::= --*<br></code></pre></td></tr></table></figure></li><li><p>axiom schemate: 如果x仅由一组短杠组成,那么x-qxp- 是一个公理</p></li><li><p>inference rules: 如果x,y与z是只包含短杠的特定字符串,并且假设 xqypz 是一个 定理, 那么 x-qypz-<br>也是一个定理.</p></li></ol><h3 id="Propositon-logic"><a href="#Propositon-logic" class="headerlink" title="Propositon logic"></a>Propositon logic</h3><ol><li><p>symbols: (, ), ¬, ∧, ∨, →, ↔, A<sub>1</sub>, A<sub>2</sub>,…<br>A<sub>n</sub>.</p></li><li><p>grammar:</p><p>str ::&#x3D; A<sub>1</sub><br>      |&#x3D; A<sub>2</sub><br>    …<br>      |&#x3D; A<sub>n</sub><br>      |&#x3D; (str ∧ str)<br>      |&#x3D; (str ∨ str)<br>      |&#x3D; (¬ str)<br>      |&#x3D; (str → str)<br>      |&#x3D; (str ↔ str)</p></li><li><p>axiom: 没有公理</p></li><li><p>inference rules:</p><ul><li>如果 x 是定理的前提下可以推出 y 是定理, 那么 $x \rightarrow y$ 是定 理.(<strong>演绎定理</strong>).<br>这条规则不像其它规则一样, 它不需要依赖定理, 所以它没 有使用``如果xxx是定理,那么XXX是定理’’的句式,<br>所以它可以”凭空”造出定理, 这也是为什么它可以不需要公理. 比如:<br>$P \rightarrow \neg\neg P$ 根据上 述规则就是一个定理, 因为P为定理的前提下可以推出 ¬¬ P<br>是定理. 但 是要注意即便P不是定理的情况下, $P \rightarrow \neg\neg P$ 仍然是定理.</li><li><strong>分离规则</strong>: 如果 x 与 x → y 都是定理, 那么 y 是定理.</li><li><strong>联接规则</strong>: 如果x, y都是定理, 那么 $x \land y$ 也是定理</li><li><strong>分割规则</strong>: 如果 $x \land y$ 是定理, 那么x, y都是定理.</li><li><strong>双重否定规则</strong>: ¬¬ 可以被删除 (负负得正)</li><li><strong>易位规则</strong>: $x \rightarrow y$ 与 $\neg y \rightarrow \neg x$<br>是可互换的.</li><li><strong>德.摩根规则</strong>: $\neg x \land \neg y$ 与 $\neg(x \lor y)$ 是可互换的.</li><li><strong>思维陀螺规则</strong>: $x \lor y$ 与 $\neg x \rightarrow y$ 是可互换的</li></ul><p>可互换意味着二者重言等价.</p></li></ol><h3 id="数论系统"><a href="#数论系统" class="headerlink" title="数论系统"></a>数论系统</h3><ol><li><p>symbols: 0, S, &#x3D;, +, ×, ¬, ∧, ∨, ∀, ∃, a, a’, a’’ …</p></li><li><p>grammar:</p><p><strong>number</strong> ::&#x3D; 0<br>             &#x3D; S <strong>number</strong><br><strong>variable</strong> ::&#x3D; a, a’, a’’, …<br><strong>term</strong> ::&#x3D; <strong>variable</strong><br>             &#x3D; <strong>number</strong><br>             &#x3D; S <strong>term</strong><br>             &#x3D; <strong>term</strong> + <strong>term</strong><br>             &#x3D; <strong>term</strong>  × *term*<br><strong>atom</strong> ::&#x3D; <strong>term</strong> &#x3D; <strong>term</strong><br><strong>formula</strong> ::&#x3D; <strong>atom</strong><br>             &#x3D; ¬*formula*<br>             &#x3D; <strong>formula</strong> ∧ Formula<br>             &#x3D; <strong>formula</strong>  ∨ *formula*<br>             &#x3D; ∀ u: <strong>formula</strong> (u is a free variable of formula)<br>             &#x3D; ∃ u: <strong>formula</strong> (u is a free variable of formula)</p></li><li><p>axioms:</p><ol><li>∀ a: ¬ Sa &#x3D; 0</li><li>∀ a: (a + 0) &#x3D; a</li><li>∀ a: ∀ b: (a + Sb) &#x3D; S(a + b)</li><li>∀ a: (a × 0) &#x3D; 0</li><li>∀ a: ∀ b:(a × Sb) &#x3D; ((a × b) + a)</li></ol></li><li><p>inference rules: 命题演算中推理规则都是数论形式系统的规则, 除此之外,还有如下规则:</p><ol><li>特称规则: 如果 ∀ u: x 是一个定理, 那么x也是一个定理, 并且对x中 的u进行的任何替换都是定理(u是x中自由变量,<br>替换u的项不能包括已在x中量 化的变量, 这样会产生变量捕捉)</li><li>概括规则: 和特称规则相反</li><li>存在规则</li><li>等号规则<ul><li>如果 s&#x3D;r 是定理, 那么 r&#x3D;s 也是定理</li><li>如果 r&#x3D;s 与 s&#x3D;t 都是定理, 那么 r&#x3D;t 是定理</li></ul></li><li>后继规则<ul><li>如果 r&#x3D;t 是定理, 那么 Sr&#x3D;St 是定理</li><li>如果 Sr&#x3D;St是定理, 那么 r&#x3D;t 是定理</li></ul></li><li>归纳规则 如果 ∀ u:&lt;X{u} → X{Su&#x2F;u}&gt; 以及 X{u&#x2F;0} 都是定理, 那么 ∀ u: X{u}是定理.</li></ol></li></ol><h2 id="哥德尔不完全性定理"><a href="#哥德尔不完全性定理" class="headerlink" title="哥德尔不完全性定理"></a>哥德尔不完全性定理</h2><p>哥德尔的不完全性定理的证明实际就是构造一个类似说谎者悖论的公式<br>$$<br>     \begin{equation}<br>       \neg \ \exists a: \exists a’: \textrm{TNT-PROOF-PAIR}<br>{a, a’} \land \textrm{ARITHMOQUINE}{a’’, a’}<br>     \end{equation}<br>$$</p><h1 id="Propositon-logic-1"><a href="#Propositon-logic-1" class="headerlink" title="Propositon logic"></a>Propositon logic</h1><h2 id="concepts-1"><a href="#concepts-1" class="headerlink" title="concepts"></a>concepts</h2><ol><li>命题符号: $A_1, A_2, \dots A_n$ are propositon symbols</li><li>逻辑联接符: 命题逻辑中为 $\lnot, \lor, \land, \rightarrow, \leftrightarrow$</li><li>参数(非逻辑符号): 命题逻辑中,所有命题符号是参数, 参数的翻译是可变的</li><li>逻辑符号: 命题逻辑中, 命题联接符以及括号是逻辑符号, 它们的翻译是不变的.</li><li>well-formed formula(合式公式): 根据形式语言的语法规则生成的符号串</li><li>满足(satisfy): 一个真值指派 v 满足 $\varphi$ 当且仅当<br>$\overset{-}{v}(\varphi)&#x3D;T$, 也就是使得合式公式为真.</li><li><strong>紧致性定理</strong>: 如果 <em>Σ</em> 是合式公式的无限集合, 如果对于 <em>Σ</em> 的任意子集 $\Sigma_0$ 都存在一个真值指派满足 $\Sigma_0$ 的每一个公式, 那么存在一个真 值指派满足 <em>Σ</em> 中的所有公式.</li><li>形式语言: (1) 符号集. (2) 语法规则,用来生成wff. (3) 一种解释或翻译</li></ol><h2 id="形式语言"><a href="#形式语言" class="headerlink" title="形式语言"></a>形式语言</h2><h3 id="符号集"><a href="#符号集" class="headerlink" title="符号集"></a>符号集</h3><p>命题符号(A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>), 左右括号, 逻辑联接符(¬, ∧,<br>∨, →, ↔)</p><h3 id="语法规则-wff"><a href="#语法规则-wff" class="headerlink" title="语法规则(wff)"></a>语法规则(wff)</h3><p>语法规则是归纳定义的合式公式集的.</p><ol><li>every propositon symbol is well-formed formula</li><li>if <em>α</em> and <em>β</em> are well-formed formula, then $(\lnot \alpha),<br>  (\alpha \land \beta), (\alpha \lor \beta), (\alpha \rightarrow \beta),<br>  (\alpha \leftrightarrow \beta)$ are also well-formed formula.</li></ol><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>逻辑符号的解释是固定的:</p><ul><li>¬(非),</li><li>∧(且)</li><li>∨(或)</li><li>→(如果…那么)</li><li>↔(等价)</li></ul><p>参数也就是命题符号的解释是可变的,实际上可以说是任意的.</p><h2 id="真值指派"><a href="#真值指派" class="headerlink" title="真值指派"></a>真值指派</h2><ol><li>S 是一个命题符号集合,比如 {A<sub>1</sub>, A<sub>2</sub> …}</li><li>v 是一个真值指派,也就是说为 S 中的每一个命题符号指定一个真值.</li><li>$\overset{-}{S}$ 是由 S 中命题符号所组成的合式公式所组成的集合</li><li>$\overset{-}{v}$ 为 $\overset{-}{S}$ 中每一个合式公式指定一个真值.<br>$$<br>\begin{align}<br>v : S \rightarrow {T, F}   \<br>\overset{-}{v} :\overset{-}{S} \rightarrow {T, F}    \<br>\end{align}<br>$$<br>$\overset{-}v$ 的存在性可以由递归定理来证明, 因为5个逻辑联接符函数是自由生成 的, 所以必然可以将 v 由 S 扩展到<br>$\overset{-}S$</li></ol><table><thead><tr><th><em>α</em></th><th><em>β</em></th><th>($\lnot$ <em>α</em>)</th><th>(<em>α</em> ∧ <em>β</em>)</th><th>(<em>α</em> ∨ <em>β</em>)</th><th>(<em>α</em> → <em>β</em>)</th><th>(<em>α</em> ↔ <em>β</em>)</th></tr></thead><tbody><tr><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>F</td><td>T</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td></tr></tbody></table><ol><li>∨, ∧, $\lnot$ 或且非</li><li>→(imply, if..then…) 代表一个承诺, 以 A → B 为例 只 有A 为 T 且 B 为 F时A → B 才为F,<br>其它情况 A → B 都为 T.</li><li>↔ 可以认为是等价关系, 要 A ↔ B 为 T, 那么只有 A 与 B有相同的真值.</li></ol><h2 id="重言蕴含"><a href="#重言蕴含" class="headerlink" title="重言蕴含"></a>重言蕴含</h2><p><strong>definition</strong>: $\Sigma \vDash \tau$ 当且仅当满足 <em>Σ</em> 中每个合式公式的指派 也满足 <em>τ</em> .</p><p>重言蕴含实际反应了一种直觉: 一个结论可以有一些假设条件推出, 只有这些假设条件 都为真时, 结论才为真.</p><p>如果 <em>Σ</em> 是 ∅ 那么 $\vDash \tau$ 意味着任意真值指派都满足 <em>τ</em> 也 就是说 <em>τ</em> 恒为真.此时 <em>τ</em> 也叫<br><strong>重言式</strong>.</p><p>如果 <em>Σ</em> 是包含一个元素<em>σ</em> 那么 ${\sigma }\vDash \tau$ 可以写作<br>$\sigma \vDash \tau$, 如果 $\sigma \vDash \tau$ 且<br>$\tau \vDash \sigma$ ,那 么意味着<em>τ</em> 与 <em>σ</em>*重言等价* 记作:<br>$\sigma \vDash \Dashv \tau$. 这也意味着 $\sigma \leftrightarrow \tau$<br>是重言式.一般在进行合式公式化简时,就是将 一个公式转化为它的一个较简单的重言等价形式(因为重言等价意味这二者可以相互替 换).</p><p><strong>几个结论</strong>:</p><ol><li><p>重言蕴含的基本意义<br>$$<br>  \begin{equation*}<br>  \Sigma;\alpha \vDash \beta \quad \textrm{iff} \quad \Sigma \vDash (\alpha \rightarrow \beta)<br>\end{equation*}<br>$$</p></li><li><p><em>α</em>, <em>β</em> 是重言等价的 <strong>iff</strong> $\vDash (\alpha \leftrightarrow \beta)$</p></li><li><p>对于任意的合式公式B<br>$$<br>\begin{equation*}<br>  {A, \neg B} \vDash B<br>\end{equation*}<br>$$<br>上式实际就是 $A \rightarrow (\neg A) \rightarrow B$, 很显然是重言式.</p></li></ol><h3 id="典型的重言式"><a href="#典型的重言式" class="headerlink" title="典型的重言式"></a>典型的重言式</h3><ol><li><p>分配律<br>$$<br> \begin{align}<br>   (A \land (B \lor C))  \leftrightarrow (A \land B) \lor (A \land C) \<br>   (A \lor (B \land C))  \leftrightarrow (A \lor B) \land (A \lor C)<br> \end{align}<br>$$</p></li><li><p>否定<br>$$<br> \begin{align}<br>   &amp;(\neg \neg A) \leftrightarrow A  \<br>   &amp;\neg (A \rightarrow B) \leftrightarrow (A \land (\neg B)) \<br>   &amp;\neg (A \leftrightarrow B) \leftrightarrow (A \land (\neg B)) \lor (\neg A \land B)<br> \end{align}<br>$$</p></li><li><p>德.摩根<br>$$<br> \begin{align}<br>   (\neg (A \land B)) \leftrightarrow (\neg A) \lor (\neg B)  \<br>   (\neg (A \lor B)) \leftrightarrow (\neg A) \land (\neg B)<br> \end{align}<br>$$</p></li><li><p>其它<br>$$<br> \begin{align}<br>   &amp;(A \lor (\neg A))  \<br>   &amp;\neg(A \land (\neg A))  \<br>   &amp;(P \rightarrow Q) \leftrightarrow (\neg Q \rightarrow \neg P)   \<br>   &amp;((A \land B) \rightarrow C)  \leftrightarrow (A \rightarrow (B \rightarrow C))<br> \end{align}<br>$$<br>最后一个可以这样理解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example">if A &#123;<br>    if B&#123;<br>        C<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">if A and B&#123;<br>    C<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说A,B是条件, C是结论.</p></li></ol><h2 id="归纳与递归"><a href="#归纳与递归" class="headerlink" title="归纳与递归"></a>归纳与递归</h2><h3 id="concepts-2"><a href="#concepts-2" class="headerlink" title="concepts"></a>concepts</h3><ol><li><strong>自由生成</strong>: 称 C 是 B 在 f 与 g作用下自由生成的,当且仅当除满足生成条件外, f 和 g 在 C上的限制<br>f<sub>C</sub> g<sub>C</sub> 必须满足以下条件:<ol><li>f<sub>C</sub> 与 g<sub>C</sub> 是一对一的</li><li>f<sub>C</sub> 的值域, g<sub>C</sub> 的值域与 B 两两不相交</li></ol></li><li><strong>封闭的</strong>: 集合 S 在f与g的作用下是是封闭的当且仅当如果 x, y 是 S的元素,那 么f(x,y) 与 g(x) 也是<br>S的元素.</li><li><strong>归纳的</strong>: 如果 S 是归纳的, 那么S满足下面两条性质(B是包含一些基本元素的集合)<ul><li>$B \subseteq S$</li><li>S 在 f与g作用下封闭<br>但是要注意 <strong>一个归纳的集合包含的基本元素是可以比B中元素多的</strong>.这也是为什 么在 <strong>归纳定义</strong> 中要加入”最小”一词的原因.<br>举个例子B&#x3D;{0}, f(x)&#x3D;x+3, 很显 然{0, 3, 6, …..} 是归纳的, 但是{0, 1, 3, 4, 6, 7,<br>…}也是归纳的, 这个 集合你可以看出它的基本元素集合是{0, 1}, 这并不违反定义.</li></ul></li></ol><h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><p>归纳实际就是通过集合U的某些初始元素, 重复的运用几种运算, 可以构造U一个子集, 该子集是包含初始元素并且对运算闭合的最小集合.</p><ol><li><p><strong>自上而下定义</strong>: $C^*$ 是U的所有归纳子集的交集</p></li><li><p><strong>自下而上定义</strong>: 设 $C_*$ 是 B 中的元素经过有限次的使用 f 和 g 得到的所有 元素的集合,<br>临时定义一个构造序列是 U 中元素组成的有限序列 &lt;x<sub>1</sub>,<br>x<sub>2</sub>,…, x<sub>n</sub>&gt;, 那么对任意$i \leq n$ 它至少满足以下三个条件之一:<br>$$<br> \begin{align}<br>   &amp;x_i&amp; \in B          \<br>   &amp;x_i&amp; &#x3D;  f(x_j, x_k) \quad \textrm{j &lt; i and k &lt; i} \<br>   &amp;x_i&amp; &#x3D;  g(x_j)      \qquad \textrm{j &lt; i}<br> \end{align}<br>$$<br>$C_n$ 是所有长度为 n 的构造序列的最后一个元素组成的集合, 那么 $C_1&#x3D;B$,<br>$$<br> \begin{align}<br>   C_1 \subseteq C_2 \subseteq C_3 \subseteq …<br> \end{align}<br>$$</p><p>$C_* &#x3D; \bigcup_n C_n$</p><p>该定义实际说明了一个重要性质: <strong>归纳集合的每一个元素都可以由该元素之前的 一些元素来构造一个生成序列</strong></p><p>以自然数为例, U 是实数集, B&#x3D;{0}, S(x) &#x3D; x + 1</p><ul><li>长度为1的序列: &lt;0&gt; (C<sub>1</sub> &#x3D;{0})</li><li>长度为2的序列: &lt;0, 0&gt;, &lt;0, 1&gt; (C<sub>2</sub> &#x3D; {0 1})</li><li>长度为3的序列: &lt;0, 0, 0&gt;, &lt;0, 0, 1&gt;, &lt;0, 1, 1&gt;, &lt;0, 1, 2&gt;<br>(C<sub>3</sub> &#x3D; {0 1 2})</li></ul></li></ol><p>$C^* &#x3D; C_*$ 也就是说两种定义等价, 一般用 C 来代替二者.</p><p><strong>归纳法则</strong>: 假设C是由B中的元素通过 $\mathcal{F}$ 中的函数生成的, 若 S 是 C的 子集, S包含B且在<br>$\mathcal{F}$ 中函数的作用下是封闭的, 那么 C&#x3D;S.</p><p><strong>归纳法</strong>: 归纳法一般用来证明一个归纳定义的集合的每个元素都具有某个性质, 一 般的证明步骤是这样的:</p><ul><li>证明对于基本元素是满足该性质的</li><li>对于任意的元素a<sub>n</sub>, 那么必有一个构造序列&lt;a<sub>1</sub>, a<sub>2</sub>,…,<br>a<sub>n</sub>&gt;, 假设对于i&lt;n, 都有a<sub>i</sub> 满足该性质, 那么在这个前提下来证明<br>a<sub>n</sub> 也是满足该性质的.</li></ul><p>举个例子, C是由B中的元素通过f,g生成的, 证明 C 满足某种性质:</p><ol><li>证明 B 中的元素有该性质</li><li>对于任意的元素a<sub>n</sub>, 存在 a<sub>i</sub>, a<sub>j</sub>, 且<br>a<sub>n</sub> &#x3D; f(a<sub>i</sub>, a<sub>j</sub>), 由归纳假设a<sub>i</sub>,<br>a<sub>j</sub> 满足该性质, 那么证明 a<sub>n</sub> 也满足该性质</li><li>对于任意的元素a<sub>n</sub>, a<sub>n</sub> &#x3D; g(a<sub>i</sub>), 由归纳假设<br>a<sub>i</sub> 满足该性质, 那么证明 a<sub>n</sub> 也满足该性质.</li></ol><h3 id="递归定理"><a href="#递归定理" class="headerlink" title="递归定理"></a>递归定理</h3><p>U 的子集 C 是由 B 在 f 与 g上 <strong>自由生成</strong> 的, 其中:<br>$$<br>      \begin{align}<br>        f: &amp;U \times U&amp; \rightarrow U   \<br>        g: &amp;U&amp; \rightarrow U<br>      \end{align}<br>$$<br>V 是集合,函数 F, G 与 f 满足:<br>$$<br>      \begin{align}<br>        f: &amp;B&amp; \rightarrow V   \<br>        F: &amp;V \times V&amp; \rightarrow V \<br>        G: &amp;V&amp; \rightarrow V<br>      \end{align}<br>$$<br>那么存在唯一的函数<br>$$<br>      \begin{align}<br>        \overset{-}{h}: C \rightarrow V<br>      \end{align}<br>$$<br>使得:</p><ol><li>对 B 中的 x, $\overset{-}{h}(x) &#x3D; h(x)$</li><li>对 C 中 x 与 y:<br>$$<br> \begin{align}<br>   &amp;\overset{-}{h}(f(x,y)) &#x3D; F(\overset{-}{h}(x), \overset{-}{h}(y))   \<br>   &amp;\overset{-}{h}(g(x)) &#x3D; G(\overset{-}{h}(x))<br> \end{align}<br>$$<br>递归定理说明了, 如果 C 是自由生成的, 那么 B上的函数 $h$, 必定可以扩展到 C上的 函数 $\overset{-}h$</li></ol><p>直观的理解: 递归在本质上就是为了计算一个 <strong>大问题</strong> 的答案, 我可以先计算一个 <strong>小问题</strong> 的答案,<br>然后把小问题的答案组合成大问题的答案.</p><ol><li>为了计算 $\overset{-}{h}(f(x, y))$, 我们先计算 $\overset{-}{h}(x)$ 与<br>$\overset{-}{h}(y)$ 的答案, 然后通过 F 将这两个小问题的答案组合成大问题 的答案.</li><li>为了计算 $\overset{-}{h}(g(x))$, 我们先计算 $\overset{-}{h}(x)$, 然后通 过 G<br>将它组合成 大问题的答案.</li></ol><h2 id="命题联结词"><a href="#命题联结词" class="headerlink" title="命题联结词"></a>命题联结词</h2><p>每一个合式公式都可以看做是一个bool 函数, 比如合式公式 <em>α</em> 它有 n 个命题 符号, 那么就有一个 n 元 bool<br>函数与这个合式公式对应.</p><ol><li>$\lnot, \land$ 是完备的<br>$$<br> \begin{align}<br>   A \lor B            &amp;&#x3D;&amp; \lnot (\lnot A \land \lnot B)    \<br>   A \rightarrow B     &amp;&#x3D;&amp; \lnot(A \land \lnot B) &#x3D; \lnot A \lor B  \<br>   A \leftrightarrow B &amp;&#x3D;&amp; (A \land B) \lor (\lnot A \land \lnot B)<br> \end{align}<br>$$</li><li>$\lnot, \lor$ 是完备的</li><li>$\lnot, \rightarrow$ 是完备的<br>$$<br> \begin{align}<br>   A \land B &amp;&#x3D;&amp; \lnot(A \rightarrow \lnot B)\<br>   A \lor B  &amp;&#x3D;&amp; \lnot A \rightarrow B        \<br>   A \leftrightarrow B &amp;&#x3D;&amp; (A \rightarrow B) \land (B \rightarrow A)<br> \end{align}<br>$$</li></ol><h1 id="一阶逻辑"><a href="#一阶逻辑" class="headerlink" title="一阶逻辑"></a>一阶逻辑</h1><h2 id="concepts-3"><a href="#concepts-3" class="headerlink" title="concepts"></a>concepts</h2><ol><li><p>项: 常数符号与变量通过0次或者多次运算 $\mathcal{F}_f$ (由函数符号确定的构 造运算)<br>得到的集合.项是指语言中的名词和代词, 一般作为翻译后句子的主语, 如<br>果语言中没有函数符号,那么项就是所有常数和变量的集合.实际上项一般指代论域 中的一个元素.</p><p>数论形式系统中一般有后继函数(S), 加法(+), 乘法(×), 同时有常量零(0), 以及变量a’, a’’,a’’’…,<br>所以项就具有如下形式:</p><p>term ::&#x3D; 0<br>       &#x3D; a’, a’’, a’’’ …<br>       &#x3D; S term<br>       &#x3D; term + term<br>       &#x3D; term × term</p></li><li><p>原子公式: 没有使用逻辑联接符以及量词符号的合式公式, 原子公式相当于命题逻 辑中命题符号的作用.<br>$$<br>    \begin{equation*}<br>    Pt_1 t_2…t_n<br>    \end{equation*}<br>$$<br>其中P是 n元谓词符号, t<sub>n</sub> 是项</p><p>在数论系统一般只有一个谓词等于(&#x3D;), 所以原子公式有如下形式:</p><p>atom ::&#x3D; term &#x3D; term</p></li><li><p>合式公式(wff): 原子公式通过0次或者多次使用 $\xi_\lnot, \xi_\rightarrow, \mathcal{Q}_i$ 运算得到的表达式集合. 合式公式也包含原子公式.</p></li><li><p>自由变量: 和 lambda calculus的 free variable 类似, 量词(∀, ∃, etc) 就相当于lambda calculus中的 <em>λ</em> abstraction.<br>$$<br>\begin{align}<br>  \overset{-}{h}(\xi_\lnot(\alpha)) &amp;&#x3D;&amp; \overset{-}{h}(\alpha)  \<br>  \overset{-}{h}(\xi_\land(\alpha)) &amp;&#x3D;&amp; \overset{-}{h}(\alpha)  \<br>  \overset{-}{h}(\forall v_i \alpha) &amp;&#x3D;&amp; \overset{-}{h}(\alpha) &#x2F; { v_i }<br>\end{align}<br>$$</p></li><li><p>句子: 如果合式公式没有自由变量出现,那么该合式公式就是句子. 之所以叫做句子 是因为它解释后是一个完整的句子(包含主语).<br>句子是一个断言,所以它要么为真, 要么为假</p></li><li><p>谓词: 如果一个合式公式中包含至少一个自由变量,那么该合式公式解释后就是一个 谓词,也就是说是一个不带主语的句子,<br>或者它的主语是一个脱离了上下文的代词.就 像下面的句子:</p><p>“是一个不带主语的句子”<br>“会是一个反常现象”<br>“他是中国人”</p><p>第三个句子中”他”是一个代词, 但是这个代词脱离上下文, 所以你也无法弄清楚这 个代词指代的是什么,<br>这和没有主语是等效的.谓词表达的是一种性质. 所以谓词不 同于句子,<br>谓词是既不为真, 也不为假, 只有但当你实例化自由变量后, 才能确定 真假,对具体的事物,它可以具有该性质,也可以不具有.</p></li><li><p>模型(model): 如果 $\vDash_\mathfrak{A} \varphi$, 那么也就是说<br>$\mathfrak{A}$ 是 <strong>句子</strong> $\varphi$ 的模型. 注意只是句子, 也就说不能出现自 由变量,<br>如果$\mathfrak{A}$ 是句子集 <em>Σ</em> 的每一个句子的模型, 那么它也是 <em>Σ</em> 的模型</p></li><li><p>初等类(EC): K 是初等类当且仅当对某个句子 <em>τ</em>, K &#x3D; Mod <em>τ</em></p></li><li><p>广义初等类($EC_\vartriangle$): K 是广义初等类当且仅当对某个句子集 <em>Σ</em>, K &#x3D; Mod <em>Σ</em></p></li><li><p>形式证明(演绎): 从 <em>Σ</em> 到 <em>φ</em> 的一个 <strong>演绎</strong>,</p></li><li><p>假言推理: 从公式 $\alpha, \alpha \rightarrow \beta$ 可以推出 <em>β</em>.<br>$$<br>\begin{equation*}<br>   \frac{\alpha, \alpha \rightarrow \beta}{\beta}<br> \end{equation*}<br>$$</p></li><li><p>理论(theory): 逻辑蕴含意义下封闭的 <strong>句子</strong> 集合.<br>$$</p><div class="code-wrapper"><pre><code class="hljs">\begin&#123;equation*&#125;   T \vDash \sigma \rightarrow \sigma \in T \end&#123;equation*&#125;</code></pre></div><p>$$<br>注意仅仅指句子</p></li></ol><h2 id="形式语言-1"><a href="#形式语言-1" class="headerlink" title="形式语言"></a>形式语言</h2><h3 id="符号集-1"><a href="#符号集-1" class="headerlink" title="符号集"></a>符号集</h3><p>一阶语言的符号包括以下两类:</p><ul><li>逻辑符号<ol><li>括号: (, )</li><li>命题联结符($\lnot, \rightarrow$)</li><li>变量</li><li>等于符号(可选)</li></ol></li><li>参数(随语言的不同而不同)<ol><li>量词符号 $\forall$</li><li>谓词符号:对于每一个正整数n,有一个n元谓词符号集(可以为空集)</li><li>常数符号</li><li>函数符号</li></ol></li></ul><p>在定义一个一阶语言时, 首先就要指定符号集, 也就是该一阶语言有哪些谓词符号, 常数符号以及函数符号, 对任何一阶语言, 逻辑符号都是一样的.</p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><ol><li><p>项</p><p><strong>term</strong> ::&#x3D; <strong>variable</strong><br>             &#x3D; <strong>constant</strong><br>             &#x3D; F <strong>term</strong> (F 是一个函数符号)</p><p>包含变量, 常量, 以及函数符号应用于项得到的符号串</p></li><li><p>原子公式</p><p><strong>atom</strong> ::&#x3D; P term (P 是一个谓词符号)</p></li><li><p>合式公式</p><p><strong>formula</strong> ::&#x3D; <strong>atom</strong><br>             &#x3D; ¬*formula*<br>             &#x3D; <strong>formula</strong>  ∧ *formula*<br>             &#x3D; <strong>formula</strong>  ∨ *formula*<br>             &#x3D; ∀ u: <strong>formula</strong> (u is a free variable of formula)<br>             &#x3D; ∃ u: <strong>formula</strong> (u is a free variable of formula)</p><p>包含原子公式, 以及命题联接符和量词符号组合得到的符号串.</p></li></ol><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>一阶语言使用结构(structure)来给语言指定意义, 实际上一个一阶语言的结构就是该 语言的一种解释, 所以结构必须为 ∀, 函数, 谓词,<br>常量符号指定意义. 形式 上一个一阶语言的结构 $\mathfrak{A}$ 是一个函数,其定义域为参数的集合:</p><ol><li>$\mathfrak{A}$ 为全称量词 ∀ 指派一个非空集合 $|\mathfrak{A}|$, 称<br>为$\mathfrak{A}$ 的论域(universe)或者是定义域(domain)</li><li>$\mathfrak{A}$ 给每一个n元谓词符号指定一个n元关系 $P^\mathfrak{A}<br>  \subseteq |\mathfrak{A}|^n$</li><li>$\mathfrak{A}$ 为每一个常数符号指定论域 $|\mathfrak{A}|$ 中的一个元素<br>$c^\mathfrak{A}$</li><li>$\mathfrak{A}$ 为每一个n元函数符号 f 指派一个 $|\mathfrak{A}|$ 上的运算:<br>$f^\mathfrak{A}: |\mathfrak{A}|^n \rightarrow |\mathfrak{A}|$</li></ol><p>有了结构之后,那么我们就可以把一个句子翻译成外部系统的陈述(比如集合论的陈述), 然后在外部系统中检查该句子的真假,<br>比如定义一个一阶语言,该语言包含:</p><ul><li>等号</li><li>∈(二元谓词符号)</li></ul><p>定义一个结构,论域是所有集合, ∈ 是子集关系, 那么任何该语言的公式都可以通过 该结构翻译成集合论系统中的陈述,<br>我们可以在集合论中来判断该句子是不是正确的.</p><p>结构有时候可以非形式的写成一行,比如下面:<br>$$<br>      \begin{equation*}<br>        \mathfrak{A} &#x3D; (\mathbb{N}; \le, S, 0)<br>      \end{equation*}<br>$$<br>依次指定了论域, 谓词, 函数, 常数</p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><h3 id="满足"><a href="#满足" class="headerlink" title="满足"></a>满足</h3><ol><li>$\varphi$ 是语言中的合式公式</li><li>$\mathfrak{A}$ 是语言的结构</li><li>$s: V \rightarrow |\mathfrak{A}|$ 是从集合到论域的函数,实际就是给合式公<br>式中的变量指定一个论域中的元素,实际上该函数的主要作用是用来给自由变量指<br>定一个论域中元素,非自由变量不受该函数的影响.</li></ol><p>那么定义对于 $\mathfrak{A}$, s 满足 $\varphi$ 的含义(也就是使 $\varphi$ 为 真)是:<br>$$<br>      \begin{align}<br>        \vDash_\mathfrak{A} \varphi[s]<br>      \end{align}<br>$$<br>还有一种表示方法:<br>$$<br>      \begin{align}<br>        \vDash_\mathfrak{A} \varphi \lVert a_1, …, a_k\rVert<br>      \end{align}<br>$$</p><p>上面的意思是说 $\varphi$ 中自由出现的变量为 $v_1, …, v_k$, 那么为这些自由 变量依次指定论域中的元素为<br>$a_1, …, a_k$.</p><ol><li><p>项(term)</p><p>项一般代表代词或者名词,所以它应该映射到论域中的一个元素</p><p><code>s</code> 是一个变量到论域的函数(V 是变量的集合):<br>$$<br>   \begin{align}<br> s: V \rightarrow |\mathfrak{A}|<br>   \end{align}<br>$$<br>项可以如下定义:<br>$$<br>   \begin{align}<br> \overset{-}{s} : T \rightarrow |\mathfrak{A}|<br>   \end{align}<br>$$<br>$\overset{-}{s}$ 的递归定义如下:</p><ol><li>x 是变量,那么: $\overset{-}{s}(x) &#x3D; s(x)$</li><li>x 是常数符号, 那么: $\overset{-}{s} &#x3D; c^\mathfrak{A}$</li><li>如果 t<sub>1</sub>, t<sub>2</sub>… t<sub>n</sub> 是项,<br>f是一个n元函数符号,那么:<br>$$<br>  \begin{align}<br>\overset{-}{s}(f t_1t_2…t_n) &#x3D; f^\mathfrak{A}(\overset{-}{s}(t_1), \overset{-}{s}(t_2)…\overset{-}{s}(t_n))<br>  \end{align}<br>$$</li></ol></li><li><p>原子公式</p><p>原子公式是合式公式,所以它应该映射到 {T, F}</p><ol><li>对等于符号而言:<br>$$<br>  \begin{align}<br>\vDash_\mathfrak{A} \ &#x3D; t_1t_2[s] \quad \textrm{iff} \quad \overset{-}{s}(t_1)&#x3D;\overset{-}{s}(t_2)<br>  \end{align}<br>$$ </li><li>对n元谓词符号 P:<br>$$<br>  \begin{align}<br>\vDash_\mathfrak{A} Pt_1 … t_n[s]  \quad \textrm{iff} \quad \langle \overset{-}{s}(t_1) … \overset{-}{s}(t_n) \rangle \in P^\mathfrak{A}<br>  \end{align}<br>$$</li></ol></li><li><p>其它合式公式</p><ol><li><p>原子公式同上</p></li><li><p>对 $\lnot$ 逻辑符号<br>$$<br>  \begin{align}<br>\vDash_\mathfrak{A} \lnot \varphi[s] \quad \textrm{iff} \quad \nvDash_\mathfrak{A} \varphi[s]<br>  \end{align}<br>$$ </p></li><li><p>对 → 逻辑符号而言:<br>$$<br>      \begin{align}<br>\vDash_\mathfrak{A} (\varphi \rightarrow \psi)[s] \quad \textrm{iff} \quad \vDash_\mathfrak{A} \varphi[s] \ \rightarrow \ \vDash_\mathfrak{A}\psi[s]<br>  \end{align}<br>$$<br>也就是说, $\nvDash_\mathfrak{A} \varphi[s]$ 或者<br>$\vDash_\mathfrak{A}<br>  \varphi[s] \ \land \ \vDash_\mathfrak{A} \psi[s]$</p></li><li><p>对 ∀ 量词符号而言:<br>$$<br>  \begin{align}<br>\vDash_\mathfrak{A} \forall x \varphi[s] \quad \textrm{iff} \quad \forall d \in |\mathfrak{A}|(\vDash_\mathfrak{A} \varphi[s(x|d)])<br>  \end{align}<br>$$<br>s(x|d) 是一个函数, 它在x点取值d, 在其它地方取值与s相同,其定义如下:</p><p>$$<br>  \begin{align}<br>s (x|d)(y) &#x3D; \left{<br>    \begin{array}{ll}<br>    d    &amp; \textrm{if y&#x3D;x} \<br>    s(y) &amp; \textrm{if y \ne x}<br>    \end{array}<br>\right.<br>  \end{align}<br>$$</p></li></ol></li></ol><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><ol><li>$\forall x \in X. P(x)$ 等价于<br>$\forall x(x \in X \rightarrow P(x))$</li><li>$\exists x \in X. P(x)$ 等价于 $\exists x(x \in X \land P(x))$</li><li>$\neg \alpha \land \beta$ 等价于 $((\neg \alpha) \land \beta)$</li><li>$\forall x \alpha \rightarrow \beta$ 等价于 $((\forall x \alpha)<br>  \rightarrow \beta)$</li><li>$\neg \alpha \land \beta \rightarrow \gamma$ 等价于<br>$((\neg \alpha) \land<br>  \beta) \rightarrow \gamma$</li><li>$\alpha \rightarrow \beta \rightarrow \gamma$ 等价于<br>$(\alpha \rightarrow<br>  (\beta \rightarrow \gamma))$</li></ol><p>去掉括号时要记住: ∀, ¬ 的优先级是最高的, 相同的联接符是右结合的.</p><h3 id="一阶语言的例子"><a href="#一阶语言的例子" class="headerlink" title="一阶语言的例子"></a>一阶语言的例子</h3><ul><li><p>某个类中每个对象都有某种属性:<br>$$<br>   \begin{align}<br> \forall v(_ \rightarrow _)<br>   \end{align}<br>$$</p></li><li><p>某个类中某些对象有某个属性:<br>$$<br>   \begin{align}<br> \exists v(_ \land _)<br>   \end{align}<br>$$<br>假设A代表是”是苹果”, B代表”是烂的”, 那么:</p></li><li><p>$\forall x(Ax \rightarrow Bx)$: 所有的苹果都是烂的</p></li><li><p>$\exists x(Ax \land Bx)$ : 有一些苹果是烂的</p></li><li><p>$\forall x(Ax \land By)$ : 任何东西都是苹果并且是烂的(任何东西都是烂苹果).</p></li></ul><h2 id="逻辑蕴含"><a href="#逻辑蕴含" class="headerlink" title="逻辑蕴含"></a>逻辑蕴含</h2><p><strong>Definition</strong>: 设 <em>Γ</em> 是合式公式的集合, $\varphi$ 是一个合式公式,那么 <em>Γ</em> 逻辑蕴含<br>$\varphi$, 记作 $\Gamma \vDash \varphi$, 当且仅当对于语言每<br>一个结构$\mathfrak{A}$ 和每个函数 $s: V \rightarrow |\mathfrak{A}|$,<br>使得 $\mathfrak{A}$ 以 s 满足 <em>Γ</em> 的每一个元素, $\mathfrak{A}$ 也以 s 满足<br>$\varphi$.</p><h3 id="examples-1"><a href="#examples-1" class="headerlink" title="examples"></a>examples</h3><p>$$<br>      \begin{align}<br>        \forall v_1 Q v_1 \vDash Q v_2  \<br>        Qv_1 \nvDash \forall v_2 Q v_2   \<br>        \forall v_1 Q v_1 \vDash \exists v_2 Q v_2  \<br>        \exists x \forall y Pxy \vDash \forall y \exists x Pxy   \<br>        \forall y \exists x Pxy \nvDash \exists x \forall y Pxy<br>      \end{align}<br>$$</p><h3 id="几个结论"><a href="#几个结论" class="headerlink" title="几个结论"></a>几个结论</h3><p>逻辑蕴含($\Gamma \vDash \varphi$)实际上还是可以看做这种直觉: <em>Γ</em> 中的公 式是前提, 而<br>$\varphi$ 是结果, 只有满足了所有的前提条件, 结果才是可满足的</p><ol><li><p>一个重要的结论:<br>$$<br>\begin{align}<br> \Gamma;\alpha \vDash \varphi \quad \textrm{iff} \quad \Gamma \vDash (\alpha \rightarrow \varphi)<br>\end{align}<br>$$<br>这个结论也有这样的形式:<br>$$<br> \begin{align}<br>   {a_1, a_2, …, a_n} \vDash \varphi \quad \textrm{iff} \quad \vDash (a_1 \rightarrow a_2 \rightarrow … \rightarrow a_n)<br> \end{align}<br>$$<br>上述转换从直观角度不言而喻.</p></li><li><p>根据紧致性定理, 必存在<br>$$<br>\begin{align}<br>   {\gamma_1, \gamma_2, …, \gamma_n} \subseteq \Gamma<br> \end{align}<br>$$<br>使得如果 $\Gamma \vDash \varphi$, 那么:<br>$$<br> \begin{align}<br>   \vDash \gamma_1 \rightarrow \gamma_2 \rightarrow … \rightarrow \gamma_n \rightarrow \varphi<br> \end{align}<br>$$</p><h2 id="同态-homomorphism"><a href="#同态-homomorphism" class="headerlink" title="同态(homomorphism)"></a>同态(homomorphism)</h2></li></ol><p>从 $\mathfrak{A}$ 到 $\mathfrak{B}$ 的同态意味着两个结构间存在一个函数:<br>$h: |\mathfrak{A}| \rightarrow |\mathfrak{B}|$, 具有下列性质:</p><ol><li>对谓词<br>$$<br>\begin{align}<br>  \langle a_1, …, a_k\rangle \in P^\mathfrak{A} \quad \textrm{iff} \quad<br>  \langle h(a_1), …, h(a_k)\rangle \in P^\mathfrak{B}<br>\end{align}<br>$$</li><li>对函数<br>$$<br>\begin{align}<br>  h(f^\mathfrak{A}(a_1, …, a_k)) &#x3D; f^\mathfrak{B}(h(a_1), …, h(a_k)))<br>\end{align}<br>$$<br>也就是说,两个结构会保持相同的谓词以及函数关系, 如果 h 是一对一的, 那么二者是 <strong>同构</strong> 的.</li></ol><h2 id="演绎计算"><a href="#演绎计算" class="headerlink" title="演绎计算"></a>演绎计算</h2><p>有限集合 <em>Λ</em> 是公理集, 通过选定推理规则, 我们可以生成新的公式, 对于公式 集<em>Γ</em>, <em>Γ</em> 的 <strong>定理</strong> 是指<br>$\Gamma \cup \Lambda$ 中的公式通过有限次的推 理得到的公式. 如果 $\varphi$ 是 <em>Γ</em><br>的定理(记作$\Gamma \vdash \varphi$)</p><p><strong>Definition</strong>: 从 <em>Γ</em> 到 $\varphi$ 的一个 <strong>演绎</strong> 是一个有限的公式序列<br>$\langle a_0, …, a_n \rangle$, 使得 $a_n &#x3D; \varphi$, 且对每个<br>$k \le n$, 那么$a_k$ 二者必居其一:</p><ol><li>$a_k$ 在 $\Gamma \cup \Lambda$ 中.</li><li>$i &lt; k$ 并且 $j &lt; k$, $a_j &#x3D; a_i \rightarrow a_k$</li></ol><p>那么 $\varphi$ 是 <em>Γ</em> 的一个定理, 记作 $\Gamma \vdash \varphi$.</p><p>从上面的定义可以很容易看出, $\Gamma \cup \Lambda$ 中的每一个公式都是 <em>Γ</em> 的定理.</p><p><em>Γ</em> 的定理集是归纳定义的:</p><ul><li><em>Γ</em> 的定理集包含 $\Gamma \cup \Lambda$ 的所有合式公式</li><li><em>Γ</em> 的定理集在假言推理上闭合</li></ul><p>所以在证明<em>Γ</em> 的定理集满足某个性质时, 可以使用归纳法:</p><ul><li>如果 $\varphi \in \Gamma \cup \Lambda$ 时, 满足该性质(有时候也可以拆成两 步, 对 <em>Γ</em>,<br><em>Λ</em> 分别考虑)</li><li>如果 $\varphi$ 是由 $\psi, \psi \rightarrow \varphi$ 假言推理得到, 那么假 设<br>$\psi, \psi \rightarrow \varphi$ 满足该性质, 那么证明 $\varphi$ 也满足 该性质.</li></ul><h3 id="逻辑公理集"><a href="#逻辑公理集" class="headerlink" title="逻辑公理集"></a>逻辑公理集</h3><ol><li>重言式</li><li>$\forall x \alpha \rightarrow \alpha_t^x$ (t替换x, 要避免变量捕捉, 也就 是说<br><code>t</code> 不能包含 <em>α</em> 中已量化的变量)</li><li>$\forall x(\alpha \rightarrow \beta) \rightarrow (\forall x \alpha<br>  \rightarrow \forall x \beta)$</li><li>$\alpha \rightarrow \forall x \alpha$ (x 不是<em>α</em> 的自由变量)</li><li>$x &#x3D; x$</li><li>$(x &#x3D; y) \rightarrow (\alpha \rightarrow \alpha’)$ (a’是将a中x替换为y得<br>来的)</li></ol><p>从上面可以看出, 公理集是恒为真的.</p><p>注意这里的公理是逻辑推理的公理, 它对任何一阶语言都是一样的, 但是对于一个公 理化的数学理论, 该理论自身会有一些公理, 比如数论的公理化系统中就会有数个公理:<br>$$<br>      \begin{align}<br>        &amp;\forall x &amp; Sx \ne 0   \<br>        &amp;\forall x &amp; x + 0 &#x3D; x   \<br>        &amp;\forall x \forall y &amp; x + Sy &#x3D; S(x + y)<br>      \end{align}<br>$$<br>当然数论系统的公理不只上面3个, 这些理论自身的公理就放在 <em>Γ</em> 中.</p><h3 id="原理-定理"><a href="#原理-定理" class="headerlink" title="原理,定理"></a>原理,定理</h3><ol><li><p>$\vDash, \vdash$ 的关系<br>$$<br> \begin{align}<br>   \Gamma \vdash \varphi \quad \textrm{iff} \quad \Gamma \cup \Lambda \vDash \varphi<br> \end{align}<br>$$<br><strong>proof</strong>: 正向: 归纳法, 反向: 紧致性定理</p></li><li><p><strong>概化定理</strong>:如果 $\Gamma \vdash \varphi$ 且x不在 <em>Γ</em> 中任何公式中自由 出现, 那么<br>$\Gamma \vdash \forall x \varphi$</p></li><li><p><strong>演绎定理</strong>: 如果 $\Gamma;\gamma \vdash \varphi$ 那么<br>$\Gamma \vdash (\gamma \rightarrow \varphi)$ (逆定理也成立,<br>逆定理本质就是假言推理).</p></li><li><p><strong>归纳原理</strong>: 如果 S 是包含 $\Gamma \cup \Lambda$ 的集合, 并且在假言推理下 封闭, 那么 S 包含<br><em>Λ</em> 的所有定理.</p></li></ol><h2 id="一致性与完备性"><a href="#一致性与完备性" class="headerlink" title="一致性与完备性"></a>一致性与完备性</h2><ol><li>逻辑公理是恒为真的.</li><li>一致性: 如果 $\Gamma \vdash \varphi$ 那么 $\Gamma \vDash \varphi$ (一致性<br>要表明的是演绎计算会得到正确的结论)</li><li>完备性: 如果 $\Gamma \vDash \varphi$ 那么 $\Gamma \vdash \varphi$</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合论</title>
    <link href="/notes/set-theory/"/>
    <url>/notes/set-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="总体把握"><a href="#总体把握" class="headerlink" title="总体把握"></a>总体把握</h1><p>naive set theory（Cantor）&#x3D;&gt; 罗素悖论(Russell’s paradox) &#x3D;&gt;公理化集合论</p><h2 id="朴素集合论（直觉上）：康托儿创立"><a href="#朴素集合论（直觉上）：康托儿创立" class="headerlink" title="朴素集合论（直觉上）：康托儿创立"></a>朴素集合论（直觉上）：康托儿创立</h2><p>几个基本概念：</p><ol><li><p>基数（势）：可以理解为大小</p></li><li><p>一一对应：比较两个集合的大小时，如果两个集合能一一对应，那么这两 个集合基数相同或等势，均势</p></li><li><p>可数无穷大（可列无穷大）：如果一个集合和自然数集一一对应，那么这 个集合就是可数，或者可列的，因为可以像数数（1 2 3 …)<br>一样列出来,所以所有的非负偶数集都是可数的，而实数集是不 可数的（対角线法证明）</p></li><li><p><strong>対角线法</strong>：对于（0，1）之间的实数，先假设所有的实数都列出来了，那 么构造一个实数使它与上面的每一个数都不同就能推出矛盾，<br>够造的方法是使対角线上的数位不同。</p><p>假设 (0, 1) 之间的实数与自然数是一一对应,且对应函数为 <code>r</code>, 那么可以将这些 数列出来:</p><p>r(1): . <strong>1</strong> 4 1 5 9 2 6 5 3 …<br>r(2): . 3 <strong>3</strong> 3 3 3 3 3 3 3 …<br>r(3): . 7 1 <strong>8</strong> 2 8 1 8 2 8 …<br>r(4): . 4 1 4 <strong>2</strong> 1 3 5 6 2 …<br>r(5): . 5 0 0 0 <strong>0</strong> 0 0 0 0 …<br>   …</p><p>那么对角线上的数字为 1,3,8,2,0… 那么我现在把对角线上的数字都加1(如果是 9, 那么加1后结果取0)后构造一个实数,<br>这个实数 <code>d</code> 就是 0.24931…, 那么这 个实数有下列性质:</p><p>d 的第一位不同于 r(1) 的第一位<br>d 的第二位不同于 r(2) 的第二位<br>d 的第三位不同于 r(3) 的第三位<br>d 的第四位不同于 r(4) 的第四位<br>d 的第五位不同于 r(5) 的第五位<br>…</p><p>也就是说 d 不在 r 映射中, 因此(0,1)中的实数和自然数就不是一一对应.</p></li></ol><p>朴素集合论的问题：按照朴素集合论的观点，只要能够给出一个确切的条件P(x)，那么 就能定义一个集合(any collection definable is a set) {x|P(x)},但是事实上这是不成立的，罗素悖论就是一个例子，公理化集合论的好处通过一系列的公理可以推出哪些集合存在，哪些集合不存在，这样就可以避开那些悖论</p><h2 id="罗素悖论（理发师悖论）"><a href="#罗素悖论（理发师悖论）" class="headerlink" title="罗素悖论（理发师悖论）"></a>罗素悖论（理发师悖论）</h2><p><strong>通俗表述</strong>: 一个理发师声称给城里不刮胡子的人刮胡子，而且也只给这些不刮胡子的 人刮，那么理发师该不该给自己刮胡子。(any<br>collection definable is a set)</p><p><strong>数学表述</strong>: P表示所有不包含自身的集合的集合（也就是所有不自吞的集合所组成的集合），那么P是否属于自己呢（也就是P是否自吞呢）。这是一个悖论，因为如果P属于P，那么P是自吞的，而根据P的性质，P只包含不自吞的集合，所以最后 $P \rightarrow \lnot P, \lnot P \rightarrow P$.<br>$$<br>     \begin{equation}<br>       P &#x3D; {x| x \notin x }<br>     \end{equation}<br>$$</p><h1 id="公理化集合论"><a href="#公理化集合论" class="headerlink" title="公理化集合论"></a>公理化集合论</h1><p>不定义什么是集合，而是通过这些公理来推导确定某些集合是存在的,某些集合是不存在 的，这些公理都是小心设计，所以避开了罗素悖论。</p><h2 id="Extensionality-Axiom-外延公理"><a href="#Extensionality-Axiom-外延公理" class="headerlink" title="Extensionality Axiom(外延公理)"></a>Extensionality Axiom(外延公理)</h2><p>判断2个集合是否相等<br>$$<br>      \begin{equation}<br>        \forall A \forall B[\forall x(x \in A \iff x \in B) \Rightarrow A&#x3D;B]<br>      \end{equation}<br>$$</p><h2 id="Empty-Set-Axiom-空集公理"><a href="#Empty-Set-Axiom-空集公理" class="headerlink" title="Empty Set Axiom(空集公理)"></a>Empty Set Axiom(空集公理)</h2><p>存在一个唯一的空集<br>$$<br>     \begin{equation}<br>       \exists B \forall x \ x \notin B<br>     \end{equation}<br>$$<br>identical form:</p><h2 id="Pairing-Axiom-偶集公理"><a href="#Pairing-Axiom-偶集公理" class="headerlink" title="Pairing Axiom(偶集公理)"></a>Pairing Axiom(偶集公理)</h2><p>For any set u and v, {u, v} is the pair set whose only members are u and<br>v.</p><h2 id="Power-Set-Axiom-幂集公理"><a href="#Power-Set-Axiom-幂集公理" class="headerlink" title="Power Set Axiom(幂集公理)"></a>Power Set Axiom(幂集公理)</h2><p>对于任意集合A，存在一个集合B，恰好以A的一切子集为元素</p><p>some propertyies of Power set:</p><ol><li>$a \subseteq A \iff a \in \mathcal{P}A$</li></ol><h2 id="Union-Axiom-并集公理"><a href="#Union-Axiom-并集公理" class="headerlink" title="Union Axiom(并集公理)"></a>Union Axiom(并集公理)</h2><p>a ∪ c is the set whose member belong to a or c</p><p>the axiom above is the <strong>preliminary form</strong> of Union axiom.</p><p>$\bigcup A &#x3D; a1 \cup a2 \cup a3$ … (where A &#x3D; {a1, a2, a3 …}) for<br>example: $\bigcup {a, b, c, d} &#x3D; a \cup b \cup c \cup d$</p><p>extremely: $\bigcup \emptyset &#x3D; \emptyset$</p><h2 id="Subset-Axioms-子集公理"><a href="#Subset-Axioms-子集公理" class="headerlink" title="Subset Axioms(子集公理)"></a>Subset Axioms(子集公理)</h2><p>For each formula __ not containning B, the following is an axiom:</p><p>The reason why this axiom is called subset axiom is that whatever the<br>formula __ is, the set B is subset of c</p><p><strong>Theorem</strong>: there is no set to which every set belongs</p><p><strong>proof</strong>: if A is a set, we will construct a set not belonging to A</p><p>According to the subset axiom, if A is a set then B exists.and according<br>to the construction rule of B:</p><p>then if B ∈ A, we get $B \in B \iff B \notin B$, this is a<br>contradiction, so B ∉ A. (actually, beacause there is no set which<br>belongs to itself, so B &#x3D; A).</p><ol><li><p>Intersection(交集)</p><ul><li><p>∩</p></li><li><p>$\bigcap$</p><p>$\bigcap {a, b, c } &#x3D; a \cap b \cap c$</p></li></ul></li><li><p>(relative complement)差集</p><p>identical form:</p></li></ol><h2 id="Axiom-of-Choice"><a href="#Axiom-of-Choice" class="headerlink" title="Axiom of Choice"></a>Axiom of Choice</h2><ol><li><p>first form</p><p>For any relation R, there is a function $H \subseteq R$ with dom H<br>&#x3D; dom R.</p></li></ol><h2 id="Infinity-Axiom"><a href="#Infinity-Axiom" class="headerlink" title="Infinity Axiom"></a>Infinity Axiom</h2><p>There exists an inductice set</p><h1 id="Algebra-of-sets"><a href="#Algebra-of-sets" class="headerlink" title="Algebra of sets"></a>Algebra of sets</h1><h2 id="Commutative-laws"><a href="#Commutative-laws" class="headerlink" title="Commutative laws"></a>Commutative laws</h2><h2 id="Associative-laws"><a href="#Associative-laws" class="headerlink" title="Associative laws"></a>Associative laws</h2><h2 id="Distributive-laws"><a href="#Distributive-laws" class="headerlink" title="Distributive laws"></a>Distributive laws</h2><h2 id="De-Morgan’s-laws"><a href="#De-Morgan’s-laws" class="headerlink" title="De Morgan’s laws"></a>De Morgan’s laws</h2><h2 id="Identities-involving-∅"><a href="#Identities-involving-∅" class="headerlink" title="Identities involving ∅"></a>Identities involving ∅</h2><h2 id="some-properties"><a href="#some-properties" class="headerlink" title="some properties"></a>some properties</h2><h1 id="Relations-and-Functions"><a href="#Relations-and-Functions" class="headerlink" title="Relations and Functions"></a>Relations and Functions</h1><h2 id="ordered-pair"><a href="#ordered-pair" class="headerlink" title="ordered pair"></a>ordered pair</h2><p>Definition: $&lt;x, y&gt;$ is defined to be <code>&#123;&#123;x&#125;, &#123;x, y&#125;&#125;</code>.</p><p>Theorem: $&lt;x,y&gt; &#x3D; &lt;u,v&gt;$ iff x&#x3D;u and y&#x3D;v</p><p>Cartesian product(笛卡尔积): A × B &#x3D; {&lt;x,y&gt; | x ∈ A and y ∈ B}</p><p>Lemma: if x ∈ C and y ∈ C then &lt;x, y&gt; ∈ $\mathcal{PP}C$</p><p>if x ∈ A and y ∈ B then &lt;x, y&gt; ∈ $\mathcal{PP}(A \cup B)$</p><h2 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h2><p><strong>Definition</strong>: A relation is a set of ordered pairs.</p><p><strong>Definition</strong>: R is a relation, we define the domain of R(dom R),the<br>range of R(ran R) and the field of R(fld R) by:</p><ul><li>x ∈ dom R $\iff$ ∃ y &lt;x,y&gt; ∈ R</li><li>y ∈ ran R $\iff$ ∃ x &lt;x,y&gt; ∈ R</li><li>fld R &#x3D; dom R ∪ ran R</li></ul><p><strong>Lemma</strong>: If &lt;x,y&gt; ∈ A, then x and y belong to $\bigcup \bigcup A$</p><p>we say R is a relation on A, it means that R is a subset of (A × A)</p><h3 id="n-ary-relations"><a href="#n-ary-relations" class="headerlink" title="n-ary relations"></a>n-ary relations</h3><p>The N-ARY RELATIONS are defined similar to 3-ary and 4-ary relation.</p><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p><strong>Definition</strong>: a function is relation F such that for each x in dom F,<br>there is only one y such that xFy.</p><p><strong>partial function</strong>: if the function is X to Y, and some elements in X<br>are undefined, then it’s a partial function.</p><p><strong>(total) function</strong>: if the function is X to Y and all elements in X<br>are defined, then it is a total function.</p><p>we say that F is a function from A <strong>into</strong> B or map A <strong>into</strong><br>B(written: A ⟶ B), iff F is a function , dom F&#x3D;A and ran F ⊆ B. if ran<br>F&#x3D;B then we say F is a function from A <strong>onto</strong> B or map A <strong>onto</strong> B.</p><p><strong>Definition</strong>: A relation R is single-rooted, iff for each y in ran R,<br>there is only one x such that xRy.</p><p><strong>Definition</strong>:</p><h2 id="Equivalence-Relations"><a href="#Equivalence-Relations" class="headerlink" title="Equivalence Relations"></a>Equivalence Relations</h2><ol><li>R is <strong>reflexive</strong> on A, by which we mean that xRx for all x ∈ A</li><li>R is <strong>symmetric</strong> on A, by which we mean that whenever xRy, then<br>also yRx</li><li>R is <strong>transitive</strong> on A, by which we mean that whenever xRy and<br>yRz, then also xRz.</li></ol><p><strong>Definition</strong>: R is equivalence relation on A iff R is a <strong>binary</strong><br>relation on A that is <strong>relexive</strong> on A, <strong>symmetric</strong> and<br><strong>transitive</strong>.</p><p>if the relation R is symmetric and transitive, then R is flexive on (fld<br>R)</p><p><strong>proof</strong>: since R is symmetric so if xRy then yRx and since R is also<br>transitive so xRx</p><h2 id="Ordering-Relation"><a href="#Ordering-Relation" class="headerlink" title="Ordering Relation"></a>Ordering Relation</h2><p>顺序关系比如大于,小于(不包含小于等于, 大于等于).</p><p><strong>Definition</strong> Let A be any set. A linear ordering on A (also called a<br>total ordering on A) is a binary relation R on A (ie<br>$R \subseteq A \times A$) meeting the following two conditions:</p><ol><li><p>R is a transitive relation; ie whenever xRy and yRz, then xRz.</p></li><li><p>R satisfies trichotomy(三分法) on A, by which we mean that for any x<br>and y in A exactly one of the three alterlatives:</p><p>holds.</p></li></ol><h1 id="Natural-Number"><a href="#Natural-Number" class="headerlink" title="Natural Number"></a>Natural Number</h1><blockquote><p>There are, in general, two ways of introducing new objects for<br>mathematical study: the axiomatic approch and the constructive<br>approch.</p></blockquote><h2 id="concepts-and-conventions"><a href="#concepts-and-conventions" class="headerlink" title="concepts and conventions"></a>concepts and conventions</h2><ol><li><em>ω</em> : the set of natural number</li><li>transitive set: A set <code>A</code> is said to be transitive set iff</li></ol><h2 id="Inductive-Set"><a href="#Inductive-Set" class="headerlink" title="Inductive Set"></a>Inductive Set</h2><p>we construct natural number like this:</p><p>so the natural number has folllowing properties:</p><p><strong>Definition</strong>: for any set A, its successor $a^+$ is defined by</p><p>then:</p><p>A set is said to be inductive iff $\emptyset \in A$ and it is “closed<br>under successor”. ie</p><h2 id="Peano’s-Postulates-皮亚诺公理"><a href="#Peano’s-Postulates-皮亚诺公理" class="headerlink" title="Peano’s Postulates(皮亚诺公理)"></a>Peano’s Postulates(皮亚诺公理)</h2><p>皮亚诺公理是对自然数的公理化</p><h3 id="Peano-System"><a href="#Peano-System" class="headerlink" title="Peano System"></a>Peano System</h3><p>Peano System to be a triple $\langle N, S,e\rangle$ consisting of a<br>set N, a function $S:N \rightarrow N$, and a member $e \in N$ such<br>that the following three conditions are met:</p><ol><li>$e \notin ran\ S$</li><li>S is one-to-one</li><li>Any subset A of N that contains e and is closed under S equals N<br>itself.</li></ol><p><img src="/static/img/peano-system.png"></p><p>The condition $e \notin ran\ S$ rules out the loop in Fig 16a, and the<br>requirement that S be one-to-one rules out the system of Fig 16B.<br>Consequently any Peano system must look like Fig 16c.</p><p><strong>Theorem</strong>: if <em>σ</em> is defined by:</p><p>$\langle \omega, \sigma, 0 \rangle$ is a Peano system</p><h2 id="RECURSION-ON-ω"><a href="#RECURSION-ON-ω" class="headerlink" title="RECURSION ON ω"></a>RECURSION ON <em>ω</em></h2><p>let A be a set, a ∈ A and $F: A \rightarrow A$. Then there exists a<br>unique function $h: \omega \rightarrow A$ such that</p><p>and for every n in <em>ω</em>,</p><p><strong>Theorem</strong> Let $\langle N, S, e \rangle$ be a Peano system, Then<br>$\langle<br>   \omega, \sigma, 0 \rangle$ is isomorphic to<br>$\langle N, S, e\rangle$, ie., there is a function h mapping <em>ω</em><br>one-to-one onto N in a way that preserves that successor operation</p><p>and the zero element</p><p>Intuitively, this theorem implies that h(0)&#x3D;e, h(1)&#x3D;S(e), h(2)&#x3D;S(S(e)),<br>h(3)&#x3D;S(S(S(e))) …</p><h1 id="Cardinal-Number-and-Axiom-of-Choice"><a href="#Cardinal-Number-and-Axiom-of-Choice" class="headerlink" title="Cardinal Number and Axiom of Choice"></a>Cardinal Number and Axiom of Choice</h1><h2 id="EQUINUMEROSITY"><a href="#EQUINUMEROSITY" class="headerlink" title="EQUINUMEROSITY"></a>EQUINUMEROSITY</h2><p><strong>Definition</strong>: A set <code>A</code> is equinumerous to a set B(written<br>$A \approx B$) iff there is a one-to-one function from A onto B.</p><h2 id="FINITE-SET"><a href="#FINITE-SET" class="headerlink" title="FINITE SET"></a>FINITE SET</h2><p><strong>Definition</strong>: A set is <strong>finite</strong> iff it is equinumerous to some<br>natural nunmber. Otherwise it is infinite.</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/notes/linear-algebra/"/>
    <url>/notes/linear-algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h1><ol><li>V : Vector space</li><li>F : stands for either <strong>R</strong> or <strong>C</strong>.</li><li>R : Real numbers</li><li>C : Complex numbers</li></ol><h1 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h1><ol><li><p>线性关系(linear relation): 源于一个很朴素的想法,如果x,y是线性关系,那么x增大或者缩小n倍,那么<br>y也应该增大或缩小n倍, 如果x1对应于y1, x2对应于y2, 那么x1+x2对应于y1+y2, 用<br>数学语言表述就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs example">F(a * x1) = a * F(x1)   a是常数<br>F(x1 + x2) = F(x1) + F(x2)<br></code></pre></td></tr></table></figure></li><li><p>线性操作(linear operation): 对 y&#x3D;F(x) 而言, 我们可以这样看,x是输入, F是操 作, 将 F 作用与输入<br>x 上得到输出y, 如果F是线性操作,那么y与x就成线性关系. 很显然F应该是一个乘以常数的操作, 因为只有y&#x3D;ax时,<br>y与x才是线性关系.实际上我 们可以推广到多维的情况y&#x3D;a1x1+a2x2+a3x3, 那么y与(x1, x2,<br>x3)^T 是线性关系, 那 么(a1, a2, a3) 就是线性操作</p></li><li><p>相似矩阵<br>$$<br> \begin{equation*}<br>   T_1 &#x3D; P^{-1}T_2P<br> \end{equation*}<br>$$<br>相似矩阵描述的实际是同一个线性变换在不同的基下面的表示</p><p>T1是坐标系 I下的变换，而T2是坐标系P下面的变换, 依次将 $P,T2,P^{-1}$ 应用到A就会得到B。</p></li></ol><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><h2 id="高斯-若尔当消元法"><a href="#高斯-若尔当消元法" class="headerlink" title="高斯-若尔当消元法"></a>高斯-若尔当消元法</h2><p>$$<br>    \begin{equation*}<br>    \begin{bmatrix} A I \end{bmatrix}<br>    \rightarrow<br>    \begin{bmatrix}I A^{-1} \end{bmatrix}<br>    \end{equation*}<br>$$<br>通过高斯消元法来将A变换为I，这样就得到了A的逆。</p><h2 id="置换矩阵"><a href="#置换矩阵" class="headerlink" title="置换矩阵"></a>置换矩阵</h2><p>这些矩阵可以用来交换矩阵的行, 重要性质： $AA^T&#x3D;I$</p><h2 id="Ax-x3D-b-的解"><a href="#Ax-x3D-b-的解" class="headerlink" title="Ax&#x3D;b 的解"></a>Ax&#x3D;b 的解</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>$$<br>     \begin{equation*}<br>       x &#x3D; x_p + c_1x_1 + … + c_nx_n<br>     \end{equation*}<br>$$<br>变换为梯形矩阵，接着将所有的自由变量设为0，找到特解，接着再求 Ax&#x3D;0 的解，这 样就可以通过向量形式把所有的解都表示出来。</p><p>$x_p$ 是特解， $c_n$ 是任意实数， $x_n$ 是 $Ax&#x3D;0$ 的解</p><h3 id="解的个数"><a href="#解的个数" class="headerlink" title="解的个数"></a>解的个数</h3><p>A 是 m×n 的矩阵，且 A 的轶是 r，那么：</p><ol><li>m&#x3D;n&#x3D;r 则有一个解</li><li>r &#x3D; n &lt; m 则 0 个或者 1 个解, 因为高斯消元之后下面肯定有0行。实际就是方程 比未知数多。</li><li>r &#x3D; m &lt; n 则有无穷多个解, 高斯消元之后下面肯定没有0行,实际上是未知数比方程多。</li><li>r &lt; n 且 r &lt; m 则 0 个解或者无穷多个解</li></ol><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><h3 id="单元素"><a href="#单元素" class="headerlink" title="单元素"></a>单元素</h3><p>乘积的第i行第j个元素是A的第i行乘以B的第j行。<br>$$<br>    \begin{equation*}<br>    c_{ij} &#x3D; \sum_{k&#x3D;1}^k a_{ik}b_{kj}<br>    \end{equation*}<br>$$</p><h3 id="行的线性组合"><a href="#行的线性组合" class="headerlink" title="行的线性组合"></a>行的线性组合</h3><p>$$<br>      \begin{equation*}<br>        \begin{bmatrix} a_1 a_2 \dots a_n \end{bmatrix}<br>        \begin{bmatrix}<br>          R_1     \newline<br>          R_2     \newline<br>          \vdots  \newline<br>          R_n<br>        \end{bmatrix}<br>        &#x3D;<br>        \begin{bmatrix}<br>          a_1R_1 \newline<br>          +      \newline<br>          a_2R_2 \newline<br>          +      \newline<br>          \vdots \newline<br>          a_nR_n<br>        \end{bmatrix}<br>      \end{equation*}<br>$$</p><p>所以对于 AB&#x3D;C 可以这样理解： C的每一行都是A的对应行乘以B，所以A的第一行作为<br>系数对B的每一行做线性组合的得到C的第一行，其他的行依次类推</p><h3 id="列的线性组合"><a href="#列的线性组合" class="headerlink" title="列的线性组合"></a>列的线性组合</h3><p>$$<br>      \begin{equation*}<br>        \begin{bmatrix} C_1 C_2 \dots C_n \end{bmatrix}<br>        \begin{bmatrix}<br>          a_1    \newline<br>          a_2    \newline<br>          \vdots \newline<br>          a_n<br>        \end{bmatrix}<br>        &#x3D;<br>        \begin{bmatrix}a_1C_1 + a_2C_2 + \dots + a_nC_n \end{bmatrix}<br>      \end{equation*}<br>$$</p><p>所以对于 AB&#x3D;C 可以这样理解： C的每一列都是A乘以B的对应列，所以B的第一列作为<br>系数对A的每一列做线性组合的得到C的第一列，其他的列依次类推</p><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><p>可以从分块矩阵的角度理解矩阵乘法, 规则和单元素时很类似，也是行乘以列</p><p>$$<br>      \begin{equation*}<br>        \begin{bmatrix} A_{11} A_{12} \ A_{21} A_{22} \end{bmatrix}<br>        \begin{bmatrix} B_{11} \ B_{21} \end{bmatrix}<br>        &#x3D;<br>        \begin{bmatrix}A_{11}B_{11} + A_{12}B_{21} \ A_{21}B_{11} + A_{22}B_{21} \end{bmatrix}<br>      \end{equation*}<br>$$</p><h2 id="逆矩阵-非奇异矩阵"><a href="#逆矩阵-非奇异矩阵" class="headerlink" title="逆矩阵(非奇异矩阵)"></a>逆矩阵(非奇异矩阵)</h2><p>只有方阵才有逆矩阵，矩阵A可逆意味着矩阵的列向量是线性无关的</p><h1 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h1><p>向量空间($V$): 一个在 <strong>加法</strong> 以及 <strong>标量乘法</strong> 上 <strong>闭合</strong> 的集合。</p><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>向量空间满足以下性质:</p><ol><li>交换律: 对所有的 $ u, v \in V $ 都有 $u+v &#x3D; v+u$.</li><li>结合律: 对所有的 $u, v, w \in V$ 都有 $(u+v) + w &#x3D; u + (v+w)$</li><li>加法单位元: 存在一个元素 $0 \in V$, 使得对所有的 $v \in V$ 都有 $v+0&#x3D;v$</li><li>加法逆: 对所有的 $v \in V$, 都存在 $w \in V$ 使得 $v + w &#x3D; 0$.</li><li>乘法单位元: 对所有的 $v \in V$, 都有 $1v &#x3D; v$.</li><li>分配性质: 对所有的 $a, b \in F, u,v \in V$ 都有<br>$a(u+v) &#x3D; au+av, (a+b)u &#x3D; au + bu$</li></ol><h2 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h2><p>子空间($U$): $U$ 是 $V$ 的子空间, 那么意味着: $U \subseteq V$, 且在加法以及标<br>量乘法上闭合:</p><ol><li>$0 \in U$</li><li>if $u, v \in U$ then $u+v \in U$</li><li>if $a \in F, u \in U$ then $au \in U$</li></ol><h2 id="四个子空间"><a href="#四个子空间" class="headerlink" title="四个子空间"></a>四个子空间</h2><p>A时m×n的矩阵，那么则存在四个子空间：列空间($C(A)$), 行空间($C(A^T)$), 零空间 ($N(A)$),<br>左零空间($N(A^T)$). 它们有如下性质：</p><ol><li>列空间和左零空间正交，行空间和零空间正交，这从向量的乘积可以比较容易的得出</li><li>列空间与行空间的维数相同，都等于A的轶r</li><li>零空间的维数时 n-r</li><li>左零空间的维数时 m-r</li></ol><h1 id="正交"><a href="#正交" class="headerlink" title="正交"></a>正交</h1><h2 id="投影与最小二乘"><a href="#投影与最小二乘" class="headerlink" title="投影与最小二乘"></a>投影与最小二乘</h2><p>投影矩阵是下面的公式<br>$$<br>     \begin{equation*}<br>       P &#x3D; A(A^TA)^{-1}A^T<br>     \end{equation*}<br>$$<br>因为A很多时候是不可逆的比如A不是方阵，所以 $(A^TA)^{-1}$ 是不能进一步化简的， 如果A可逆，那么最终的结果就是<br>I,也就是说投影是它自身，这是符合几何上的直觉的.同 时上面的公式有一个前提就是 $A^TA$<br>必须是可逆的，可以证明只要A的列向量是线性无 关的，那么就是可逆的,证明如下：<br>$$<br>     \begin{align}<br>       (A^TA)x &#x3D; 0     \newline<br>       x^T(A^TA)x &#x3D; 0  \newline<br>       (Ax)^TAx &#x3D; 0    \newline<br>       Ax &#x3D; 0<br>     \end{align}<br>$$<br>证明的思路就是：一个矩阵可逆也就意味它的线性齐次方程组只有零解，最重要的一步是方程两边乘以 $x^T$</p><p>如果A的列向量是标准正交的,也就是说 $A^TA &#x3D; I$ ，那么<br>$$<br>     \begin{equation*}<br>       P &#x3D; AA^T<br>     \end{equation*}<br>$$</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="几何性质"><a href="#几何性质" class="headerlink" title="几何性质"></a>几何性质</h2><ol><li>二维时是2个矩阵列向量组成的平行四边形的面积</li><li>三维时是3个矩阵列向量组成的立方体的体积</li><li>高维你可以想象成某种高维体积</li></ol><p>很多行列式的性质都可以从几何上获得直观的解释。</p><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><ol><li><p>$det(I) &#x3D; 1$</p></li><li><p>交换两行，那么行列式的值变号</p></li><li><p>$$<br>  \begin{align}<br>\begin{vmatrix}<br>  ta &amp; tb  \newline<br>  c  &amp; d<br>\end{vmatrix}<br>&amp; &#x3D; &amp;<br>t<br>\begin{vmatrix}<br>  a &amp; b \newline<br>  c &amp; d<br>\end{vmatrix} \newline<br><br>\begin{vmatrix}<br>  a + a’ &amp; b+b’  \newline<br>  c &amp; d<br>\end{vmatrix}<br>&amp; &#x3D; &amp;<br>\begin{vmatrix}<br>  a &amp; b  \newline<br>  c &amp; d<br>\end{vmatrix}<br>+<br>\begin{vmatrix}<br>  a’ &amp; b’  \newline<br>  c &amp; d<br>\end{vmatrix}<br>  \end{align}<br>$$</p></li><li><p>三角矩阵行列式等于对角线上元素的乘积.</p></li><li><p>$det(AB)&#x3D;det(A)det(B)$</p></li><li><p>$det(A^T)&#x3D;det(A)$</p></li></ol><h2 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h2><ol><li>将矩阵行归约成梯形形式，主元的乘积就是行列式(三角矩阵的行列式等于对角线元素的 乘积),<br>如果交换了行，那么要添加适当的正负号.(<strong>计算机使用这种方法计算行列式</strong>)</li><li>n个项的加法($a_{1\alpha}, a_{2\beta}, a_{3\gamma}, … a_{n\omega}$),<br>从每 一行每一列中取一个元素,也就是说 $\alpha, \beta, \gamma … \omega$ 必须不一样。</li><li>代数余子式: 某一行(列) 的元素乘以其对应的代数余子式然后相加。<ul><li>余子式：$M_{ij}$ 是指去掉第i行以及第j列后的矩阵组成的行列式</li><li>代数余子式: $C_{ij} &#x3D; (-1)^{i+j}M_{ij}$</li></ul></li></ol><h2 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h2><p>1.逆矩阵： $A^{-1} &#x3D; \frac{1}{det(A)} C^T$ , 其中C是代数余子式组成的矩阵。</p><p>2.克拉默法则： 求解 $Ax&#x3D;b$.<br>   $$<br>     \begin{equation*}<br>       \begin{bmatrix}<br>         x_1    \newline<br>         x_2    \newline<br>         \vdots \newline<br>         x_n<br>       \end{bmatrix}<br>       &#x3D;<br>       \frac{1}{det(A)}<br>         \begin{bmatrix}<br>           det(B_1) \newline<br>           det(B_2) \newline<br>           \vdots   \newline<br>           det(B_n)<br>         \end{bmatrix}<br>     \end{equation*}<br>    $$<br>其中 $B_n$ 是A的第n列替换为b后得到的。</p><h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><p>特征值和特征向量只对方阵有意义，主要是用来简化计算的，通过将任意的向量向特征向量 的方向做分解可以大大的简化计算</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>$$<br>  \begin{equation*}<br>    Ax &#x3D; \lambda x<br>  \end{equation*}<br>$$<br>x就是特征向量,$\lambda$ 就是特征值, 他们可以使用下式来计算<br>$$<br>  \begin{equation*}<br>    det(A-\lambda I) &#x3D; 0<br>  \end{equation*}<br>$$<br>这个式子就是特征方程, 也就是说 $A-\lambda I$ 的列必须时线性相关的，那么如果A是一<br>个三角矩阵那么特征值就是A对角线上的元素。<br>$$<br>  \begin{align}<br>    AS &amp;&#x3D; S \Lambda           \newline<br>    A  &amp;&#x3D; S \Lambda S^{-1}     \newline<br>    A^n &amp;&#x3D; S \Lambda^n S^{-1}<br>  \end{align}<br>$$<br>$S$ 是$A$的特征向量组成的矩阵， $\Lambda$ 是特征值组成的对角矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css笔记</title>
    <link href="/notes/css/"/>
    <url>/notes/css/</url>
    
    <content type="html"><![CDATA[<h1 id="三种引用css的方法"><a href="#三种引用css的方法" class="headerlink" title="三种引用css的方法"></a>三种引用css的方法</h1><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 外部样式表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/static/css/your.css&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 内部样式表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 行内样式表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-size: 12px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>很多时候可能有多个css规则来指定一个元素的属性,这时需要从中选出一个优先级最 高的规则(<strong>不是后面的规则覆盖前面的规则</strong>).</p><ol><li>!important: 优先级最高,但不提倡使用, 如果都是或者都不是 !important 样式那 么检查规则2.</li><li>用style编写的规则(行内样式)总是优先于除1以外的其它规则, 如果都是或者都不 是行内样式那么检查规则3</li><li>具有id选择符的规则必定优先于没有id选择符的规则, 如果都有id选择符, 那么id 选择符数量多的优先级高,<br>如果id选择符的数量也相同那么比较规则4.</li><li>具有class选择符的规则必定优先于没有class选择符的规则. 如果都有class选择 符, 那么class 选择符数量多的优先级高,<br>如果class选择符的数量也相同那么比 较类型选择符和伪元素选择器.</li></ol><p>因此在确定一个元素的css规则时就是依次检查上述1, 2, 3, 4条规则, 选出优先级最 高的css规则应用于该元素.下面举一些例子:</p><ol><li>#content a 比 .dropdown a 的优先级高,因为前者有id选择符</li><li>#wrapper #content 比 #content .datepost 优先级高, 因为前者有两个id选择符.</li></ol><h1 id="css-selector"><a href="#css-selector" class="headerlink" title="css selector"></a>css selector</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;                 <span class="hljs-comment">/*tag selector*/</span><br><span class="hljs-selector-tag">body</span>, <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">ol</span> &#123;&#125;                 <span class="hljs-comment">/*body,ul,ol标签, 有逗号就意味着平等*/</span><br><br><span class="hljs-selector-id">#nav</span> &#123;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;&#125;         <span class="hljs-comment">/*id selector*/</span><br><span class="hljs-selector-class">.sidebar</span> &#123;<span class="hljs-attribute">font-family</span>:Times&#125;    <span class="hljs-comment">/*class selector*/</span><br><br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-id">#content</span> &#123;&#125;                       <span class="hljs-comment">/*id为content的h1标签*/</span><br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.blue</span>&#123;&#125;                           <span class="hljs-comment">/*class为blue的h1标签*/</span><br><br><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;<span class="hljs-attribute">text-decoration</span>: none;&#125;   <span class="hljs-comment">/*descendant selector*/</span><br><span class="hljs-selector-tag">li</span> &gt; <span class="hljs-selector-tag">a</span>&#123;<span class="hljs-attribute">text-decoration</span>: none;&#125;  <span class="hljs-comment">/*和li a 的区别是这个只选择直接子节点(ie6不支持)*/</span><br><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">font-weight</span>: bold;&#125;      <span class="hljs-comment">/*h1后面的第一个p节点(h1和p应该是平级的,也就是二者是兄弟节点)*/</span><br><span class="hljs-selector-tag">li</span> <span class="hljs-selector-id">#content</span>&#123;&#125;                   <span class="hljs-comment">/*li下所有id为content的标签*/</span><br><span class="hljs-selector-tag">li</span> <span class="hljs-selector-class">.blue</span>&#123;&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">color</span>: red&#125;             <span class="hljs-comment">/*pseudo-class selector*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123;<span class="hljs-attribute">color</span>: red&#125;           <span class="hljs-comment">/*attribute selector 所有有title属性的a节点,不支持ie6及以下浏览器*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>]</span> &#123;<span class="hljs-attribute">color</span>:red&#125; <span class="hljs-comment">/*所有href属性等于http://www.baidu.com的a节点*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href^=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>]</span>&#123;<span class="hljs-attribute">color</span>: red;&#125; <span class="hljs-comment">/*所有href属性以http://www.baidu.com开头的a节点*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href$=<span class="hljs-string">&quot;.pdf&quot;</span>]</span>&#123;<span class="hljs-attribute">color</span>: red;&#125; <span class="hljs-comment">/*所有指向pdf文档的a节点*/</span><br></code></pre></td></tr></table></figure><h2 id="伪类与伪对象"><a href="#伪类与伪对象" class="headerlink" title="伪类与伪对象"></a>伪类与伪对象</h2><p>伪类:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>:link</td><td>a链接未被访问时的样式</td></tr><tr><td>:hover</td><td>对象在鼠标移上时的样式</td></tr><tr><td>:active</td><td>对象被用户点击以及被点击释放时的样式</td></tr><tr><td>:visted</td><td>a 链接被访问后的样式</td></tr><tr><td>:focus</td><td>对象成为输入焦点时的样式</td></tr><tr><td>:first-child</td><td>对象的第一个子对象的样式</td></tr><tr><td>:first</td><td>对于页面第一页使用的样式</td></tr></tbody></table><p>标准伪对象:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>:after</td><td>设置对象之后的内容</td></tr><tr><td>:before</td><td>设置对象之前的内容</td></tr></tbody></table><h1 id="css-box"><a href="#css-box" class="headerlink" title="css box"></a>css box</h1><h2 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h2><p>css的盒子模型：</p><p><img src="/notes/css/static/img/css-box.png"></p><p><strong>注意当用width与height来设置块级元素的宽与高时,实际只是设置的content区域的宽 与高</strong>,<br>margin,border,padding都是不考虑在内,所以这个宽与高不是元素实际占用的 宽与高,<br>这也就是margin，border，padding三个属性的含义了,这三个属性都有4个值， 比如如下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">margin</span>:<span class="hljs-number">25px</span> <span class="hljs-number">50px</span> <span class="hljs-number">75px</span> <span class="hljs-number">100px</span>;<br><br><span class="hljs-attribute">margin-top</span>: <span class="hljs-number">25px</span>;<br><span class="hljs-attribute">margin-right</span>: <span class="hljs-number">50px</span>;<br><span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">75px</span>;<br><span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br></code></pre></td></tr></table></figure><p>上述两段代码等价，指定四个值则依次为：上： 25px，右：50px，下：75px，左：100px。(T-R-B-L)<br>如果指定两个值，那么第一个是上下，第二个为左右，比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> auto;<br></code></pre></td></tr></table></figure><p>那么上下是0px，左右会相等，也就是居中效果</p><h2 id="margin的负值"><a href="#margin的负值" class="headerlink" title="margin的负值"></a>margin的负值</h2><p>这三个属性只有margin可以为负值，padding与border都不可以为负值，几个概念：</p><ul><li>box的物理大小：包括border， padding，content，不考虑margin</li><li>box的实际大小：考虑margin</li><li>基准线：margin移动的基准线，<ol><li>top与left是以外元素(也就是紧邻的元素或者是父元素)为基准线，这两个值是<br>用来确定本元素相对于外元素的位置的，以top为例，大体可以认为<br><strong>margin-top&#x3D;本元素border-top的位置 - 外元素的下边界</strong> ，比如<br>margin-top&#x3D;10px，那么本元素的border-top的位置就会与外元素相隔10px，如<br>果margin-top&#x3D;-10px，那么本元素的border-top的位置就会和外元素相距-10px，<br>也就是说本元素的boerder-top在外元素下边界的上方，那么就意味着本元素和<br>外元素发生了重叠</li><li>right与bottom是以本元素作为基准线的，这两个值不会改变本元素的位置，但<br>它会改变紧邻的右边或者是下边的元素的位置，以right为例，可以认为<br><strong>margin-right &#x3D; 右边紧邻元素的左边界 - 本元素的border-right的位置</strong> ，<br>因此如果magin-right&#x3D;10px，那么右边元素就与本元素的border-right的位置<br>相距10px，视觉上就是右边的紧邻元素与本元素相距10px（不考虑右边元素的<br>margin），如果margin-right &#x3D; -10px，那么右边元素的边界就在本元素的<br>border-right的位置的左边，也就是说，右边元素与本元素发生了重叠</li><li>box 的实际大小 &#x3D; box 的物理大小 + 正的 margin， 也就是说负的margin值<br>是不改变box的大小的，因为负的margin会让本元素与紧邻的元素发生重叠</li><li>用更通俗的话来解释margin：如果margin为正值的时候，那么行为就和看到的 图片中的一样，这里只讨论为负值的情况：<ul><li>margin-top为负值，那么把本元素向上移动</li><li>margin-left为负值，那么把本元素向左移动，比如在实现选项卡时，使用<br>margin-left：-1px，可以避免显示两条边界</li><li>margin-right为负值，那么将紧邻的右边元素向左移动</li><li>margin-bottom为负值，那么把紧邻的下边元素向上移动</li></ul></li></ol></li></ul><h2 id="框类型"><a href="#框类型" class="headerlink" title="框类型"></a>框类型</h2><p>网页中的任何元素都可以看作是在某种框中, 框的类型有:</p><ol><li>块框: 块级元素, 比如 p,div, h1~h6, ul 默认创建块框.</li><li>行内框: 行内元素, 比如 a, img, span, strong 默认创建行内框.</li></ol><p>可以通过display属性来修改框类型, 比如对 <code>a</code> 使用 <code>display:block</code> 就可以把它 变成一个块框.</p><p>行内元素显示为一个 <strong>行内框</strong> , 而页面中的一行文本可以看做是一个 <strong>行框</strong>, 多个* 行内框* 包含在一个 <strong>行框</strong> 之中,<br>可以设置 <strong>行内框</strong> 的左右margin, 左右border, 左右padding, 但是 <strong>设置上下 margin, padding<br>却不会影响行框的高度</strong>, 如果要设 置行内框的上下padding, margin同时又要自动改变行框的高度, 那么可以使用<br><code>display: inline-block</code>, 一般使用 line-height 来改变行框的高度. 行内框的上下 border可以设置,<br>这在有时候需要制作一些下划线效果时特别有用(text-decoration 可以设置删除线,下划线等等,但它的颜色不能设置,<br>而且只能用实线, 不灵活).</p><p><img src="/notes/css/static/img/inline-elements.png"></p><p>如果行框在一个浮动框的旁边, 那么行框会自动缩短来给浮动框留出空间.</p><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><ol><li>block: 块级元素, 默认一个元素占一行, 会产生块框</li><li>inline: 行内元素, 会产生行内框.</li><li>inline-block: 和 inline不同的是: 它如果设置了上下 padding, margin会自动 撑大行框的高度,<br>这在设计一些行内的按钮时特别有用, 和 block 不同的是 inline-block 元素不会另起一行.</li></ol><h2 id="上下margin叠加问题"><a href="#上下margin叠加问题" class="headerlink" title="上下margin叠加问题"></a>上下margin叠加问题</h2><p>关键点是: 如果两个 margin 上下紧挨着, 那么最终的margin 不是二者的和, 而是二 者中较大的一个,<br>也就是上下margin发生叠加, <strong>注意只在普通文档流有效,如果其中 任何一个元素使用了浮动, 绝对定位,<br>那么上下 margin不会叠加.</strong></p><ol><li><p>当两个对象是上下关系, 很显然上方对象的 margin-bottom 和下方对象的 margin-top 是紧挨着的,<br>那么最终的margin 是二者中较大的一个,而不是二者的 和.</p><p><img src="/notes/css/static/img/css-margin-bottom-top.png"></p><p>这是为了兼顾排版时第一个段落而做的设计，因为如果是和的话，那么第一个段落 的上边距和下面的段落会不一致.</p></li><li><p>当一个元素包含在另一个元素中时, 如果外部元素的上下padding, border设为0,<br>那么外部元素的margin就会和内部元素的margin上下紧邻,<br>因此也就会和内部元素 的margin发生叠加</p><p><img src="/notes/css/static/img/css-margin-top-top.png"></p><p>这种情形比较诡异, 因为会导致内部元素有时候会影响外部元素的行为. 比如如果 外部元素的 margin-top 为0,<br>内部元素的margin-top为20px, 那么最终外部元素 的 margin-top也会变成 20px.<br>这会使你应用在外部元素上的背景在那20px的 margin上无效, <strong>修复的主要方法是对外部元素使用<br>1px的padding或者border</strong>.</p></li></ol><h2 id="IE6-的左右margin加倍"><a href="#IE6-的左右margin加倍" class="headerlink" title="IE6 的左右margin加倍"></a>IE6 的左右margin加倍</h2><p>当盒对象浮动时,IE6自动将盒对象的左右margin加倍,可以使用 <code>display:inline</code> 来 消除这个影响. 因此如果要兼容ie6,<br>只要是浮动对象,那么都应该设置 <code>display:inline</code>.</p><h1 id="css定位"><a href="#css定位" class="headerlink" title="css定位"></a>css定位</h1><p>css有3中主要的定位方式: 普通文档流, 浮动, 绝对定位</p><h2 id="普通文档流"><a href="#普通文档流" class="headerlink" title="普通文档流"></a>普通文档流</h2><p>普通文档流中各个块级元素根据出现html中的位置由上到下排列.</p><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>绝对定位与相对定位(position属性)</p><ul><li><p>static: 默认的值</p></li><li><p>absolute:相对于父元素(top, left, right, bottom),绝对定位的元素离开文档流，<br>而飘在文档流的上方，注意绝对定位的父元素是这样确定的：在该元素的所有父元<br>素中查找，如果找到了设置position(只要不是static, 可以为absolute，relative，<br>fixed)的元素，那么这个元素就是绝对定位的父元素，如果没有找到那么就是html 的body元素是绝对定位的父元素,<br>absolute与float混用时,float会无效,也就是 float对绝对定位的元素无效果</p></li><li><p>relative: 相对于元素的原始位置而言,其原始占位信息依然存在，比如下面的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#div-1</span> &#123;<br>    <span class="hljs-attribute">position</span>:relative;<br>    <span class="hljs-attribute">top</span>:<span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">left</span>:-<span class="hljs-number">40px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么div-1就会相对于原位置向下偏移20px，向左偏移40px(注意负值), 相对定位,<br>如果添加float,那么元素先浮动,然后根据浮动得到的位置进行相对定位</p></li><li><p>fixed: 相对于浏览器窗口, 设置该值意味着不管如何滚动元素都会固定显示在浏览 器窗口的同一个位置, <strong>IE6不支持</strong>.</p></li><li><p>top, right, left, bottom: 这四个属性是用来确定元素的位置， <strong>注意top right left<br>bottom属性只对设置了position(absolute, relative, fixed)的对象有效</strong><br>这四个属性都可以设置负值，比如top &#x3D; -10px ，那么元素就是向上移动10px，如<br>果为正值就向下移动，其它的3个选项依次类推, <strong>这四个属性的默认值是元素本来 位置</strong>.</p></li></ul><h2 id="浮动定位"><a href="#浮动定位" class="headerlink" title="浮动定位"></a>浮动定位</h2><h3 id="浮动的基本原理"><a href="#浮动的基本原理" class="headerlink" title="浮动的基本原理"></a>浮动的基本原理</h3><p>html文档有一个标准文档流，每一个块级元素(如div, p)都要单独占一行[1]</p><p><img src="/notes/css/static/img/div-per-line.png"></p><p>如果给一个元素添加浮动，那么他就会脱离标准文档流，而悬浮于标准文档流之上:</p><p><img src="/notes/css/static/img/div-float-23.png"></p><p>这是给div2,div3添加左浮动后的效果，因为div2,div3添加了浮动，所以二者脱离<br>标准文档流，那么div4就会上移，因为div1没有浮动，所以div2在div1的下方（不<br>是div1的右方），div3浮动所以跟在div2的后面。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><ol><li><code>clear:left</code> 意思是本元素的左边不能有浮动元素</li><li><code>clear:right</code> 意思是本元素的右边不能有浮动元素</li><li><code>clear:both</code> 意思是本元素的左边, 右边都不能有浮动元素</li></ol><h3 id="浮动的注意事项"><a href="#浮动的注意事项" class="headerlink" title="浮动的注意事项"></a>浮动的注意事项</h3><ol><li><p>浮动元素是不占据空间的</p><p>如果一个 <strong>没有浮动的父元素</strong> 包含的所有子元素都是浮动的,那么这个父元素的实 际大小是 0,<br>而不是各个子元素大小的和(<strong>如果父元素也浮动了, 那么父元素的大小<br>是子元素的和</strong>), 直观上的印象就是父元素没有被子元素撑开, 所以如果要该父元素 包含浮动的子元素, 那么有四种解决方案:</p><ol><li><p>可以在父元素的最后添加:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> style=&quot;clear:both;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方案的缺点是要添加无意义的 html 元素.</p></li><li><p>可以使用after 伪对象(ie6不支持):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;.&quot;</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">visibility</span>: hidden;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">    <span class="hljs-attribute">clear</span>: both;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clearfix&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>after伪类会自动向元素的末尾添加content指定的内容, 然后通过设置 height, visibility<br>来将它隐藏,这么做的好处是不用在html中添加额外的空div, 但是 ie6支持不好.</p></li><li><p>将父元素浮动,但是这样会影响父元素下面的元素,所以可以给父元素下面的元素 添加 <code>clear:both</code>,<br>这种方法是兼容性较好的做法.</p></li><li><p>将父元素的 overflow 设为 hidden 或者 auto. 因为应用值为 hidden或者auto<br>的overlow元素会自动清理包含的浮动子元素, 但是设置overflow会改变元素的显<br>示方式,所以也不是任何时候都有效.</p></li></ol></li></ol><h1 id="css的常用属性"><a href="#css的常用属性" class="headerlink" title="css的常用属性"></a>css的常用属性</h1><h2 id="foreground-color"><a href="#foreground-color" class="headerlink" title="foreground color"></a>foreground color</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">50</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>背景实际是设置盒子模型的 content以及padding区域的背景(也就是border以内的 区域), 不影响<br>margin区域的背景,依次有以下几个属性:</p><ol><li>background-color: 背景颜色,使用十六进制或者rgb是最好的,不要使用颜色名, 也可以设置为transparent,<br>这是默认值,但是有时父元素设置了背景颜色, 那么 就可以用它来恢复透明.</li><li>background-image: 背景图片, 背景图片总是在背景颜色的上面.</li><li>background-repeat: 图片的平铺方式[repeat, no-repeat, repeat-x,<br>repeat-y],默认是repeat,也就是完全平铺</li><li>background-attachment: 背景图片的滚动方式[fixed, scroll], scroll是默认<br>值，也就是说默认如果背景图片在窗口的左上角，那么如何向下滚动页面，那么<br>该背景图片就会跟着左上角的内容消失，如果是fixed，那么背景图片无论你如<br>何滚动，都会在窗口的左上角,该属性较多的用于body的背景设置，其它元素基 本不用</li><li>background-position: 图片定位方式,分别为x与y坐标, x,y的值可以是left， right，<br>center，bottom,可以是百分比，也可是像素值，当你指定两个像素值 (x,<br>y)时，意思就是说，把背景图片的左上角移到(x,y)(注意浏览器文档左上角<br>的坐标为0,0)，x, y可以为负值, 比如: <code>background-position: -2px -49px</code><br>意思就是将背景图片向左移动2px, 向上移动49px,利用负值可以把多个背景图片<br>集合成一张图片,节省http请求次数,也使代码更容易管理(也就是所谓的 <strong>css Sprites</strong> ):</li></ol><!-- end list --><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#content</span> &#123;<br>    <span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">220</span>, <span class="hljs-number">220</span>, <span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;sample.png&#x27;</span>);<br>    <span class="hljs-attribute">background-repeat</span>:no-repeat;<br>    <span class="hljs-attribute">background-position</span>: <span class="hljs-number">20%</span> <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#content</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">220</span>, <span class="hljs-number">220</span>, <span class="hljs-number">220</span>) <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;sample.png&#x27;</span>) no-repeat <span class="hljs-number">20%</span> <span class="hljs-number">20px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以用background 来简写,简写时属性依次为: background: [color] [image] [repeat]<br>[attachment] [position]</p><h2 id="列表相关"><a href="#列表相关" class="headerlink" title="列表相关"></a>列表相关</h2><table><thead><tr><th>属性</th><th>说明</th><th>可能值</th></tr></thead><tbody><tr><td>list-style</td><td>简写</td><td></td></tr><tr><td>list-style-image</td><td>设置图片作为项目符号</td><td>[none, url]</td></tr><tr><td>list-style-position</td><td>项目符号的放置位置</td><td>[inside, outside]</td></tr><tr><td>list-style-type</td><td>设置项目符号的默认样式(圆圈, 罗马数等等)</td><td>[none, disc, circle…]</td></tr></tbody></table><h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><table><thead><tr><th>属性</th><th>描述</th><th>可用值</th></tr></thead><tbody><tr><td>font</td><td>缩写，[style, variant, weight, size, line-height, font-family]</td><td></td></tr><tr><td>color</td><td>字体颜色(前景色)</td><td>颜色(rgb或者十六进制值)</td></tr><tr><td>font-family</td><td>字体</td><td>字体名</td></tr><tr><td>font-size</td><td>字体大小，注意em是个相对单位，1.5em是相对于本行的其他文字大小的1.5倍，比使用px有优势，因为如果你修改了本行其它文字的大小，那么1.5em也会相应的变大</td><td></td></tr><tr><td>font-style</td><td>文字样式</td><td>[normal, italic, oblique]</td></tr><tr><td>font-weight</td><td>[bold, normal], 加粗与不加粗</td><td>[normal, bold, bolder, lighter…]</td></tr><tr><td>text-decoration</td><td>文本下划线, [none, overline(上划线),underline(下划线), line-through(删除线)]</td><td></td></tr></tbody></table><h2 id="段落样式"><a href="#段落样式" class="headerlink" title="段落样式"></a>段落样式</h2><ol><li>line-height： 行高 [normal, length], 因为 <code>line-height</code> 会 <strong>自动使文本垂<br>直居中</strong>, 所以有时用它来代替height与padding-top属性来实现垂直居中效果, 同 时 <strong>将<br><code>height</code> 与 <code>line-height</code> 设为相同值是好的做法</strong>.</li><li>text-indent: 对象中 <strong>首行文字的缩进</strong> [normal, length], 比如给一个 <code>a</code> 链<br>接设置一个背景icon, 那么就可以使用text-indent来使链接文本后移, 避免覆盖<br>到背景icon上,当然这种效果也可以用 padding-left来实现. <strong>text-indent 可以 为负值</strong>,<br>有时候为了让文本从屏幕上消失, 会将 text-indent 设置绝对值非常大 的负数, 比如 -1000em.</li><li>text-overflow：当对象中的文字超过对象宽度时可以设置省略号[clip, ellipsis], 只有设置了<br><code>word-break:keep-all</code> 才有效.</li><li>vertical-align: 对象中内容的垂直对齐的方式[middle, top, bottom…], 在设 计网站logo时,<br>有时需要图片与文本对齐, 这时可以使用 <code>vertical-align:     middle</code> 也就是中线对齐.</li><li>text-align: 对象中的文本的对齐方式[left, right, center, justify]</li><li>word-break: 当一个单词非常长以至于超过了对象的宽度时如何处理[normal, keep-all, break-all]</li><li>word-warp: 内容超过元素的宽度时，break-word会换行 [normal, break-word]</li><li>overflow: 如果内容超过了容器的宽高,如何显示.[visible,auto,hidden, scroll] <strong>如果设置为<br>hidden 或 auto 那么会自动的清理包含的任何浮动元素</strong>.</li></ol><h2 id="链接样式"><a href="#链接样式" class="headerlink" title="链接样式"></a>链接样式</h2><p>几个有用的伪类</p><ol><li>a:link 链接未访问时</li><li>a:visited 链接访问过时</li><li>a:hover 鼠标移到链接上时</li></ol><h1 id="表单设计"><a href="#表单设计" class="headerlink" title="表单设计"></a>表单设计</h1><h2 id="输入框-input-text"><a href="#输入框-input-text" class="headerlink" title="输入框(input text)"></a>输入框(input text)</h2><p>一般设置这样几个属性:</p><ol><li><code>line-height: normal</code>: 这样设置后,如果改变字体大小那么输入框的高度会跟着 改变.</li><li><code>font-size</code>: 设置为合适的大小</li><li><code>padding</code> : 6-10px 基本就够了</li><li><code>border</code>: 设置1px的border, 这样可以去掉默认的那个丑丑的阴影</li><li>设置宽度</li><li>使用css3 来设置阴影与圆角(自由发挥)</li></ol><h1 id="css编写的一些规则"><a href="#css编写的一些规则" class="headerlink" title="css编写的一些规则"></a>css编写的一些规则</h1><h2 id="id的使用场景"><a href="#id的使用场景" class="headerlink" title="id的使用场景"></a>id的使用场景</h2><ol><li>对页面进行布局时, 可以对每一个区域(div)定义一个 id, 这样可以使文档结构更 清楚.</li><li>样式只使用一次，比如logo</li><li>对网页中特定区域进行布局，比如header，sidebar等等</li></ol><h2 id="class的使用场景"><a href="#class的使用场景" class="headerlink" title="class的使用场景"></a>class的使用场景</h2><ol><li>同一页面多次使用</li><li>通用且经常使用的元素</li><li>多个class属性</li></ol><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ol><li>css大小写敏感，建议小写</li><li>命名时建议用 - 来分割多个单词</li><li>对于class可以使用适当的前缀，比如字体 f-， 按钮 btn-</li></ol><h1 id="html5与css3"><a href="#html5与css3" class="headerlink" title="html5与css3"></a>html5与css3</h1><h2 id="css3边框"><a href="#css3边框" class="headerlink" title="css3边框"></a>css3边框</h2><h3 id="border-radius-x3D-gt-圆角"><a href="#border-radius-x3D-gt-圆角" class="headerlink" title="border-radius &#x3D;&gt; 圆角"></a>border-radius &#x3D;&gt; 圆角</h3><p>border-radius是四个属性的简写(T-R-B-L),border-top-radius，right，bottom，left与之类似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>&#123;<br>    <span class="hljs-attribute">border</span>:<span class="hljs-number">2px</span> solid;<br>    <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">25px</span>;<br>    -moz-<span class="hljs-attribute">border-radius</span>:<span class="hljs-number">25px</span>; <span class="hljs-comment">/* Old Firefox */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加圆角</p><h3 id="box-shadow-x3D-gt-添加阴影"><a href="#box-shadow-x3D-gt-添加阴影" class="headerlink" title="box-shadow &#x3D;&gt; 添加阴影"></a>box-shadow &#x3D;&gt; 添加阴影</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#888888</span>;<br>-moz-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#888888</span>; <span class="hljs-comment">/* 老的 Firefox */</span><br></code></pre></td></tr></table></figure><p>第一个10px是水平阴影，第二个10px是垂直阴影，第三个5px是模糊距离，第四个是阴影颜色.</p><h3 id="border-image-x3D-gt-边框图片"><a href="#border-image-x3D-gt-边框图片" class="headerlink" title="border-image &#x3D;&gt; 边框图片"></a>border-image &#x3D;&gt; 边框图片</h3><p>border-image 是border-image-* 的简写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>&#123;<br>    <span class="hljs-attribute">border-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">border.png</span>) <span class="hljs-number">30</span> <span class="hljs-number">30</span> round;<br>    -moz-<span class="hljs-attribute">border-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">border.png</span>) <span class="hljs-number">30</span> <span class="hljs-number">30</span> round; <span class="hljs-comment">/* 老的 Firefox */</span><br>    -webkit-<span class="hljs-attribute">border-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">border.png</span>) <span class="hljs-number">30</span> <span class="hljs-number">30</span> round; <span class="hljs-comment">/* Safari 和 Chrome */</span><br>    -o-<span class="hljs-attribute">border-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">border.png</span>) <span class="hljs-number">30</span> <span class="hljs-number">30</span> round; <span class="hljs-comment">/* Opera */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="css3背景"><a href="#css3背景" class="headerlink" title="css3背景"></a>css3背景</h2><h2 id="css3文本效果"><a href="#css3文本效果" class="headerlink" title="css3文本效果"></a>css3文本效果</h2><h3 id="text-shadow-x3D-gt-文本阴影"><a href="#text-shadow-x3D-gt-文本阴影" class="headerlink" title="text-shadow &#x3D;&gt; 文本阴影"></a>text-shadow &#x3D;&gt; 文本阴影</h3><p>和box-shadow类似</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span><br>&#123;<br>    <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#FF0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="word-wrap-x3D-gt-可以对太长的单词进行换行"><a href="#word-wrap-x3D-gt-可以对太长的单词进行换行" class="headerlink" title="word-wrap &#x3D;&gt; 可以对太长的单词进行换行"></a>word-wrap &#x3D;&gt; 可以对太长的单词进行换行</h3><h2 id="transform-x3D-gt-2D，3D转换"><a href="#transform-x3D-gt-2D，3D转换" class="headerlink" title="transform &#x3D;&gt; 2D，3D转换"></a>transform &#x3D;&gt; 2D，3D转换</h2><ol><li><p>2d转换</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>matrix(a,b,c,d,tx,ty)</td><td>定义 2D 转换，使用六个值的矩阵。</td></tr><tr><td>translate(x, y)</td><td>定义 2D 转换，沿着 X 和 Y 轴移动元素。</td></tr><tr><td>translateX(n)</td><td>定义 2D 转换，沿着 X 轴移动元素。</td></tr><tr><td>translateY(n)</td><td>定义 2D 转换，沿着 Y 轴移动元素。</td></tr><tr><td>scale(x, y)</td><td>定义 2D 缩放转换，改变元素的宽度和高度。</td></tr><tr><td>scaleX(n)</td><td>定义 2D 缩放转换，改变元素的宽度。</td></tr><tr><td>scaleY(n)</td><td>定义 2D 缩放转换，改变元素的高度。</td></tr><tr><td>rotate(angle)</td><td>定义 2D 旋转，在参数中规定角度。</td></tr><tr><td>skew(x-angle,y-angle)</td><td>定义 2D 倾斜转换，沿着 X 和 Y 轴。</td></tr><tr><td>skewX(angle)</td><td>定义 2D 倾斜转换，沿着 X 轴。</td></tr><tr><td>skewY(angle)</td><td>定义 2D 倾斜转换，沿着 Y 轴。</td></tr></tbody></table><p>几个示例代码：</p><ol><li><p>matrix: 这个是所有2d变换的基础，其他的基本都可以用这个属性来实现，所以<br>其它的比如skew，translation都可以看作是matrix的简写，下面来讨论matrix<br>的原理：</p><p>transform的变换实际就是一次坐标变换，也就是待变换的元素中的每一个点 (x,y)都通过一个变换得到一个新的坐标(x1,<br>y1),然后该点就在(x1,y1)处显示 出来，所以关键就是(x, y) &#x3D;&gt; (x1, x2)的变换过程:</p><p>一个3×3的矩阵 乘以 3×1的矩阵结果是一个3×1的矩阵，所以:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">x2 = ax + by + tx<br>y2 = cx + dy + ty<br>1 = 1<br></code></pre></td></tr></table></figure><p>这就是(x, y) &#x3D;&gt; (x1, y1)的变换规则,如果a&#x3D;d&#x3D;1, b&#x3D;c&#x3D;0， 那么就变成了 translate(tx,<br>ty)</p></li><li><p>translate：根据坐标从当前位置移动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>);<br>    -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>);       <span class="hljs-comment">/* IE 9 */</span><br>    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>);   <span class="hljs-comment">/* Safari and Chrome */</span><br>    -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>);        <span class="hljs-comment">/* Opera */</span><br>    -moz-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>);      <span class="hljs-comment">/* Firefox */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>3d转换</p></li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>matrix3d(n1,n2,n3, … n16)</td><td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td></tr><tr><td>translate3d(x,y,z)</td><td>定义 3D 转化。</td></tr><tr><td>translateX(x)</td><td>定义 3D 转化，仅使用用于 X 轴的值。</td></tr><tr><td>translateY(y)</td><td>定义 3D 转化，仅使用用于 Y 轴的值。</td></tr><tr><td>translateZ(z)</td><td>定义 3D 转化，仅使用用于 Z 轴的值。</td></tr><tr><td>scale3d(x,y,z)</td><td>定义 3D 缩放转换。</td></tr><tr><td>scaleX(x)</td><td>定义 3D 缩放转换，通过给定一个 X 轴的值。</td></tr><tr><td>scaleY(y)</td><td>定义 3D 缩放转换，通过给定一个 Y 轴的值。</td></tr><tr><td>scaleZ(z)</td><td>定义 3D 缩放转换，通过给定一个 Z 轴的值。</td></tr><tr><td>rotate3d(x,y,z,angle)</td><td>定义 3D 旋转。</td></tr><tr><td>rotateX(angle)</td><td>定义沿 X 轴的 3D 旋转。</td></tr><tr><td>rotateY(angle)</td><td>定义沿 Y 轴的 3D 旋转。</td></tr><tr><td>rotateZ(angle)</td><td>定义沿 Z 轴的 3D 旋转。</td></tr><tr><td>perspective(n)</td><td>定义 3D 转换元素的透视视图。</td></tr></tbody></table><ol><li>matrix3d的规则也类似于matrix，只是这里是一个4×4的矩阵乘以一个4×1的矩阵结果是一个4×1的矩阵</li></ol><h2 id="transition-IE9及以下版本无效"><a href="#transition-IE9及以下版本无效" class="headerlink" title="transition (IE9及以下版本无效)"></a>transition (IE9及以下版本无效)</h2><p>不使用js的情况下，或者从一种样式变为另一种样式的动画效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">transition</span>: width <span class="hljs-number">2s</span>;<br>    -moz-<span class="hljs-attribute">transition</span>: width <span class="hljs-number">2s</span>;  <span class="hljs-comment">/* Firefox 4 */</span><br>    -webkit-<span class="hljs-attribute">transition</span>: width <span class="hljs-number">2s</span>;   <span class="hljs-comment">/* Safari 和 Chrome */</span><br>    -o-<span class="hljs-attribute">transition</span>: width <span class="hljs-number">2s</span>;    <span class="hljs-comment">/* Opera */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当宽度属性变化时就会有一个2s的动画</p><h1 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h1><ol><li><p>sass中可以嵌套的定义规则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* style.scss */</span><br><span class="hljs-selector-id">#navbar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">23px</span>;<br><br>    <span class="hljs-selector-tag">ul</span> &#123;<br>        <span class="hljs-attribute">list-style-type</span>: none;<br>    &#125;<br>    <span class="hljs-selector-tag">li</span> &#123;<br>        <span class="hljs-attribute">float</span>: left;<br>        <span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">font-weight</span>: bold; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* style.css */</span><br><span class="hljs-selector-id">#navbar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">23px</span>;<br>&#125;<br><span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">list-style-type</span>: none;<br>&#125;<br><span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>父引用: 用 &amp; 代替父选择子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* style.scss */</span><br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ce4dd6</span>;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffb3ff</span>; &#125;<br>    &amp;<span class="hljs-selector-pseudo">:visited</span> &#123; <span class="hljs-attribute">color</span>: <span class="hljs-number">#c458cb</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">/* style.css */</span><br><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ce4dd6</span>;<br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffb3ff</span>;<br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#c458cb</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>变量：$main-color: #ce4dd6;<br>该语句就定义了一个名为main_color的变量，引用时使用$main_color</p></li><li><p>插值：使用#($var)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* style.scss */</span><br>$side: top;<br>$radius: <span class="hljs-number">10px</span>;<br><br><span class="hljs-selector-class">.rounded-</span> &#123;<br>  <span class="hljs-attribute">border</span>-#&#123;$side&#125;-radius: $radius;<br>  -moz-<span class="hljs-attribute">border-radius</span>-#&#123;$side&#125;: $radius;<br>  -webkit-<span class="hljs-attribute">border</span>-#&#123;$side&#125;-radius: $radius;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>mixin: 可以看作是自定义函数，通过@include并且在函数名后跟上实参来进行调用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* style.scss */</span><br><span class="hljs-comment">/* $radius 指定了默认值10px */</span><br><span class="hljs-keyword">@mixin</span> rounded($side, $<span class="hljs-attribute">radius</span>: <span class="hljs-number">10px</span>) &#123;<br>  <span class="hljs-attribute">border</span>-#&#123;$side&#125;-radius: $radius;<br>  -moz-<span class="hljs-attribute">border-radius</span>-#&#123;$side&#125;: $radius;<br>  -webkit-<span class="hljs-attribute">border</span>-#&#123;$side&#125;-radius: $radius;<br>&#125;<br><br><span class="hljs-selector-id">#navbar</span> <span class="hljs-selector-tag">li</span> &#123; <span class="hljs-keyword">@include</span> rounded(top); &#125;<br><span class="hljs-selector-id">#footer</span> &#123; <span class="hljs-keyword">@include</span> rounded(top, <span class="hljs-number">5px</span>); &#125;<br><span class="hljs-selector-id">#sidebar</span> &#123; <span class="hljs-keyword">@include</span> rounded(left, <span class="hljs-number">8px</span>); &#125;<br><br></code></pre></td></tr></table></figure></li><li><p>@import:导入文件，注意被导入的文件应该命名为 partial_filename.sass, 这样导入的时候就用 @import<br>“filename” 为了支持sass与scss，在@import后不要指定后缀名</p></li></ol><!-- end list --><ol><li><a href="http://blog.jobbole.com/37112/">http://blog.jobbole.com/37112/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lang</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算理论</title>
    <link href="/notes/theory-of-computation/"/>
    <url>/notes/theory-of-computation/</url>
    
    <content type="html"><![CDATA[<h1 id="自动机理论"><a href="#自动机理论" class="headerlink" title="自动机理论"></a>自动机理论</h1><h2 id="正则语言"><a href="#正则语言" class="headerlink" title="正则语言"></a>正则语言</h2><h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><ul><li>DFA: 确定型有穷自动机</li><li>NFA: 非确定有穷自动机</li><li>正则语言：能被一个有穷自动机接受的语言就是正则语言</li><li>语言: 如果 <code>A</code> 是机器 <code>M</code> 所接受的所有字符串组成的集合,那么我们就说 <code>A</code> 是 机器 <code>M</code> 的语言.也可以写作<br>L(M)&#x3D;A 或者 M 识别 A.</li></ul><h3 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h3><ol><li><p>Definition</p><p>有穷自动机是一个五元组 $(Q, \Sigma, \delta, q_0, F)$:</p><ol><li>Q 是一个有穷集合,叫 <strong>状态集</strong>.</li><li>$\Sigma$ 是一个有穷集合,叫 <strong>字母表</strong>.</li><li>$\delta: Q \times \Sigma \rightarrow Q$ 是 <strong>转移函数</strong>.</li><li>$q_0 \in Q$ 是 <strong>起始状态</strong>.</li><li>$F \subseteq Q$ 是 <strong>接受状态</strong>.</li></ol></li><li><p>example</p><p>下面是一个叫 M<sub>1</sub> 的有穷自动机</p><p><img src="/notes/theory-of-computation/static/img/m1-finite-automaton.png"></p><p>形式定义如下:</p><ol><li><p>Q 是 {q<sub>1</sub>, q<sub>2</sub>, q<sub>3</sub>}</p></li><li><p>$\Sigma$ 是 {0, 1}</p></li><li><p>转移函数 $\delta$ 由下表给出:</p><table><thead><tr><th align="center"></th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">q<sub>1</sub></td><td align="center">q<sub>1</sub></td><td align="center">q<sub>2</sub></td></tr><tr><td align="center">q<sub>2</sub></td><td align="center">q<sub>3</sub></td><td align="center">q<sub>2</sub></td></tr><tr><td align="center">q<sub>3</sub></td><td align="center">q<sub>2</sub></td><td align="center">q<sub>2</sub></td></tr></tbody></table><p>transformation rules</p></li><li><p>q<sub>1</sub> 是起始状态</p></li><li><p>F &#x3D; |q<sub>2</sub>|</p></li></ol><p>下面是一个M1的程序:</p><figure class="highlight scheme"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">m1</span> ss)<br>  (<span class="hljs-name"><span class="hljs-built_in">define</span></span> tbl                     <span class="hljs-comment">;transformation rules</span><br>    &#x27;(((q1 . <span class="hljs-literal">#\0</span>) . q1) ((q1 . <span class="hljs-literal">#\1</span>) . q2)<br>      ((q2 . <span class="hljs-literal">#\0</span>) . q3) ((q2 . <span class="hljs-literal">#\1</span>) . q2)<br>      ((q3 . <span class="hljs-literal">#\0</span>) . q2) ((q3 . <span class="hljs-literal">#\1</span>) . q2)))<br>  (<span class="hljs-name"><span class="hljs-built_in">define</span></span> accepted-states<br>    &#x27;(q2))<br><br>  (<span class="hljs-name"><span class="hljs-built_in">define</span></span> m1-inner<br>    (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ([<span class="hljs-name">state</span> <span class="hljs-symbol">&#x27;q1</span>])<br>      (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (input)<br>        (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> [(<span class="hljs-name"><span class="hljs-built_in">assoc</span></span> `(,state . ,input) tbl) =&gt;<br>               (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (entry)<br>                 (<span class="hljs-name"><span class="hljs-built_in">set!</span></span> state (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> entry))<br>                 (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> entry))]<br>              [<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name">error</span> <span class="hljs-symbol">&#x27;Error</span> <span class="hljs-string">&quot;unkown state input pair ~a&quot;</span><br>                           `(,state ,input))]))))<br><br>  (<span class="hljs-name"><span class="hljs-built_in">let*</span></span> ([<span class="hljs-name">char-lst</span> (<span class="hljs-name"><span class="hljs-built_in">string-&gt;list</span></span> ss)]<br>         [<span class="hljs-name">ret</span> (<span class="hljs-name">last</span> (<span class="hljs-name"><span class="hljs-built_in">map</span></span> m1-inner char-lst))])<br>    (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">memv</span></span> ret accepted-states)<br>        <span class="hljs-symbol">&#x27;accept</span><br>        <span class="hljs-symbol">&#x27;reject</span>)))<br></code></pre></td></tr></table></figure><p>设M &#x3D; $(Q, \Sigma, \delta, q_0, F)$ 是一台有穷自动机, $\omega&#x3D;\omega_1<br>  \omega_2 … \omega_n$ 是字母表 $\Sigma$ 上的字符串,如果存在 Q 中的状态序列:<br>r<sub>0</sub>, r<sub>1</sub>, …, r<sub>n</sub> 满足下述条件:</p><ol><li>r<sub>0</sub> &#x3D; q<sub>0</sub></li><li>$\delta(r_i, \omega_{i+1})&#x3D;r_{i+1}, i&#x3D;0,1,2,…,n-1$</li><li>$r_n \in F$</li></ol><p>则 M 接受 $\omega$.</p></li><li><p>正则运算</p><p>设 A 与 B 是两个语言, 定义正则运算 <strong>并</strong> <strong>连接</strong> <strong>星号</strong>:</p><ul><li>union(并) : $A \cup B &#x3D; {x| x \in A  \ or \  x \in B }$</li><li>concatenation(连接):<br>$A \centerdot B &#x3D; {xy| x \in A \ and \ y \in B }$</li><li>star 星号:<br>$A^* &#x3D; {x_1 x_2 x_3 … x_k| k \geq 0 \ and \ \forall x_i \in A}$</li></ul></li><li><p>property</p><p>正则语言类是所有正则语言组成的集合</p><ol><li>正则语言类在 <strong>并</strong> 运算下封闭 (closure under union)</li><li>正则语言类在 <strong>连接</strong> 运算下封闭(closure under concatenation)</li></ol></li></ol><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ol><li>$(r)|(s)$ is a regular expression denoting the language $L(r) U L(s)$</li><li>(r)(S) is a regular expression denoting the language $L(r)L(s)$</li><li>$(r)<em>$ is a regular expression denoting the language $L(r)^</em>$</li><li>$(r)$ is a regular expression denoting the language $L(r)$</li></ol><p>some extensions:</p><ol><li>$(r)+$ is a regular expression denoting the language $L(r)+, r+ &#x3D; rr*$.</li><li>$(r)?$ (zero or one)</li><li>$[abcd]$ is shorthand of $a|b|c|d$</li></ol><h3 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h3><ol><li><p>DFA VS NFA</p><ul><li>DFA的每一个状态对于字母表中的每一个符号总是恰好有一个转移箭头射出,而NFA对<br>于每一个状态对于字母表字母表的每一个符号可能有0,1<br>或者多个箭头射出.</li><li>NFA中箭头的标号可以是 $\varepsilon$, 而DFA不允许.</li></ul><p><img src="/notes/theory-of-computation/static/img/n1-NFA.png"></p></li><li><p>definition</p><p>非确定型有穷自动机是一个五元组 $(Q, \Sigma, \delta, q_0, F)$:</p><ol><li>Q 是一个有穷集合,叫 <strong>状态集</strong>.</li><li>$\Sigma$ 是一个有穷集合,叫 <strong>字母表</strong>.</li><li>$\delta: Q \times \Sigma_\varepsilon \rightarrow \mathcal{P}(Q)$<br>是 <strong>转移函数</strong>.</li><li>$q_0 \in Q$ 是 <strong>起始状态</strong>.</li><li>$F \subseteq Q$ 是 <strong>接受状态</strong>.</li></ol></li><li><p>DFN的直观理解</p><ol><li><p>非确定性可以看做若干”过程”能同时运行的一类并行计算.当NFA分头跟踪若干选择<br>时,这对应于一个过程分叉成若干个子过程,各子过程分别进行.如果这些子过程中<br>至少有一个接受,那么整个计算接受</p></li><li><p>把非确定性计算看作一颗可能性的树,树根对应计算的开始,树中的每一个分支点对<br>应计算中机器有多种选择的点.如果计算分支中至少有一个结束在接受状态,则机器<br>接受.</p><p>该理解是这样操作的: 当读入字符串时,如果发现该字符串可以到达n个下一状态 那么该节点就会有 n个子节点.如果发现有<br>$\varepsilon$ 箭头,那么就直接分裂 出一个子节点.下图描述了 N1 对 010110的 计算</p><p><img src="/notes/theory-of-computation/static/img/nfa-tree.png"></p></li></ol></li><li><p>property</p><ol><li><p>每一台 NFA 都有一台等价的 DFA与之对应</p></li><li><p>正则语言类在并运算下封闭</p><p>Proof: 假设有正则语言 A1 A2, 它们对应的 NFA为 N1 N2, 现在构造出一台NFA, 它能够识别出 A1 U<br>A2, 构造的方法就是使用一个新的初始状态q<sub>0</sub>, 而从 q<sub>0</sub> 上 分别连一个<br>$\varepsilon$ 箭头到N<sub>1</sub> 与 N<sub>2</sub> 的初始状态,见下图:<br><img src="/notes/theory-of-computation/static/img/nfa-union.png"></p></li><li><p>正则语言在连接运算下封闭</p><p>Proof: 假设有正则语言 A1 A2, 它们对应的 NFA为 N1 N2, 现在构造出一台NFA, 它能够识别出 A1<br>A2, 构造的方法就是从N1的每一个接受状态都连一个 $\varepsilon$ 箭头到N<sub>2</sub><br>的初始状态,见下图: <img src="/notes/theory-of-computation/static/img/nfa-concatenate.png"></p></li><li><p>正则语言类在星号运算下封闭 <img src="/notes/theory-of-computation/static/img/nfa-star.png"></p></li></ol></li></ol><h3 id="非正则语言"><a href="#非正则语言" class="headerlink" title="非正则语言"></a>非正则语言</h3><p>泵引理: 设A是一个正则语言,则存在一个数 p(泵长度)使得, 如果s是A中任一长度不小 于p的字符串, 那么s可以被分为3段,<br>s&#x3D;xyz,满足下述条件:</p><ol><li>对每一个 $i \geqslant 0, xy^iz \in A$</li><li>|y| &gt; 0</li><li>|xy| &lt;&#x3D; p</li></ol><h2 id="上下文无关语言"><a href="#上下文无关语言" class="headerlink" title="上下文无关语言"></a>上下文无关语言</h2><h3 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h3><p>上下文无关文法是一个四元组 $(V, \Sigma, R, S)$, 这里:</p><ol><li>V 是一个有穷集合,称作 <strong>变元集</strong>.(箭头左边的部分)</li><li>$\Sigma$ 是一个与 V 不想交的有穷集合,称作 <strong>终结符集</strong>.</li><li>R 是一个有穷的规则集,每一条规则是一个变元和一个由变元与终结符组成的字符 串</li><li>$S \in V$ 是 <strong>起始变元</strong>.</li></ol><h3 id="乔姆斯基范式"><a href="#乔姆斯基范式" class="headerlink" title="乔姆斯基范式"></a>乔姆斯基范式</h3><p>一个上下文无关文法为乔姆斯基范式,如果它的每一条规则具有如下的形式:</p><p>$A \rightarrow BC$ $A \rightarrow a$ a是任意的终结符,<br>A,B,c使任意的变元,但是B,C不能是起始变元.</p><h1 id="可计算理论"><a href="#可计算理论" class="headerlink" title="可计算理论"></a>可计算理论</h1><h1 id="计算复杂度理论"><a href="#计算复杂度理论" class="headerlink" title="计算复杂度理论"></a>计算复杂度理论</h1>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>theory</tag>
      
      <tag>comoutation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/notes/computer-network/"/>
    <url>/notes/computer-network/</url>
    
    <content type="html"><![CDATA[<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="Pcket-Structure"><a href="#Pcket-Structure" class="headerlink" title="Pcket Structure"></a>Pcket Structure</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs example"> 0                   1                   2                   3<br> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|Version|  IHL  |Type of Service|          Total Length         |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|         Identification        |Flags|      Fragment Offset    |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|  Time to Live |    Protocol   |         Header Checksum       |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                       Source Address                          |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                    Destination Address                        |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                    Options                    |    Padding    |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br><br></code></pre></td></tr></table></figure><ol><li>Version:</li></ol><h2 id="IP地址的分级和组成"><a href="#IP地址的分级和组成" class="headerlink" title="IP地址的分级和组成"></a>IP地址的分级和组成</h2><ol><li>A类(0开头) 0.xx.xx.xx ~ 127.xx.xx.xx</li><li>B类(10开头) 128.xx.xx.xx ~ 191.xx.xx.xx</li><li>C类(110开头) 192.xx.xx.xx ~ 223.xx.xx.xx</li><li>D类(1110开头) 224.xx.xx.xx ~ 239.xx.xx.xx</li><li>E类(1111开头) 240.xx.xx.xx ~ 255.xx.xx.xx</li></ol><p>为了局域网组网方便,有一部分IP是私有,也就是说带有这些ip的ip包是不会出现在公网上的,这 些ip只应该出现私有网络内部.</p><ul><li>A类：10.0.0.0 - 10.255.255.255 (10.0.0.0&#x2F;8)</li><li>B类：172.16.0.0 - 172.31.255.255 (172.16.0.0&#x2F;12)</li><li>C类：192.168.0.0 - 192.168.255.255 (192.168.0.0&#x2F;16)</li></ul><p>loopback网段: 127.0.0.0&#x2F;8</p><h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><p>ip地址被分为NET ID和HOST ID, 如果ip地址的NET ID相同那么就处于同一子网, 也就可以 使用链路层设备直接通信.</p><ul><li>子网掩码: 用来指定ip的哪些位是NET ID, 比如说 <code>255.255.255.0</code> 就是说IP的前24位 是NET ID,<br><code>255.240.0.0</code> 就是说前12位是NET ID. 所以 <code>192.168.0.0/255.255.255.0</code><br>实际上就是指定了一个网段, 也可以用CIDR <code>192.168.0.0/24</code>,<br>后面的数字代表前24位是NET ID.</li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>Network Address Translation, 主要是用来自动转换IP地址, 这样一个私有网络的所有计 算机就可以共用一个public<br>ip来上网. 它是使用ip和port来识别包的.</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>tcp提供的是可靠的数据传输，这意味着要满足以下几点:</p><ol><li>数据报不能损坏</li><li>数据报不能丢失</li><li>数据报要按照发送顺序提供给上层的调用者</li></ol><p>为了应对这几点，引入很多机制</p><ol><li>为了应对数据报丢失和损坏，引入了 <strong>确认</strong> 机制，也就是ack报文。</li><li>为了检测数据报损坏，所以引入了checksum</li><li>为了从数据报损坏,丢失中恢复，引入 <strong>重传</strong> 的机制</li><li>为了消除重传造成的数据报冗余，必须保证 幂等，这样就引入了 <strong>序号</strong> 机制, 序 号机制也可以保证数据流的顺序。</li></ol><h2 id="协议详解"><a href="#协议详解" class="headerlink" title="协议详解"></a>协议详解</h2><p>tcp的头部格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs example"> 0                   1                   2                   3<br> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|          Source Port          |       Destination Port        |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                        Sequence Number                        |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                    Acknowledgment Number                      |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|  Data |           |U|A|P|R|S|F|                               |<br>| Offset| Reserved  |R|C|S|S|Y|I|      Receive Window Size      |<br>|       |           |G|K|H|T|N|N|                               |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|           Checksum            |         Urgent Pointer        |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                    Options                    |    Padding    |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                             data                              |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br></code></pre></td></tr></table></figure><p><strong>几点解释:</strong></p><ol><li>Source Port, Destination Port是端口号</li><li>Sequence Number: tcp对内部传送的每一个字节都会编号, 该字段代表的就是该数 据报第一个字节的编号.</li><li>Acknowledgment Number: 当接受端收到一个tcp数据报后,会发送一个确认报文,发<br>送端就是根据确认报文来判断该数据报是否发送成功,如果长时间没有收到确认报<br>文,那么发送端就会重发tcp数据报, 确认报文的ACK必须为1,同时Acknowledgment<br>Number代表该端期望接受数据的序号,比如接受端收到一个tcp报文,该报文的<br>Sequence Number是a, 同时报文长度是b, 那么对该报文的确认报文的 Acknowledgment<br>Number字段就是a+b. <strong>只有ACK标志为1时该字段才有效</strong></li><li>Data Offset: 实际数据在报文中的偏移,也可以看作是tcp头部的大小,因为tcp头部<br>包含options所以他的大小是可变的,这就是该字段存在的原因.</li><li>标志:<ul><li>URG: 紧急指针</li><li>ACK: Acknowledgement number有效</li><li>PSH:</li><li>RST: 重置连接, 万恶的GFW经常这么干.</li><li>SYN: Synchronize sequence numbers, 三步握手时需要.</li><li>FIN: finish, 关闭连接时会用到该标志</li></ul></li><li>Window size: 用来标示发送该数据报的一端希望接收的数据大小, 主要用来进行 流控制(flow control).</li></ol><p><strong>其他说明:</strong></p><ol><li>TCP可以看做是一个全双工管道,可读可写, 也就是说一个tcp socket的读写是分离, 互不干扰的.</li><li>TCP提供了流控制,也就是说内部有缓冲区,如果缓冲区满了那么相应的操作就会阻塞,举 个例子,<br>如果接受者的读缓冲区满了,那么你在发送者一端调用write就会阻塞.</li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol><li>tcp是使用累积确认，也就是说接收端发送了一个ack&#x3D;N的确认报文，那么就意味着 所有序号小于N的数据都已经成功接受。</li><li>接收端只确认顺序到达的最大序号的报文，比如a,b,c,d四个报文，假设它们顺序到<br>达但是b丢失，那么实际上对c,d的确认报文和对a的确认报文是一样的。一旦发送端<br>收到的重复ACK报文达到一个阈值，那么就会重发b， 对b的ACK报文的ack实际上等 于d的序号加上d的长度。</li></ol><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="三步握手"><a href="#三步握手" class="headerlink" title="三步握手"></a>三步握手</h3><p>如下图所示: <img src="/notes/computer-network/static/img/tcp-three-way-handshake.png"> 三个报文:</p><ol><li>SYN标志为1, 同时为Sequence Number指定一个初始值J</li><li>SYN以及ACK标志为1,同时为Sequence Number指定一个初始值K, 同时将 Acknowledgement<br>Number设为J+1.</li><li>ACK标志为1, 同时将Acknowledgement Number设为K+1, FIN报文会消耗一个编号</li></ol><h3 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h3><p>如下图所示 <img src="/notes/computer-network/static/img/tcp-terminate.png"></p><h3 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h3><p>如下图所示 <img src="/notes/computer-network/static/img/tcp-state-change.png"></p><p><strong>TIME_WAIT</strong>: 关闭连接时, 执行主动关闭的一方的socket在发送了最后一个ACK后进入<br>TIME_WAIT状态,并保持该状态2SML(1-4分钟), 该状态存在的原因是:</p><ol><li>如果最后一个ACK丢失,那么对方就会重发FIN报文,这时socket有机会发送ACK报文, 而不是由内核发送RST报文.</li><li>可以让网络中当前连接的tcp报文全部失效,因为TCP会超时重传,所以网络可能存在<br>一些没有被当前客户端接受的报文,等待2SML后这些报文就都失效了.<br>如果不等待 2SML, 同时你又在相同的interface上创建了socket,那么这些上一次连接的报文就 可能被本次连接认为有效.</li></ol><p><strong>处于TIME_WAIT时,(ip, port)不可用, 所以有时重启服务器需要等一段时间.</strong>, 当然<br>只有在服务器有客户端连接的情况下才会出现这种情况,因为如果这时重启服务器,那么<br>服务器端会执行主动关闭,所以就会进入TIME_WAIT状态. 如果没有客户端连接,那么服 务器一般就只有一个listen<br>socket,关闭它不会进入TIME_WAIT.</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>tcp必须匹配发送方以及接收方的速率,因为接收方处理数据的速度可能没有发送方发送<br>数据的速度快，这时候需要降低发送方的发送速度，因为发送的再快，可是接收方处理<br>不了的话，那也没有任何意义。</p><p><strong>Notice</strong>: 流量控制和拥塞控制不是一回事，流量控制只是为了匹配发送方，接收方的<br>速率和网络没关系。拥塞控制主要是根据网络的负载情况来动态的调整发送速率，来避<br>免网络拥塞.</p><p>tcp数据报的Receive window size就是用来告知对方自己的接收缓冲区最多还能接收多 少数据，它是通过下面的方式计算的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">lastByteRcvd - lastByteRead &lt;= RcvBuffer<br>rwnd = RcvBuffer - (lastByteRcvd - lastByteRead)<br></code></pre></td></tr></table></figure><ol><li>lastByteRcvd: 接收到的最大序号</li><li>lastByteRead: 已经被上层处理了的最大序号</li><li>rwnd: 流量窗口的大小</li><li>RcvBuffer: 接收缓冲区的大小</li></ol><p><strong>zero window</strong>: 当rwnd&#x3D;0的时候，发送方仍然会继续发送只包含1字节数据的数据报，<br>这样可以迅速的探测出对方的接收缓冲区什么时候有空间了。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h1 id="TSL-x2F-SSL"><a href="#TSL-x2F-SSL" class="headerlink" title="TSL&#x2F;SSL"></a>TSL&#x2F;SSL</h1><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>目的:</p><ol><li>确定正文内容确实来源于发送者</li><li>确定正文内容没有被篡改</li></ol><p>实现:</p><ul><li>发送者: 对正文内容hash从而生成摘要(Digest),接着用私钥加密摘要,将密文附在正文的后面</li><li>接收者: 用发送者的公钥解密得到摘要,接着hash正文,比较摘要是否一致</li></ul><p>原理: 私钥加密可以防止摘要被篡改,摘要要可以用来检查正文内容是否被篡改.</p><p><strong>数字签名对正文是不加密的</strong></p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>目的: 分发公钥, 防止公钥被篡改,这也是为什么叫public key certification 的原因</p><p>实现:</p><ol><li>CA机构会将你的公钥连同你的一些个人信息放入数字证书中,同时使用CA的私钥来进 行数字签名, 数字签名也会放入数字证书中.<br>数字证书一般包含这些内容:<ul><li>Version</li><li>Serial Number: 用来唯一的标示一个证书的</li><li>Certification Signature Algorithm: 签名算法(hash和加密)</li><li>Certification Signature Value: 数字签名的值</li><li>Issuer: 该证书的颁发机构(CA)</li><li>Subject: 该证书的所有者</li><li>Public Key: 证书所有者的公钥</li><li>Fingerprint: 该证书的指纹,可以看做是数字证书一个身份标示</li></ul></li><li>很多软件比如浏览器会有受信任的CA机构的数字证书,这些证书包含了CA的公钥,当收<br>到一个数字证书时,它会读取证书的颁发者,然后用颁发者的公钥来检查数字证书的签<br>名是否正常.</li></ol><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>要保证安全实际上要做的就是两件事:</p><ol><li><strong>确认服务器的身份</strong>,也就是说服务器不能被冒充,杜绝中间人攻击,实现方法:<ul><li>通过数字证书安全的获得服务器的公钥</li><li>验证服务器的私钥</li></ul></li><li><strong>所有的通信数据要加密</strong>,这样即便数据被截获也可以保证安全，实现方法是每一个 会话都协商一个对称秘钥,<br>用它来加密和解密传输的信息,之所以不直接使用RSA是因<br>为开销太大，同时秘钥加密的数据可以被解密，达不到加密的要求。</li></ol><p><strong>CA机构必须保证不做恶</strong>, 因为一旦CA机构干坏事那就基本没有安全可言，CNNIC就是一 个例子，比如它可以配合gfw这样进行中间人攻击：</p><ol><li>它签发一个证书给某台服务器</li><li>用GFW的dns劫持将访问google等网站的请求导向1中的服务器</li><li>因为CNNIC的证书被浏览器信任，所以浏览器会高高兴兴的和1中的服务器进行https 通信，这样gfw也就可以解密你的https请求了</li></ol><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><ol><li>NS记录用来将一个subdomain授权给其它的dns server管理</li><li>CNAME记录不能与其它记录共存</li><li>SOA和CNAME记录对同一个name只能有一条。</li><li>TXT可以指定多条记录，每一条记录内部又可以指定多条字符串。在dns包中每一个字符<br>串都是1byte存放字符串的长度，接着跟着字符串的长度，字符串不需要以0结尾。</li><li>DNS包中的authority section只能放NS记录</li></ol><h1 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h1><ol><li>集线器(HUB): 工作于第二层,基本已被淘汰, 目前基本用交换机, HUB最大的问题是当它<br>接收到一个数据包后,它会向所有连接到该hub的主机广播,<br>这样会造成一大堆无用流量. 这主要是因为HUB内部没有交换机内部的那种MAC地址表.</li><li>网桥: 也基本被淘汰. 它有两个端口，作用是可以把一个大的局域网分成两个小的局域<br>网,这样可以显著的减少广播包的数量。但是每一个小的局域网内部还是需要广播，还是<br>没有交换机那样点对点传播高效。</li><li>交换机<ul><li>二层交换机: 用来将链路层数据包发给相应的主机或者网络设备, 内部有个MAC地址表,交<br>换机会根据各个端口接受数据包的源MAC地址来自动的更新该表.因为这个表的存在,交<br>换机不用像HUB一样广播,它可以点对点的发送,所以效率要高得多.</li><li>三层交换机</li><li>四层交换机</li></ul></li><li>路由器</li><li>家用路由器：名字有误导性，实际上相当于一个交换机加上路由器以及防火墙。插在Lan<br>口上的电脑以及无线连接的设备就像连在交换机上组网，同时它又是一个路由器，一边<br>是局域网一边是公网,同时要用到 <strong>NAT</strong> ，因为需要将局域网ip转换成公网ip。</li></ol><h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>主要有tcpdump和wireshark</p><h2 id="Capture-Filter"><a href="#Capture-Filter" class="headerlink" title="Capture Filter"></a>Capture Filter</h2><p>这是启动抓包之前需要设置的过滤器,设置后在本次抓包过程中不可更改, 格式是 wireshark, tcpdump通用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs example">Exp       ::= AtomicExp LogicOp Exp | AtomicExp<br>AtomicExp ::= Protocol  Direction  Key  Value<br><br>LogicOp   ::= and | or | not | &amp;&amp; | ! | ||<br><br>Protocol  ::= ether| fddi| tr| wlan| ip| ip6| arp| rarp| decnet| tcp | udp<br>Direction ::= src | dst | src or dst<br>Key       ::= host | net | port | portrange<br></code></pre></td></tr></table></figure><ol><li><p>Protocol: 协议,可能的值为:ether, fddi, ip, arp, rarp, decnet, lat, sca,<br>moprc, mopdl, tcp and udp, 默认是所有协议</p></li><li><p>Direction: src, dst, src and dst, src or dst 默认是src or dst</p></li><li><p>Key: 可以看做是某种属性名,支持的值为:host,port, net, portrange, 默认是host</p></li><li><p>Value: 对应于Key的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs example">portrange 10000-10020<br>port 27011<br>host 127.0.0.1<br>net 192.168.1.0/24<br></code></pre></td></tr></table></figure></li><li><p>LogicalOperation: not, and, or, 可以用来组合多个表达式</p></li></ol><h2 id="Didsplay-Filter"><a href="#Didsplay-Filter" class="headerlink" title="Didsplay Filter"></a>Didsplay Filter</h2><p>通过Capture filter过滤后得到的包如果还是太多,那么可以通过display filter来过滤,只 让过滤后的包显示出来,<br><strong>wireshark专用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs example">Exp ::= AtomicExp LogicOp Exp | AtomicExp<br>AtomicExp ::= Protocol.Key1.Key2 CompOp Value<br><br>LogicOp ::= and | or | not | &amp;&amp; | ! | ||<br>CompOp  ::= eq | ne | gt | lt | ge | le | == | != | &lt; | &gt; | &lt;= | &gt;=<br><br>Protocol ::= ether| fddi| tr| wlan| ip| ip6| arp| rarp| decnet| tcp | udp<br></code></pre></td></tr></table></figure><ol><li><p>Key1, Key2 是可选的,不同的协议是不同的,常用的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">ip.addr, ip.src, ip.dst<br>tcp.port, tcp.srcport, tcp.dstport<br></code></pre></td></tr></table></figure><p>更详细就查文档</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UNP笔记</title>
    <link href="/notes/unp/"/>
    <url>/notes/unp/</url>
    
    <content type="html"><![CDATA[<h1 id="socket地址相关"><a href="#socket地址相关" class="headerlink" title="socket地址相关"></a>socket地址相关</h1><p>有一个通用地址结构 <code>struct sockaddr_in</code>, bind, connect这样的API中都是使用这个 结构,<br>其它的地址结构必须类型转换为该结构. ipv6又定义了一个新的通用地址结构 <code>struct sock_storage</code>, 该结构可以包含所有的地址,包括ipv4,ipv6以及unix.</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* -------------- 通用地址结构(旧) ----------------------- */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span>     sa_len;<br>    <span class="hljs-type">sa_family_t</span> sa_family;    <span class="hljs-comment">/* address family: AF_xxx value */</span><br>    <span class="hljs-type">char</span>        sa_data[<span class="hljs-number">14</span>];  <span class="hljs-comment">/* protocol-specific address */</span><br>&#125;;<br><span class="hljs-comment">/* ---------------- ipv4 ----------------------------------- */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">in_addr_t</span>  s_addr;    <span class="hljs-comment">/* 32-bit IPv4 address */</span><br>    <span class="hljs-comment">/* network byte ordered */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span>         sin_len;       <span class="hljs-comment">/* length of structure (16) */</span><br>    <span class="hljs-type">sa_family_t</span>     sin_family;    <span class="hljs-comment">/* AF_INET */</span><br>    <span class="hljs-type">in_port_t</span>       sin_port;      <span class="hljs-comment">/* 16-bit TCP or UDP port number */</span><br>    <span class="hljs-comment">/* network byte ordered */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span>  <span class="hljs-title">sin_addr</span>;</span>      <span class="hljs-comment">/* 32-bit IPv4 address */</span><br>    <span class="hljs-comment">/* network byte ordered */</span><br>    <span class="hljs-type">char</span>            sin_zero[<span class="hljs-number">8</span>];   <span class="hljs-comment">/* unused */</span><br>&#125;;<br><br><span class="hljs-comment">/* --------------通用地址结构(新, ipv6定义) ------------------ */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span>      ss_len;    <span class="hljs-comment">/* length of this struct (implementation dependent) */</span><br>    <span class="hljs-type">sa_family_t</span>  ss_family; <span class="hljs-comment">/* address family: AF_xxx value */</span><br>    <span class="hljs-comment">/* implementation-dependent elements to provide:</span><br><span class="hljs-comment">     * a) alignment sufficient to fulfill the alignment requirements of</span><br><span class="hljs-comment">     *    all socket address types that the system supports.</span><br><span class="hljs-comment">     * b) enough storage to hold any type of socket address that the</span><br><span class="hljs-comment">     *    system supports.</span><br><span class="hljs-comment">      */</span><br>&#125;;<br><br><span class="hljs-comment">/* ------------------------ ipv6 --------------------------- */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span>   s6_addr[<span class="hljs-number">16</span>];   <span class="hljs-comment">/* 128-bit IPv6 address */</span><br>                             <span class="hljs-comment">/* network byte ordered */</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIN6_LEN         <span class="hljs-comment">/* required for compile-time tests */</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span>          sin6_len;      <span class="hljs-comment">/* length of this struct (28) */</span><br>    <span class="hljs-type">sa_family_t</span>      sin6_family;   <span class="hljs-comment">/* AF_INET6 */</span><br>    <span class="hljs-type">in_port_t</span>        sin6_port;     <span class="hljs-comment">/* transport layer port# */</span><br>                                    <span class="hljs-comment">/* network byte ordered */</span><br>    <span class="hljs-type">uint32_t</span>         sin6_flowinfo; <span class="hljs-comment">/* flow information, undefined */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span>  <span class="hljs-title">sin6_addr</span>;</span>     <span class="hljs-comment">/* IPv6 address */</span><br>                                    <span class="hljs-comment">/* network byte ordered */</span><br>    <span class="hljs-type">uint32_t</span>         sin6_scope_id; <span class="hljs-comment">/* set of interfaces for a scope */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><p>有两个函数来转换ip地址,也就是在presentation format与numeric format之间转换,<br>presentation format是字符串,比如”127.0.0.1”, 这种形式对人更友好,而numeric<br>format是数字,它是放在地址结构体中, 这两个函数能转换ipv4以及ipv6地址,原型如 下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example">#include &lt;arpa/inet.h&gt;<br><br>int inet_pton(int af, const char *src, void *dst);<br>const char *inet_ntop(int af, const void *src,<br>                      char *dst, socklen_t size);<br></code></pre></td></tr></table></figure><p>常用 <code>inet_pton</code> 来将字符串表示的ip转换为地址结构体要求的数字ip</p></li><li><p>因为网络程序需要在不同的机器间通信,所以字节序很重要, 网络协议默认的字节序是 大端字节序, 所以需要函数来在 <strong>主机字节序(host<br>byte order)</strong> 与 <strong>网络字节序 (network byte order)</strong> 之间转换, 有以下几个函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs example">#include &lt;netinet/in.h&gt;<br>uint16_t htons(uint16_t host16bitvalue) ;<br>uint32_t htonl(uint32_t host32bitvalue) ;<br>                       Both return: value in network byte order<br>uint16_t ntohs(uint16_t net16bitvalue) ;<br>uint32_t ntohl(uint32_t net32bitvalue) ;<br>                       Both return: value in host byte order<br></code></pre></td></tr></table></figure><p>常用 <code>htons</code> 来转换端口号.</p></li></ol><h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><ol><li><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">servaddr</span>;</span><br>bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>servaddr.sin_family = AF_INET;<br>servaddr.sin_port = htons(<span class="hljs-number">13</span>);<br><span class="hljs-keyword">if</span> (inet_pton(AF_INET, argv[<span class="hljs-number">1</span>], &amp;servaddr.sin_addr) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">/* error */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>服务端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">servaddr</span>;</span><br>bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br>servaddr.sin_family = AF_INET;<br>servaddr.sin_port = htons(<span class="hljs-number">13</span>);<br>servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<br><span class="hljs-comment">/* or use inet_pton to set ip */</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="基本socket-API"><a href="#基本socket-API" class="headerlink" title="基本socket API"></a>基本socket API</h1><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>客户端使用该api建立连接,它可能返回以下错误:</p><ol><li>ETIMEDOUT: 超时, 也就是说没有接收到server端的ACK报文.</li><li>ECONNREFUSED: 发送SYN报文后,收到了RST报文,也就是说server端没有进程在监听 你要连接的端口.</li><li>EHOSTUNREACH, ENETUNREACH:收到了ICMP的unreachable的报文</li></ol><p><strong>connect一旦出错,那么该socket就不可用了,必须关闭.</strong></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p>原型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">int listen (int sockfd, int backlog);<br></code></pre></td></tr></table></figure><p>内核会维护两个队列:</p><ol><li>未完成队列:　当客户端发送３次握手的第一个SYN报文到服务端时,该队列就会增加 一项,完成三次握手后该项就会移到已完成队列的末尾</li><li>已完成队列: 当客户端完成三次握手,那么在队列的末尾增加一项,当你调用accept<br>时就从队列的开头移除一项,如果该队列为空,那么accept会阻塞.</li></ol><p>从linux2.2开始backlog是已完成队列的最大值. 未完成队列的最大值由一个全局值设 定,该值在<br>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog中, 如果已完成队列满了,而此时<br>未完成队列的某个连接收到了三步握手的最后一个ACK,<br>这时内核会忽略这个ACK(意思就 是说就像没有收到这个ACK包一样),<br>因此一段时间后server端会重发第二步握手的 SYN&#x2F;ACK包.</p><h2 id="socket读写api"><a href="#socket读写api" class="headerlink" title="socket读写api"></a>socket读写api</h2><ol><li>对于面向连接的socket(TCP), 有以下两组api, recv&#x2F;send以及read&#x2F;write, 前者比<br>后者多了一个flag参数, 当使用flag&#x3D;0来调用recv,<br>send时,他的行为和read,write 是一样的.</li><li>面向非连接的socket(UDP, RAW):有以下api, recvfrom&#x2F;sendto, 这两个有一个地址<br>参数和一个指示地址结构长度的参数, 如果将这两个值设为NULL和0,那么行为实际<br>和recv&#x2F;send一样.</li><li>send buffer: 在内核中,每一个socket都有一个 send buffer<ul><li><strong>TCP</strong>: 当你调用write或者send时, 实际就是将数据从用户空间的buffer复制到 内核空间的send<br>buffer, 如果send buffer的空间不够,那么write&#x2F;send操作将阻<br>塞(前提是socket没有设为非阻塞).当write&#x2F;send返回时,意味着数据已经都复制<br>到了send buffer,但不保证数据已经通过网络发送出去了. 只有收到对方的ACK报 文,这些数据才能从send<br>buffer移除.</li><li><strong>UDP</strong>: 因为udp是直接将数据加上udp头部发往下层,也就是udp数据报要原子的发<br>送,它不能拆解,所以如果你传入的数据太大,比如比send<br>buffer还大,那么内核会 返回错误EMSGSIZE. 如果只是当前的send buffer没有足够的空间,那么阻塞的<br>socket上的send调用会阻塞,非阻塞的send调用会返回EAGAIN或者EWOULDBLOCK.<br><strong>UDP上的send要么全部发送,要么出错,不会出现只发送一部分数据的情况</strong></li></ul></li><li>receive buffer: 内核中每一个socket都有一个receive buffer.<ul><li><strong>TCP</strong>: 通过tcp的流控制(tcp报文的Window字段), 可以通知peer该端目前能够接<br>受的数据大小,如果peer忽略该建议,同时发送来的数据大于该大小,那么内核会丢<br>弃这个数据报.因为receive buffer没有足够的空间容纳这些数据.丢弃后peer过<br>一段时间要重发,那么peer就会”慢下来”, 这实际就是流量控制.</li><li><strong>UDP</strong>: udp没有流控制,如果receive buffer,内核会直接丢弃数据报</li></ul></li><li>读就绪条件:满足下面四个条件之一的,read操作不会阻塞<ol><li>socket的receive buffer中的数据大于等于”低水位”值(low-water mark)</li><li>socket的被读关闭,那么read会马上返回0</li><li>socket是listening socket,而且这时已完成队列不为空,那么accept会立即返回</li><li>socket上有错误在排队,read操作会直接出错返回<br><strong>当读就绪时, 阻塞读与非阻塞读的行为是相似的,都会立即返回.并且返回读到的字 节数.</strong></li></ol></li><li>写就绪条件: 满足下面四个条件之一的,write操作不会阻塞<ol><li>socket的send buffer的空余空间大于”低水位”值,</li><li>socket被写关闭,那么写操作会产生SIGPIPE信号.</li><li>非阻塞的connect,或者connect出错</li><li>socket上有错误在排队, write会直接出错返回.</li></ol></li></ol><h1 id="socket-options"><a href="#socket-options" class="headerlink" title="socket options"></a>socket options</h1><p>使用下面的两个系统调用来获取以及设置socket选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">#include &lt;sys/socket.h&gt;<br>int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);<br>int setsockopt(int sockfd, int level, int optname, const void *optval socklen_t optlen);<br></code></pre></td></tr></table></figure><p>注意optval对于不同的选项是不同的值,所以你要optlen参数来通知获得optval的长度.</p><h2 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h2><p>如果socket设置了该选项, 那么当一个连接有两个小时没有交换数据了(这意味着程序 阻塞在某个系统调用上),<br>那么就会向对方发送一个keep-alive probe, 实际就是一个 tcp报文.<br>如果这个报文收到了正常的ACK,那么就什么也不做,如果超时或者收到RST报<br>文,那么被阻塞的系统调用会返回相应的错误.</p><h2 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h2><p>对面向连接的协议有效, 所以对UDP该选项无用, 该选项是用来改变socket调用close时的行<br>为.默认如果你调用close,那么close会立即返回,但是如果send<br>buffer有数据,那么系统会 现将数据发送出去. 这种默认行为可以改变</p><h2 id="SO-RCVBUF-x2F-SO-SNDBUF"><a href="#SO-RCVBUF-x2F-SO-SNDBUF" class="headerlink" title="SO_RCVBUF&#x2F;SO_SNDBUF"></a>SO_RCVBUF&#x2F;SO_SNDBUF</h2><p>修改socket的send buffer以及receive buffer的大小. <strong>这两个选项必须在connect与<br>listen之前设置</strong>.</p><h2 id="SO-RCVLOWAT-x2F-SO-SNDLOWAT"><a href="#SO-RCVLOWAT-x2F-SO-SNDLOWAT" class="headerlink" title="SO_RCVLOWAT&#x2F;SO_SNDLOWAT"></a>SO_RCVLOWAT&#x2F;SO_SNDLOWAT</h2><p>低水位标志,用来判断一个socket是否可读或者可写, 如果接受缓冲区的数据量大于 SO_RCVLOWAT(默认为1)那么可读,<br>如果发送缓冲区的空闲空间大于SO_SNDLOWAT(默认通常为 2048)那么可写.</p><h2 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h2><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><ol><li>可以避免重启服务器时的 address already in use 的错误</li><li>指定该选项,那么可以在相同的端口上启动多个实例,也就是多个socket bind到相同 的端口,但是ip地址必须不同</li><li>即便指定该选项,tcp也不能bind完全相同的地址(相同的ip与port)到多个socket,如 果要这么做,那么需要使用<br><code>SO_REUSEPORT</code> 选项.</li></ol><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p>如果指定了该选项,那么你可以bind完全相同的地址(相同的ip与port)到多个socket, 当<br>收到数据报时,如果你指定的是多播地址,那么数据报会发送给每一个绑定的socket,如果<br>是单播地址,那么随机的选择一个socket.对单播地址的场景, <strong>建议使用SO_REUSEPORT</strong>,<br>因为它可以将数据报更均衡的发布到多个socket上.</p><h2 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h2><p>这个选项用来将完全相同的地址bind到多个socket,支持tcp,udp</p><h3 id="tcp-1"><a href="#tcp-1" class="headerlink" title="tcp"></a>tcp</h3><p>通常的tcp服务器都是这样的:</p><ol><li>一个线程创建listen socket,然后accept,得到连接后下发到工作线程,memcached就<br>是这么实现的,但是它有一个问题就是这个accept的线程在极端场景可能成为瓶颈.</li><li>多个线程同时在一个listen socket上accept,哪个线程得到新连接那么它就负责处<br>理.这种方式的问题是负载不均衡.也就是说有的线程得到的连接多,有的得到的少.</li></ol><p>上面的两种做法的问题根源是 <strong>只能有一个listen socklet</strong>, 通过指定 <code>SO_REUSEPORT</code>,<br>可以创建多个绑定到相同地址的listen socket, 这样你可以在不同<br>的进程或者线程里面单独的accept到该地址的新连接,操作系统负责将新连接均匀的分 布到各个listen<br>socket.</p><h3 id="udp-1"><a href="#udp-1" class="headerlink" title="udp"></a>udp</h3><p>单个socket的recv buffer是有锁的,所以多线程的使用单个socket是得不到明显的性能 提升的.甚至可能使性能下降,通过指定<br><code>SO_REUSEPORT</code> 你可以创建多个绑定到相同地 址的udp<br>socket,这样你就可以在不同的线程或者进程中单独的收发到该地址的数据报.因<br>为使用的是不同的socket,所以也就不会用锁竞争的问题.</p><h1 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h1><h2 id="一些情形下tcp-socket的行为"><a href="#一些情形下tcp-socket的行为" class="headerlink" title="一些情形下tcp socket的行为"></a>一些情形下tcp socket的行为</h2><ul><li>server端的进程终止了,这时client端向socket写则会收到RST报文, 如果你接着向这个<br>socket写入数据,那么会收到SIGPIPE信号.如果你忽略了该信号,那么write会返回EPIPE<br>错误.</li><li>如果server崩溃(比如断电,比如断掉网线然后关掉进程, 总之让client无法收到正常 关闭时的FIN包), 这时有两种情况:<ul><li>如果server端没有恢复正常(比如没有重启, 或者没有插上网线重启进程), 那么 client端会超时.</li><li>如果server恢复了正常,那么client向server写会收到RST, 这时读该socket会产生 ECONNRESET错误</li></ul></li><li>RST的产生条件：<ol><li>connect连接一个服务器，可是服务器没有运行（在指定的端口没有 socket在listen），<br>该情况作为connect调用的错误检查（ECONNREFUSED）</li><li>当tcp要 abort一个连接时。</li><li>当tcp收到一个不存在的连接发来的数据包时。</li></ol></li><li>对于连接的任一端，如果发送FIN，就意味着该端不会再向该连接写数据，所以另一端 read该连接都会返回0也就是EOF。</li><li>Connect只能调用一次，不能像accept，read，write那样被信号打断后重启，一旦失败， 那么该socket<br>fd就必须关闭，当然只是同步调用，如果指定了了O_NOBLOCK,如果connect<br>失败，且errno&#x3D;EINPROGRESS，那么并不意味在调用失败。</li><li>如果向socket写入数据返回了RST，那么此时读该socket会返回ECONNRESET错误，如果此<br>时写该socket会产生SIGPIPE信号，该信号默认会终止该程序，所以必须处理。</li><li>如果一个A到B的连接，如果执行了B-&gt;A的半关闭，也就是B向A发送FIN，那么表明B不会再<br>向socket写数据，所以在A端读该socket会返回EOF，如果A端向socket写，那么分情况：<ol><li>如果B端的进程已终止，那么连接已经不存在，所以会返回一个RST，</li><li>如果B端的进程没有终止，而只是执行了半关闭，那么A端的write是合法的，因为 半 关闭是合法的。</li></ol></li><li>对于tcp客户端，如果没有明确调用bind，那么socket的端口是在调用connect时由内核随 机指定，而udp<br>socket的端口则是在第一次调用sendto 时由内核随机指定的，而且一旦 指定就不在改变，而udp<br>socket的ip地址是可变的，如果客户端主机是一个多接口（有多<br>块网卡）的主机，那么每一次发送udp数据包内核都可以随机选择可用的ip地址。（ip地<br>址是在ip层指定，而端口则是在udp层指定，所以没有调用bind的socket，它的端口不可 变，ip却可变）。</li><li>对于缓冲区：对tcp而言，向socket写，会将数据从用户缓冲区复制到内核的发送缓冲区，<br>然后内核将这些数据发送给目的端，但是此时内核发送缓冲区的数据没有丢弃，只有当接<br>到ack时这些数据才会丢弃，因为网络数据包可能丢失，所以这些可能需要重传。而对于<br>udp则并没有发送缓冲区，因为udp是unreliable的，它无连接，所以不需要重传，直接将<br>数据加上udp头，ip头发送出去，然后数据就丢弃了。对于内核的接收缓冲区，tcp与udp<br>基本一致，udp的内核接受缓冲区会限制接受的数据报的数量，一旦<br>超出缓冲区的大小， 后续的udp包都会丢弃。（unp 8.13）。</li></ul><h2 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h2><ol><li><p><code>connect</code>: 在调用之前将socket设置为非阻塞, 那么connect可能会出错, 那么这时候 要检查errno,<br>如果为EINPROGRESS, 那么意味着connect需要阻塞, 这时候你应该监听 socket的可写事件,<br>如果发现可写,那么使用 <code>getsockopt</code> 来获取错误, 如果没有错误,那 么connect执行成功,<br>否则执行失败,示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> flags;<br><br><span class="hljs-keyword">if</span>((flags = fcntl(fd, F_GETFL)) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//获取当前的flags标志</span><br>  err_sys(“F_GETFL error!”);<br><br>flags |= O_NONBLOCK; <span class="hljs-comment">//修改非阻塞标志位</span><br><br><span class="hljs-keyword">if</span>(fcntl(fd, F_SETFL, flags) &lt; <span class="hljs-number">0</span>)<br>  err_sys(“F_SETFL error!”);<br><span class="hljs-keyword">if</span> (connect(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;sa, <span class="hljs-keyword">sizeof</span>(sa)) == <span class="hljs-number">-1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (errno != EINPROGRESS) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br> &#125;<br><span class="hljs-comment">// 监听可写事件, 如果可写执行下面代码</span><br>err = <span class="hljs-number">0</span>;<br>errlen = <span class="hljs-keyword">sizeof</span>(err);<br><span class="hljs-keyword">if</span> (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;err, &amp;errlen) == <span class="hljs-number">-1</span>) &#123;<br>  <span class="hljs-built_in">sprintf</span>(<span class="hljs-string">&quot;getsockopt(SO_ERROR): %s&quot;</span>, strerror(errno));<br>  close(fd);<br>  <span class="hljs-keyword">return</span> ERR;<br> &#125;<br><span class="hljs-keyword">if</span> (err) &#123;<br><br>  errno = err;<br><br>  close(fd);<br><br>  <span class="hljs-keyword">return</span> ERR;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>服务端在accept之前将socket设置为非阻塞, 这样你就可以监听listenfd的可读事件,<br>如果可读,那么就意味着有新连接进来,那么你就可以调用accept来获得连接了,<br>如果没 有连接的时候你调用accept, 那么会出错返回, errno为EAGAIN或者EWOULDBLOCK.</p></li></ol><h2 id="raw-socket"><a href="#raw-socket" class="headerlink" title="raw socket"></a>raw socket</h2><p>raw socket 是用来获取IP报文的, 但是内核不会把所有的报文都发给raw socket.</p><ol><li>TCP&#x2F;UDP的IP报文不会发给raw socket, 所以要抓这种报文只能去链路层抓包</li><li>ICMP&#x2F;IGMP的IP报文会发送给raw socket</li><li>如果内核不认识IP报文的协议类型字段,那么发给raw socket</li><li>如果IP报文有分片,那么只有把所有的分片组合成一个完整的IP报文后才会发送给raw socket.</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>socket</tag>
      
      <tag>api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git笔记</title>
    <link href="/notes/git/"/>
    <url>/notes/git/</url>
    
    <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="git的基本命令"><a href="#git的基本命令" class="headerlink" title="git的基本命令"></a>git的基本命令</h2><ul><li>安装：sudo apt-get install git git-uid</li><li><code>init</code>: git init（工作目录运行，会生成一个.git目录，里面会存放索引数据）</li><li><code>add</code>: 将文件添加到暂存区<ol><li><code>git add</code>: 添加文件</li><li><code>git add .</code>: 添加所有</li></ol></li><li><code>commit</code>: 提交到版本库，一般调用add后只是在暂存区，只有调用commit才会提交到git版本库<ol><li><code>git commit -m &quot;comment&quot;</code>:</li><li><code>git commit -a</code>: 提交所有</li><li><code>git commit --amend</code>: 可以重新提交上一次commit,这在上一次提交遗漏了某些文件 时非常有用.</li></ol></li><li>clone: git clone 只要有.git目录，那么就可以调用该命令来得到git管理的 所有文件 eg: git clone<br>test.git dest\_dir&#x2F; git—-&gt;dest\_dir git clone 账户@IP:工作树路径 你的目录<br>远程github</li><li>pull: git pull（将远程分支拉到本地，然后和本地分支合并）</li><li>push： git push（将本地分支推送远程仓库）</li><li><code>branch</code>: 创建分支或者查看有哪些分支<ol><li><code>git branch</code>: 查看有哪些分支</li><li><code>git branch &lt;branch&gt;</code> 创建分支</li><li><code>git branch -d &lt;branch&gt;</code> 删除分支,如果有commit没有合并,那么会拒绝删除</li><li><code>git branch -D &lt;branch&gt;</code>: 和上一个类似,但是会强制删除</li></ol></li><li><code>merge</code>:将制定分支与当前分支合并(git merge TmpBranch 将TmpBranch与当前分支合并）</li><li><code>checkout</code>:切换到分支, tag或者撤销工作目录的修改<ol><li><code>git checkout &lt;branch/tag&gt;</code>: 切换到分支或者tag</li><li><code>git checkout -- &lt;file&gt;</code>: 撤销工作目录&lt;file&gt;的修改,实际上就是用暂存区的文件 替换工作目录</li></ol></li><li><code>diff</code>: 比较工作区与暂存区或者暂存区与版本库的差异<ol><li><code>git diff</code>:工作区与暂存区的diff</li><li><code>git diff --staged</code>: 暂存区与版本库的diff</li></ol></li><li><code>reset</code>:重置, <code>&lt;commit&gt;</code> 如果不指定那么就为 <code>HEAD</code>,可以使用 <code>HEAD^/HEAD~1</code> (父 提交),<br><code>HEAD^^/HEAD~2</code> (父父提交)等类似的语法指定相对于HEAD的偏移.<ol><li><code>git reset &lt;commit&gt; &lt;file&gt;</code>: 不修改引用,但是撤销对文件的暂存,也就是用版本库<br>中的文件替换暂存区中的文件, 工作目录的文件不会变动</li><li><code>git reset --hard &lt;commit&gt;</code>: 将引用设置为commit, 同时用commit的文件替换暂存<br>区和工作目录. <strong>慎用</strong>.</li><li><code>git reset --soft &lt;commit&gt;</code>: 只将引用设置为commit, 不修改暂存区和工作目录</li><li><code>git reset --mixed &lt;commit&gt;</code>: 将引用设置为commit,同时替换暂存区,但是不替换 工作目录</li></ol></li><li><code>blame</code>: 用来确定文件的每一行都是谁修改的</li></ul><h2 id="git一般的工作过程是："><a href="#git一般的工作过程是：" class="headerlink" title="git一般的工作过程是："></a>git一般的工作过程是：</h2><ol><li>git pull(将远程分支与本地分支合并)</li><li>git log（查看其他成员的更改）</li><li>git branch (建一个本地分支）</li><li>git checkout（进入本地分支）</li><li>在该本地分支上进行修改</li><li>git checkout（回到主分支）</li><li>git merge （将分支上所做的工作合并到主分支）</li><li>git branch -d （删除今天创建的分支）</li><li>git pull（将远程仓库合并到本地仓库,很重要，因为今天可能别人修改了远程仓库）</li><li>git push （将本地仓库合并到远程仓库）</li></ol><h1 id="git的原理"><a href="#git的原理" class="headerlink" title="git的原理"></a>git的原理</h1><h2 id="工作区-work-tree"><a href="#工作区-work-tree" class="headerlink" title="工作区(work tree)"></a>工作区(work tree)</h2><p>就是你本地的工作目录树</p><ul><li>git add :将工作区的文件提交到暂存区,暂存区的目录树会更新</li></ul><h2 id="git的暂存区-index"><a href="#git的暂存区-index" class="headerlink" title="git的暂存区(index)"></a>git的暂存区(index)</h2><p>暂存区可以看作一个目录树，暂存区的目录树和版本库的目录树是不同的，.git目录有一个index文件，这个文件包含了<br>git所管理的目录中所有文件的大小以及修改时间，每一次你调用git status或者git<br>diff这类命令时，git都会比较工作<br>区的文件与该index文件中记录的文件的差异，如果发现文件的大小已经改变，那么工作区的文件肯定已经改变，如果发<br>现文件的修改时间已改变，那么git会读取工作区中的文件与暂存区的文件的内容进行比较，如果内容相同，那么git会修<br>改index文件的相应条目的文件时间(因为虽然时间改变了，但文件内容没有改变)，这就是基本的工作流程了</p><ul><li>git commit: 将暂存区的文件提交到版本库</li><li>git reset HEAD : 暂存区的目录树会被当前分支的版本库目录树替换,所以任何未提交的更新都会丢弃,但工作区不受 影响</li><li>git checkout 或者 git checkout – &lt;file&gt;<br>:用暂存区的全部或者部分文件来替换工作区的文件,所以这个操作会清<br>除没有添加到暂存区的工作区改动, <strong>危险操作</strong></li><li>git checkout HEAD 或者 git checkout HEAD &lt;file&gt; :<br>用HEAD指向的版本库分支的全部或者部分文件来替换暂存区与<br>工作区的文件,所以这个操作会清除所有未提交的暂存区与工作区改动. <strong>危险操作</strong></li><li>git rm –cached &lt;file&gt; : 直接删除暂存区中的文件,工作区不受影响</li><li>git rm &lt;file&gt; : 会删除工作区与暂存区的指定文件</li></ul><h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p>由git管理的分支代码的目录树，比如master分支，以及其它你自己创建的分支,当然操作时一般都只是当前分支的目录树</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><ul><li>git diff : 工作区与暂存区比较</li><li>git diff HEAD : 工作区与HEAD比较</li><li>git diff –cached : 暂存区与HEAD比较</li></ul><h2 id="HEAD-master"><a href="#HEAD-master" class="headerlink" title="HEAD, master"></a>HEAD, master</h2><p>HEAD(.git&#x2F;HEAD)实际是一个指针,指向的是.git&#x2F;refs&#x2F;heads&#x2F;branch-name文件,<br>branch-name可以是master或者你自己创 建的分支名,该文件实际指向的是该分支的最新的一次commit,<br>如果当前是master分支,那么这几个文件的内容应该是这 样:</p><ul><li>.git&#x2F;HEAD : “.git&#x2F;refs&#x2F;heads&#x2F;master” 如果用git<br>checkout改变分支,那么master会变成相应的分支名,所以HEAD可<br>以认为一直指向当前分支</li><li>.git&#x2F;refs&#x2F;heads&#x2F;master: 235fd887b9f85d44ce94e8d733b8814509c1d4e8<br>(master分支最新一次提交的id),通过 git reset<br>–[hard|soft|mixed]可以重置该文件到指定的commit<br>id,那么在你指定的commit id之后的提交就都会丢失.</li></ul><h1 id="git-github"><a href="#git-github" class="headerlink" title="git github"></a>git github</h1><ol><li>git remote add remoteName remoteUrl eg: git remote add origin<br><a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;">&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;</a>:youName&#x2F;github-example.git<br>只第一次新建了仓库时才需要运行，实际上是将本地的仓库与远程的仓库关联起来<br>如果出错可以使用命令 git remote rm origin</li><li>git push origin master(将本地的仓库推送到远端）<br>如果报错那么极有可能是远端仓库被别人提交过了，所以要先pull，与本地合并然后在提交<br>git pull origin master</li><li>git pull -u origin master origin是远程分支的名字，master是本地分支的名字</li><li>子模块<ul><li>添加子模块: <code>git submodule add repo-url local-path</code></li><li>clone子模块: <code>git clone --recursive repo-url</code>,<br>如果不指定recursive，那么clone后需要初始化 <code>git submodule update --init --recursive</code></li><li>更新： <code>git submodule update</code></li><li>删除： ubmodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm<br>–cached ”命令将子模块所在的文件从git中删除。</li></ul></li><li>fork后合并原仓库的改变 情景如下：我在github<br>fork一个仓库（<a href="https://github.com/purcell/emacs.d.git">https://github.com/purcell/emacs.d.git</a> ）到我的的账户<br>（<a href="https://github.com/yuyang0/emacs.d.git">https://github.com/yuyang0/emacs.d.git</a> ）然后我将这个fork仓库clone到本地，现在<br>我要合并原仓库的改变。。 first: git remote add purcell<br><a href="https://github.com/purcell/emacs.d.git">https://github.com/purcell/emacs.d.git</a> next: git pull purcell<br>master (git fetch purcell, git merge purcell&#x2F;master) next: git push<br>origin master</li></ol><h1 id="gitignore-syntax"><a href="#gitignore-syntax" class="headerlink" title="gitignore syntax"></a>gitignore syntax</h1><ul><li><p>“#“ ： 注释</p></li><li><p>！ : 取反，即匹配模式的文件不忽略</p></li><li><p>&#x2F; ： &#x2F;结尾被当作目录，该目录的所有文件忽略</p></li><li><p>&#x2F; ： &#x2F;开头则只忽略工作树根目录开始匹配eg：core&#x2F;TODO与&#x2F;core&#x2F;TODO不<br>同，前者只要文件路径包含core&#x2F;TODO（如doc&#x2F;core&#x2F;TODO）即匹配，<br>而后者则只匹配工作树根目录下的core文件夹的TODO文件</p></li><li><p>glob模式：glob模式不同于正则表达式，等同于shell模式下的方式</p><p>*：匹配任意字符<br>?: 匹配任意单个字符<br>[abcd]: 匹配a b c d中的一个<br>[a-z]: 匹配a-z之间的一个字符</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elisp</title>
    <link href="/notes/emacs-lisp/"/>
    <url>/notes/emacs-lisp/</url>
    
    <content type="html"><![CDATA[<h1 id="elisp基本语法"><a href="#elisp基本语法" class="headerlink" title="elisp基本语法"></a>elisp基本语法</h1><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><ul><li>M-x apropos (find symbol)</li><li>C-h k(descripte key)</li><li>C-h f (function)</li><li>C-h v (variable)</li></ul><h2 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h2><ol><li><p><code>if</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs commonlisp">(if test<br>a<br>b)<br>;;test is the condition<br></code></pre></td></tr></table></figure></li><li><p><code>when</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(when condition a b c)<br>;;; equivalent<br>(if condition (progn a b c) nil)<br></code></pre></td></tr></table></figure></li><li><p><code>unless</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(unless condition a b c)<br>;;;equvalent<br>(if condition nil (progn a b c))<br><br></code></pre></td></tr></table></figure></li><li><p><code>cond</code> 和scheme类似:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">cond</span></span> ((<span class="hljs-name">numberp</span> x) x)<br>      ((<span class="hljs-name">stringp</span> x) x)<br>      ((<span class="hljs-name">bufferp</span> x)<br>       (<span class="hljs-name">setq</span> temporary-hack x) <span class="hljs-comment">; multiple body-forms</span><br>       (<span class="hljs-name">buffer-name</span> x))        <span class="hljs-comment">; in one clause</span><br>      ((<span class="hljs-name">symbolp</span> x) (<span class="hljs-name">symbol-value</span> x)))<br></code></pre></td></tr></table></figure></li><li><p><code>and</code> or <code>not</code> logical expression: the function <code>or</code> works like the<br>logical “or” in most languages: if all the arguments are false, it<br>return nil, otherwith it will return the value of the last argument<br>whose value is non-nil. eg: (or nil nil 3 2 1) return 3 (not t) so<br>(if a a b) is identical to (or a b)</p></li><li><p><code>while</code> <strong>Special Form</strong>: while condition forms…</p></li><li><p><code>dolist</code> <strong>Macro</strong>: dolist (var list [result]) body…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(defun reverse (list)<br>  (let (value)<br>    (dolist (elt list value)<br>      (setq value (cons elt value)))))<br></code></pre></td></tr></table></figure></li><li><p><code>dotimes</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(dotimes (i 100)<br>            (insert &quot;I will not obey absurd orders\n&quot;))<br></code></pre></td></tr></table></figure></li></ol><h2 id="let-let"><a href="#let-let" class="headerlink" title="let let"></a>let <span class="tag" data-tag-name="let"><span class="smallcaps">let</span></span></h2><p><code>let</code>, <code>let*</code>, <code>letrec</code> 的作用语法与scheme类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(let ((val1 value1)<br>      (val2 value2))<br>  body)<br></code></pre></td></tr></table></figure><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">(defun func-name (a b &amp;optional c d &amp;rest e) body)<br></code></pre></td></tr></table></figure><p>optional代表参数可选, rest代表可变参数, 如果有那么会是一个列表</p><ol><li><p><code>apply</code>: <code>apply function &amp;rest arguments</code></p><p>调用函数, <code>function</code> 的值是一个symbol(比如你要调用 <code>list</code> 函数,那么你应 该传递 ‘list<br>)最后一个参数必须是列表, 这个列表参数会被apply自动拆开,然后 传递给function</p></li><li><p><code>funcall</code>: 与 <code>apply</code> 不同的是,它不会拆开列表参数, 而是直接将列表参数作为一个 参数传递给function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(setq f &#x27;list)<br>(apply f &#x27;a &#x27;b &#x27;(1 2))                  ; (a b 1 2)<br>(funcall f &#x27;a &#x27;b &#x27;(1 2))                ; (a b (1 2))<br></code></pre></td></tr></table></figure></li></ol><h2 id="lists"><a href="#lists" class="headerlink" title="lists"></a>lists</h2><ul><li><code>null</code>: 测试list是否为空</li><li><code>listp</code>: 是否为list</li><li><code>car</code></li><li><code>cdr</code></li><li><code>cons</code></li><li><code>list</code>: (list ‘a “b” 1) &#x3D;&#x3D;&gt; (a “b” 1)</li><li><code>append</code>: (append ‘(a b) ‘(c d)) &#x3D;&#x3D;&gt; (a b c d)</li><li><code>reverse</code>: (reverse ‘(a b c d)) &#x3D;&#x3D;&gt; (d c b a)</li><li><code>nthcdr</code>: call cdr n times</li><li><code>length</code>: get the length of the list</li><li><code>mapcar</code>:</li><li><code>equal</code>: only test the object’s structure and content</li><li><code>eq</code>: test if the two arguments is the same object(like pointer in<br>C)</li></ul><p><strong>以上的函数都不会原地改变list, 它会返回一个新的list作为结果, 下面的函数会 原地改变list</strong></p><ul><li><code>setcar</code>: change the car-element of the list</li><li><code>setcdr</code>: change the cdr-element of the list</li><li><code>push</code>: 和cons类似,只是会原地改变list</li><li><code>pop</code>: 和car类似,只是会原地改变list(删除list的第一个元素)</li><li><code>add-to-list</code>: 和push类似</li></ul><h3 id="Associate-List"><a href="#Associate-List" class="headerlink" title="Associate List"></a>Associate List</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">((key1 . value1 )<br>(key2 . value2 )<br>(keyn . valuenn ))<br></code></pre></td></tr></table></figure><ul><li><code>assoc</code>: 当list类似于关联数组时，用key来寻找value，用equal测试key</li><li><code>assq</code>: 与assoc相似，只是用eq测试key</li></ul><h3 id="property-list"><a href="#property-list" class="headerlink" title="property list"></a>property list</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(setq alist &#x27;(:publish-dir &quot;~/Documents&quot; :base-dir &quot;~/Documents/note&quot;))<br>(plist-get alist :base-dir)<br></code></pre></td></tr></table></figure><h1 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h1><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ul><li><p><code>length</code>: (length “abc”) –&gt; return 3</p></li><li><p><code>substring</code>: (substring “hello world” 1 3) –&gt; return “ell”</p></li><li><p><code>replace-regexp-in-string</code>: (replace-regexp-in-string regex replace<br>str) –&gt; 正则替换</p></li><li><p><code>string-match</code>: (string-match regex str) –&gt; return the index first<br>match the regex in str</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(setq mystr &quot;The quick fox jumped quickly.&quot;)<br>(string-match &quot;\\(qu\\)\\(ick\\)&quot;<br>                   mystr)   ;=&gt;副作用：将匹配结果存储到match-data中<br>(match-string 0 mystr)      ;=&gt;结果为quick，也就是模式匹配的结果<br>(match-string 1 mystr)      ;=&gt;结果为qu   ，也就是第一个分组的匹配结果<br>(match-string 2 mystr)      ;=&gt;结果为ick  ，也就是第二个分组的匹配结果<br></code></pre></td></tr></table></figure></li></ul><h2 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h2><ol><li>用来匹配字符串时 ^匹配字符串的开头, $匹配字符串的结尾, 用来匹配buffer中的 内容时, ^匹配一行的开头, $匹配一行的结尾.</li><li>常用的字符串匹配函数是string-match, 常用的buffer 内正则匹配的函数是 <code>looking-at</code><br>它会匹配从当前光标开始的内容.</li><li>在通常的语言(比如python)的正则表达式实现中, (, ), [, ], {, }, \ 等都是特 殊字符, 但是在emacs<br>lisp中都是普通的字符,所以如果你要把它们当作特殊的字符, 比如用(,)来分组, 那么你就必须对(,)转义,<br>也就是使用( 与 ), 可是由于 一个普通字符, 所以当你希望它是一个用来转义的特殊字符时, 你必须对<br>义(否则), 结果就是\(, \)这样丑陋的东西. 这是 一个设计失误.</li><li>M-x re-builder: 可以实时的显示buffer中匹配regex的字符串.</li></ol><h2 id="buffer相关：-buffer"><a href="#buffer相关：-buffer" class="headerlink" title="buffer相关： buffer"></a>buffer相关： <span class="tag" data-tag-name="buffer"><span class="smallcaps">buffer</span></span></h2><ul><li><code>buffer-name</code>: (buffer-name)</li><li><code>buffer-file-name</code>: (buffer-file-name) –&gt; full name</li><li><code>save-buffer</code>: (save-buffer) –&gt; 保存当前的buffer 的文件</li><li><code>kill-buffer</code>: (kill-buffer BufferName)</li><li><code>kill-this-buffer</code>: (kill-this-buffer)</li><li><code>with-current-buffer</code>: (with-current-buffer BUFFER-OR_NAME body)<br>–&gt; 将 BUFFER-ORNAME指定的buffer设为当前buffer, body运行完后会恢复原先的buffer, *<br>常用*</li></ul><h3 id="buffer-content相关"><a href="#buffer-content相关" class="headerlink" title="buffer content相关"></a>buffer content相关</h3><ul><li>增: <code>insert</code></li><li>删: <code>delete-char</code>, <code>delete-region</code> 等等一系列的delet函数</li><li>查找: <code>re-search-forward</code> 与 <code>re-search-backward</code> 最 <strong>常用</strong></li><li>替换: 一般是查找后,使用 <code>replace-match</code> 来替换</li><li>获取buffer的内容: <code>buffer-substring</code>, point上的字符可以用 <code>char-after</code> 与<br><code>char-before</code> 来获得, point附近的词可以用 <code>current-word</code> 得到, 其它类 型的文本可以用<br><code>thing-at-point</code>.</li></ul><h3 id="buffer中移动以及光标相关-point"><a href="#buffer中移动以及光标相关-point" class="headerlink" title="buffer中移动以及光标相关 point"></a>buffer中移动以及光标相关 <span class="tag" data-tag-name="point"><span class="smallcaps">point</span></span></h3><ul><li><p><code>point</code> :(point)</p></li><li><p><code>point-max</code> :(point-max) –&gt; 一般返回buffer-end,但是如果指定了Narrowing,<br>那么结果就不同</p></li><li><p><code>point-min</code> :(point-min) –&gt; 一般返回1,但是如果指定了Narrowing,那么结果就 不同</p></li><li><p><code>buffer-end</code> :(buffer-end)</p></li><li><p><code>buffer-size</code> :(buffer-size)</p></li><li><p><code>save-excursion</code> :(save-excursion body) –&gt; 可以用来保存当前的point,不管<br>body中如何改变point,执行完成后都会回到执行save-excursion之前的point</p></li><li><p><code>narrow-to-region</code> :(narrow-to-region start end) –&gt;<br>Narrowing(将emacs的 文本操作限定在buffer的一个子区域中)</p></li><li><p><code>region-beginning</code> :(region-beginning)</p></li><li><p><code>region-end</code> :(region-end) –&gt; line</p></li><li><p><code>beginning-of-line</code> :(beginning-of-line)</p></li><li><p><code>end-of-line</code> :(end-of-line)</p></li><li><p><code>buffer-substring</code> :(buffer-substring start end)</p></li><li><p><code>goto-char</code> :(goto-char 293)</p></li><li><p><code>forward-char</code> :(forward-char n)</p></li><li><p><code>backward-char</code> :(backward-char n)</p></li><li><p><code>skip-chars-forward</code> :(skip-chars-forward “”͡)</p></li><li><p><code>skip-chars-backward</code> :(skip-chars-backward “”͡)</p></li><li><p><code>forward-line</code> :(forward-line n)</p></li><li><p><code>backward-line</code> :(backward-line n)</p></li><li><p><code>looking-at</code> :(looking-at regex) ;; return t if text after the point<br>match the REGEXP</p></li><li><p><code>looking-back</code> :(looking-back regex)</p></li><li><p><code>search-forward</code> :(search-forward my-str)</p></li><li><p><code>search-backward</code> :(search-backward my-str)</p></li><li><p><code>re-search-forward</code> :(re-search-forward my-regex)</p></li><li><p><code>re-search-backward</code> :(re-search-backward my-regex)</p></li><li><p><code>replace-match</code> :(replace-match)</p></li></ul><h2 id="file相关-file"><a href="#file相关-file" class="headerlink" title="file相关 file"></a>file相关 <span class="tag" data-tag-name="file"><span class="smallcaps">file</span></span></h2><ul><li><code>find-file</code>: (find-file path) ;;open a file</li><li><code>write-file</code>: (write-file path) ;;save the file</li><li><code>insert-file-contents</code>: (insert-file-contents path) –&gt;将指定文件内容插入当前位置</li><li><code>append-to-file</code>: (append-to-file start-pos end-pos path)</li><li><code>rename-file</code>: (rename-file old-name new-name)</li><li><code>copy-file</code>: (copy-file file-name new-name)</li><li><code>delete-file</code>: (delete-file file-name)</li><li><code>file-name-directory</code>: (file-name-directory full-path) –&gt;路径（不包含文件名）</li><li><code>file-name-nondirectory</code>: (file-name-nondirectory full-path)<br>–&gt;文件名（不包含路径）</li><li><code>file-name-extension</code>: (file-name-extension file-name) –&gt;后缀,一般时扩展名</li><li><code>file-name-sans-extension</code>: (file-name-sans-extension<br>“&#x2F;hello&#x2F;abc.html”) –&gt;return “&#x2F;hello&#x2F;abc”,只去掉后缀</li></ul><h2 id="other-useful-function"><a href="#other-useful-function" class="headerlink" title="other useful function"></a>other useful function</h2><ul><li><p><code>save-excursive</code>: 保存并恢复当前point</p></li><li><p><code>interactive</code>:</p></li><li><p><code>thing-at-point</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(thing-at-point &#x27;word)<br>(thing-at-point &#x27;sexp)<br>(thing-at-point &#x27;url)<br></code></pre></td></tr></table></figure></li><li><p><code>bounds-of-thing-at-point</code>: 和 <code>thing-at-point</code> 类似,只是它会返回一个 pair –&gt;<br>(start . end) , 这个pair 的car是左边界,cdr是右边界</p></li><li><p><code>current-time-string</code>: (current-time-string) –&gt; 返回当前时间字符串</p></li><li><p><code>format-time-string</code>: (format-time-string “%1.%M %p” (current-time))</p></li><li><p><code>symbol-name</code>: 将symbol转换为字符串, eg: (symbol-name ‘sym) –&gt; “sym”</p></li><li><p><code>intern</code>: 将字符串转换为symbol, eg: (intern “sym”) –&gt; ‘sym</p></li></ul><h2 id="useful-variable"><a href="#useful-variable" class="headerlink" title="useful variable"></a><strong>useful variable</strong></h2><ul><li><code>mark-active</code>: 现在一般用 <code>region-active-p</code> 代替</li><li><code>last-command</code>: 最后一条命令</li></ul><h2 id="useful-code-snippet"><a href="#useful-code-snippet" class="headerlink" title="useful code snippet"></a>useful code snippet</h2><ol><li><p>test if a mode(major or minor) is on (flymake-mode as an example)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(if (and (boundp &#x27;flymake-mode) flymake-mode)<br>    (message &quot;flymake-mode is on&quot;)<br>  (message &quot;flymake-mode is off&quot;))<br></code></pre></td></tr></table></figure></li><li><p>setting keybinding for specified mode <strong>there are two way</strong>, the<br>first is <strong>eval-after-load</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(eval-after-load &quot;org&quot;<br>  &#x27;(progn<br>     (define-key org-mode-map (kbd &quot;&lt;C-M-return&gt;&quot;) &#x27;org-insert-heading-respect-content)<br>     (define-key org-mode-map (kbd &quot;&lt;M-right&gt;&quot;) nil) ; erasing a keybinding.<br>     (define-key org-mode-map (kbd &quot;&lt;M-left&gt;&quot;) nil) ; erasing a keybinding.<br>     ))<br></code></pre></td></tr></table></figure><p>the second way is <strong>add-hook</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(defun my-org-settngs ()<br>    (flyspell-mode 1))<br>(add-hook &#x27;org-mode-hook &#x27;my-org-settngs)<br></code></pre></td></tr></table></figure><p>对以上二者的说明:</p><ol><li>eval-after-load只运行一次,所以比较适合那些一次性的设置,比如给某个特定的mode设置keymap,它没有当前<br>buffer的概念,<br>而add-hook这是对每一个打开了该mode的buffer都会运行一次.所以它适合来设置一些和buffer相<br>关的设置</li><li><strong>local-set-key</strong> 实际上也是调用 <strong>define-key</strong> , 其中 <strong>map</strong> 参数是<br><strong>(current-local-map)</strong> 的值. 这个值 一般是由major mode设置的. 所以在给minor<br>mode设置keymap时,使用 <strong>define-key</strong> 比较好, 因为可以直接指定 minor mode 的map</li></ol></li></ol><h1 id="interactive-interactive"><a href="#interactive-interactive" class="headerlink" title="interactive interactive"></a>interactive <span class="tag" data-tag-name="interactive"><span class="smallcaps">interactive</span></span></h1><p>emacs中交互式运行的命令都需要在函数体的最上方加上(interactive arg-descriptor),<br>arg-descriptor最后会解析成参数从递给该命令, arg-descriptor 有三种形式</p><ol><li><p><code>(interactive)</code> : <code>arg-descriptor</code> 为 <code>nil</code>, 该命令没有参数</p></li><li><p><code>(interactive &quot;p\ncZap to char: &quot;)</code> : <code>arg-descriptor</code> 以 <code>\n</code> 分割后每一<br>部分都会产生一个参数,比如上面的例子,以:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">&quot;p&quot;<br>&quot;cZap&quot;<br></code></pre></td></tr></table></figure><p>其中每一部分开头的那个字母有特殊的含义:</p><ul><li>p: 接受C-u传入的参数,返回的是整数,默认是1,也就是numeric prefix argument.<br>后面不能跟提示字符串,因为参数来自C-u而不是minibuffer</li><li>c: 从minibuffer中读入一个字符,它后面跟的Zap会作为提示显示在minibuffer 中</li></ul><p>除了上面的p, c外还有很多这样的特殊字符,下面是一些常用的,<br>这是官方<a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Interactive-Codes.html#Interactive-Codes">文档</a><br>, 这是一些单词的含义: <strong>Prompt</strong> (后面可以跟显示在minibuffer中提示字符串), <strong>Existing</strong><br>(file, command… 必须已存在), <strong>Completion</strong> (可以补全) :</p><ul><li>P(uppercase): 和小写p的最大区别是它返回的是raw prefix argument, 默认是 nil,<br>后面不能跟提示字符串,因为参数来自C-u而不是minibuffer</li><li>b: 已存在的buffer name, 可以跟提示字符串, 默认是当前buffer, 可以补全</li><li>B: 不存在的buffer name, 可以跟提示字符串, 默认是最近使用的buffer</li><li>f: 已存在的文件名, [Existing, Completion, Default, Prompt]</li><li>F: 不存在的文件名, [Completion, Default, Prompt]</li><li>C(uppercase): 命令名称, [prompt, Existing, Completion]</li></ul></li><li><p><code>(interactive (lisp-expression-return-list-argument))</code> :<br>arg-descriptor是 一个elisp表达式,这个表达式应该产生传递给命令的参数,一般会调用 <code>read-string</code><br>这样的函数从minibuffer中读入字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(interactive (list<br>              (read-string (format &quot;word (%s): &quot; (thing-at-point &#x27;word))<br>                           nil nil (thing-at-point &#x27;word))))<br><br>(interactive<br> (let ((string (read-string &quot;Foo: &quot; nil &#x27;my-history)))<br>   (list (region-beginning) (region-end) string)))<br><br></code></pre></td></tr></table></figure><p>这是 <code>read-string</code> 的原型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">read-string prompt &amp;optional initial history default inherit-input-method<br></code></pre></td></tr></table></figure></li></ol><h1 id="autoload-autoload"><a href="#autoload-autoload" class="headerlink" title="autoload autoload"></a>autoload <span class="tag" data-tag-name="autoload"><span class="smallcaps">autoload</span></span></h1><p>使用autoload可以使一个函数或者命令只在调用时才加载进来,这样可以加快emacs的 启动时间,使用autoload有两种方法:</p><ol><li><p>autoload function filename &amp;optional docstring interactive type</p><p>该函数会将function标记为autoload:</p><ul><li>function: 一个symbol,用来代表函数或者宏</li><li>filename: 一个 <code>string</code>, 用来指定加载function的文件,不要带目录名与后缀 名</li><li>docstring: 文档字符串,指定后可以在没有加载function的情况下看它的文档</li><li>interactive: bool,如果为 <code>t</code> 那么就是一个command,否则就是一个函数</li><li>type:</li></ul></li><li><p>使用魔法注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">;;;###autoload<br>(defun doctor ()<br>  &quot;Switch to *doctor* buffer and start giving psychotherapy.&quot;<br>  (interactive)<br>  (switch-to-buffer &quot;*doctor*&quot;)<br>  (doctor-mode))<br></code></pre></td></tr></table></figure><p>那么这个 <code>doctor</code> 就是标记为autoload的.实际上上面的注释部分会被自动转换 为 <code>autoload</code> 的形式</p></li><li><p>package.el 中的 <code>autoload</code>, 以yasnippet为例, package.el 会根据yasnippet<br>中魔法注释创建一个yasnippet-autoloads.el的文件,该文件就是调用 autoload函<br>数来自动加载yasnippet.el中指定要自动加载的函数,而<br>yasnippet-autoloads.el(所有的package.el管理的包的 -autoloads.el文件)都是是在<br>执行(package-initialize)时运行的.这样每一个包需要自动加载的函数就都加载 进来了</p></li></ol><h1 id="define-mode-minor-mode-or-major-mode"><a href="#define-mode-minor-mode-or-major-mode" class="headerlink" title="define mode(minor mode or major mode)"></a>define mode(minor mode or major mode)</h1><h2 id="keymap"><a href="#keymap" class="headerlink" title="keymap"></a>keymap</h2><p>定义一个mode的时候,通常会用到keymap,keymap规定了该mode下的键映射,可以用如 下的代码来创建一个keymap:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(defvar prelude-mode-map<br>  (let ((map (make-sparse-keymap)))<br>    (define-key map (kbd &quot;C-c o&quot;) &#x27;prelude-open-with)<br>    (define-key map (kbd &quot;C-c g&quot;) &#x27;prelude-google)<br>    ;; ... more define-key sexp<br>    map)<br>  &quot;Keymap for Prelude mode.&quot;)<br></code></pre></td></tr></table></figure><p>上面就创建了一个名为 prelude-mode-map的keymap</p><h2 id="minor-mode"><a href="#minor-mode" class="headerlink" title="minor mode"></a>minor mode</h2><p>创建一个minor mode,需要经过以下几个步骤:</p><ol><li>定义一个变量 xxxx-mode,该变量为 mode varible,如果该 mode已打开,那么这个 变量就为t,否则为nil,<br>这个变量一般要设为buffer local varible</li><li>定义一个命令 xxxx-mode, 注意命令的名字必须和第一步的变量的名字相同,该命 令的作用就是设置第一步的mode<br>varible,当然该命令中也可以添加一些初始化的 操作</li><li>添加一个元素到 minor-mode-alist</li></ol><p>上面的步骤比较繁琐,这里有一个宏, define-minor-mode可以方便的定义一个minor mode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(define-minor-mode prelude-mode<br>  &quot;Minor mode to consolidate Emacs Prelude extensions.<br><br>\\&#123;prelude-mode-map&#125;&quot;<br>  :lighter &quot; Pre&quot;<br>  :keymap prelude-mode-map<br>  (if prelude-mode<br>      ;; on start<br>      (prelude-mode-add-menu)<br>    ;; on stop<br>    (prelude-mode-remove-menu)))<br></code></pre></td></tr></table></figure><p>“ Pre”是要在modeline上显示的字符串,prelude-mode-map是该minor-mode的keymap,<br>下面的body,实际就是 prelude-mode命令了, 可以通过<br>define-globalized-minor-mode 来把minor<br>mode设为global,可以参考这里的<a href="https://github.com/bbatsov/prelude/blob/965e5e2fdbc0babbdb3c149e93d9e7662807d0d7/core/prelude-mode.el#L146">代码</a></p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emacs</tag>
      
      <tag>elisp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emacs</title>
    <link href="/notes/emacs/"/>
    <url>/notes/emacs/</url>
    
    <content type="html"><![CDATA[<h1 id="emacs大杂烩"><a href="#emacs大杂烩" class="headerlink" title="emacs大杂烩"></a>emacs大杂烩</h1><p>这是我的emacs配置：<a href="https://github.com/yuyang0/emacs.d">https://github.com/yuyang0/emacs.d</a><br>,我在<a href="https://github.com/purcell/emacs.d">purcell</a> 的配置的基础<br>上添加了一些我自己的设置.</p><h2 id="编译emacs24"><a href="#编译emacs24" class="headerlink" title="编译emacs24"></a>编译emacs24</h2><p>去官方下载emacs24.4的包。</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libxml2-dev libxslt-dev python-dev libncurses-dev<br>sudo apt-get install build-essential texinfo libx11-dev libxpm-dev<br>sudo apt-get install libjpeg-dev libpng-dev libgif-dev libtiff-dev libgtk2.0-dev<br><br>./configure<br>make<br>sudo make install<br></code></pre></td></tr></table></figure><p>要特别注意libxml2-dev， 这个包部安装，那么eww无法使用。</p><h2 id="emacs各种设置与注意事项"><a href="#emacs各种设置与注意事项" class="headerlink" title="emacs各种设置与注意事项"></a>emacs各种设置与注意事项</h2><h3 id="emacs在英文系统的输入法问题"><a href="#emacs在英文系统的输入法问题" class="headerlink" title="emacs在英文系统的输入法问题"></a>emacs在英文系统的输入法问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">mv /usr/bin/emacs /usr/bin/emacs.raw<br>gedit /usr/bin/emacs<br></code></pre></td></tr></table></figure><p>在文件中输入以下代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">export</span> LC_CTYPE=zh_CN.utf-8<br>/usr/bin/emacs.raw <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="交换ControlL与Capslocks"><a href="#交换ControlL与Capslocks" class="headerlink" title="交换ControlL与Capslocks"></a>交换Control<sub>L与Capslocks</sub></h3><p>通过 xev | grep ‘keycode’得到键码，然后输入以下文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs example">remove Lock = Caps_Lock<br>remove Control = Control_R<br>keycode  66 = Control_R NoSymbol Control_R<br>keycode  105 = Caps_Lock NoSymbol Caps_Lock<br>add Lock = Caps_Lock<br>add Control = Control_R<br></code></pre></td></tr></table></figure><p>保存为.xmodmap，然后运行xmodmap .xmodmap</p><h2 id="auto-complete-complete"><a href="#auto-complete-complete" class="headerlink" title="auto-complete complete"></a>auto-complete <span class="tag" data-tag-name="complete"><span class="smallcaps">complete</span></span></h2><p>一个补全的包,实际可以看作是一个补全选项的展示界面,支持很多后端,这是<a href="http://cx4a.org/software/auto-complete/manual.html">文档</a></p><ol><li>ac-trigger-commands: 一个变量用来指定启动自动补全的命令,默认是self-insert-command</li><li>TAB(ac-expand):有几种行为:如果只有一个候选项,那么直接补全,如果有多个候选<br>项而且候选项有相同的部分,那么补全相同的部分,如果不是以上两种情况,那么就<br>在各个候选项上循环</li><li>RET(ac-complete) : 会补全当前的候选项,如果该候选项有action(如yas),那么执 行该action</li><li>M-n(ac-next)</li><li>M-p(ac-previous)</li></ol><p>有用的变量:</p><ol><li>ac-auto-start: 如果设置为nil, 那么当运行ac-trigger-command中指定的命令时,不<br>会启动自动补全,如果为正数值,那么只有但你输入的字符大于该值时才自动补全,比 如 <code>(setq ac-auto-start 4)</code>,那么只有你输入了4个字符时才会启动自动补全</li><li>ac-auto-show-menu: 自动弹出显示补全菜单,可以设为nil,或者一个数值(延迟妙 数)</li><li>ac-completing-map: 显示了补全菜单后的map,可以设置快捷键</li><li>ac-dwim: dwim ⟶ do what I mean:一般设为nil -After selecting candidates,<br>TAB will behave as RET -TAB will behave as RET only on candidate<br>remains</li></ol><h2 id="grep-grep"><a href="#grep-grep" class="headerlink" title="grep grep"></a>grep <span class="tag" data-tag-name="grep"><span class="smallcaps">grep</span></span></h2><p>如果是想搜索当前buffer，那么你可以是occur，如果你想搜索多个文件，那么可以使 用grep，推荐两个命令</p><ul><li>lgrep：只会搜索当前目录(不搜索子目录)</li><li>rgrep：它会递归搜索子目录</li></ul><p>wgrep包可以是emacs在grep buffer中直接修改文件内容</p><ul><li>C-c C-p: 在grep buffer中只要按该快捷键，就可以在grep buffer直接编辑文件</li><li>C-c C-k: 放弃所有修改</li><li>M-x wgrep-save-all-buffers</li></ul><h2 id="isearch-isearch"><a href="#isearch-isearch" class="headerlink" title="isearch isearch"></a>isearch <span class="tag" data-tag-name="isearch"><span class="smallcaps">isearch</span></span></h2><p>Increment Search.当你搜索时,你每输入一个字符,它会实时的向你展示基于目前的输<br>入所得到的所有匹配项,并自动将光标跳到第一个匹配项<br>C-x C-x:可以在isearch之后回到原来的位置</p><h2 id="dired-dired"><a href="#dired-dired" class="headerlink" title="dired dired"></a>dired <span class="tag" data-tag-name="dired"><span class="smallcaps">dired</span></span></h2><p>dired是一个强大的文件管理器,dired的标记方式有很多种，如标记删除（D标记，用于 删除），<br>如标记为*（m所做的标记就是*标记），默认如果有被*标记的文件，那么所<br>有的文件操作就是在这些标记的文件上进行的，否则就在当前行代表的文件上进行操作，<br>当然还可以有其他类型的标记如t标记，k标记，只是这些标记没有快捷键，一般D标记<br>和*标记用的多，其他标记一般用于临时的转换一下。*c命令可以修改标记，eg：*c D t将D标记修改为t标记，*c t<br>*将t标记修改为*标记</p><ul><li><p>“#“: 标记所有自动保存的文件（D标记）</p></li><li><p>～：标记所有的备份文件（D标记）</p></li><li><p>&amp;： 标记所有的垃圾文件(D标记)</p></li><li><p>d: mark D标记</p></li><li><p>x：执行删除</p></li><li><p>m: mark *标记</p></li><li><p>t: 将所有*标记的文件变为未标记，所有未标记的变为*标记</p></li><li><p>**：标记所有可执行文件</p></li><li><p>*@：标记所有符号链接</p></li><li><p>*s: 标记所有文件</p></li><li><p>*&#x2F;：标记所有目录（不包括. ..)</p></li><li><p>%m or *%: 正则匹配文件名</p></li><li><p>%g：正则匹配所有文件的内容</p></li><li><p>u: unmark</p></li><li><p>常用的文件操作：</p></li><li><p>U: unmark all</p></li><li><p>D: 立即删除</p></li><li><p>R：rename</p></li><li><p>C：copy</p></li><li><p>A: 正则搜索</p></li><li><p>Q：正则替换</p></li><li><p>Z：解压文件</p></li><li><p>L：把lisp文件加载进emacs</p></li><li><p>B：byte compile</p></li><li><p>O：chown</p></li><li><p>G：chgrp</p></li><li><p>M：chmod</p></li><li><p>+：create a directory</p></li><li><p>!: 可以显示打开文件的命令（对pdf等文件不要RET）</p></li></ul><h3 id="wdired-批量改名"><a href="#wdired-批量改名" class="headerlink" title="wdired(批量改名)"></a>wdired(批量改名)</h3><p>C-x C-q : (wdired-change-to-wdired-mode) 进入wdired mode, 进入后就可以像普<br>通的buffer一样编辑文件名(用multiple cursor来编辑多个文件名), 完成后C-c C-c 或者C-x C-s</p><h2 id="ibuffer的快捷键-ibuffer"><a href="#ibuffer的快捷键-ibuffer" class="headerlink" title="ibuffer的快捷键 ibuffer"></a>ibuffer的快捷键 <span class="tag" data-tag-name="ibuffer"><span class="smallcaps">ibuffer</span></span></h2><ul><li>p：prev</li><li>n: next</li><li>m：mark</li><li>u: unmark</li><li>t: mark all</li><li>**: unmark all</li><li>x: kill the marked buffer or current buffer if no buffer marked</li><li>S: save the marked buffer or current buffer if no buffer marked</li><li>D: same as ‘x’</li><li>O: 在所有mark的buffer中正则搜索</li><li>U: 在所有mark的buffer中替换</li><li>Q: 在所有mark的buffer中query，replace</li><li>&#x2F;m: 按主模式过滤</li><li>&#x2F;n: 按名字过滤，可以只输入一部分</li><li>&#x2F;&#x2F;: 撤销过滤，全部显示</li><li>&#x2F;p: 多重过滤时撤销上一层过滤</li><li>&#x2F;f: 过滤filename，与&#x2F;n类似</li></ul><h2 id="cua-mode以及矩形操作的快捷键-cua"><a href="#cua-mode以及矩形操作的快捷键-cua" class="headerlink" title="cua-mode以及矩形操作的快捷键 cua"></a>cua-mode以及矩形操作的快捷键 <span class="tag" data-tag-name="cua"><span class="smallcaps">cua</span></span></h2><ul><li>M-x cua-mode : enable cua-mode</li><li>C-RET: 激活矩形操作，然后就可以常规移动光标来进行列编辑</li><li>C-v : past rectangle</li></ul><h2 id="mutiple-cursors多光标-multiple-cursor"><a href="#mutiple-cursors多光标-multiple-cursor" class="headerlink" title="mutiple cursors多光标 multiple cursor"></a>mutiple cursors多光标 <span class="tag" data-tag-name="multiple"><span class="smallcaps">multiple</span></span> <span class="tag" data-tag-name="cursor"><span class="smallcaps">cursor</span></span></h2><ol><li><p>C-&lt;: mc&#x2F;mark-previous-like-this</p></li><li><p>C-&gt;: mc&#x2F;mark-next-like-this</p></li><li><p>C-c &lt;: mc&#x2F;mark-all-like-this (上面三项功能以word为单位，必须先mark-word)</p></li><li><p>C-c c a:在所有行的开头加入光标</p></li><li><p>C-c c e:在所有行的结尾加入光标</p></li><li><p>C-c c c:在所有的行加入一个光标(上面的三项功能以行为单位，必须先mark数行)</p></li></ol><p>在multiple cursors中isearch是失效的,为了实现C-s, C-r增量搜索,有以下两种方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(defvar jc/mc-search--last-term nil)<br><br>(defun jc/mc-search (search-command)<br>  ;; Read new search term when not repeated command or applying to fake cursors<br>  (when (and (not mc--executing-command-for-fake-cursor)<br>             (not (eq last-command &#x27;jc/mc-search-forward))<br>             (not (eq last-command &#x27;jc/mc-search-backward)))<br>    (setq jc/mc-search--last-term (read-from-minibuffer &quot;Search(regex): &quot;)))<br>  (funcall search-command jc/mc-search--last-term))<br><br>(defun jc/mc-search-forward ()<br>  &quot;Simplified version of forward search that supports multiple cursors&quot;<br>  (interactive)<br>  (jc/mc-search &#x27;search-forward-regexp))<br><br>(defun jc/mc-search-backward ()<br>  &quot;Simplified version of backward search that supports multiple cursors&quot;<br>  (interactive)<br>  (jc/mc-search &#x27;search-backward-regexp))<br><br>(add-hook &#x27;multiple-cursors-mode-enabled-hook<br>          (lambda()<br>            (local-set-key (kbd &quot;C-s&quot;) &#x27;jc/mc-search-forward)<br>            (local-set-key (kbd &quot;C-r&quot;) &#x27;jc/mc-search-backward)))<br><br></code></pre></td></tr></table></figure><p>上述代码放入配置中,就可以开启增量搜索, 还有一种方法是使用phi-search</p><h2 id="ace-jump-mode-ace"><a href="#ace-jump-mode-ace" class="headerlink" title="ace-jump-mode ace"></a>ace-jump-mode <span class="tag" data-tag-name="ace"><span class="smallcaps">ace</span></span></h2><p>类似于火狐的vim插件，输入一个head char，就会在所有匹配的地方放入一个字母</p><ol><li>C-; ：ace-jump-char-mode</li><li>C-: : ace-jump-word-mode</li></ol><h2 id="expand-region-expand-region"><a href="#expand-region-expand-region" class="headerlink" title="expand region expand region"></a>expand region <span class="tag" data-tag-name="expand"><span class="smallcaps">expand</span></span> <span class="tag" data-tag-name="region"><span class="smallcaps">region</span></span></h2><p>这个包可以根据程序的语法结构来选定区域</p><ul><li>C-&#x3D; : 不断的按该快捷键,会使选定的区域不断的扩展,而且只扩展到语法层面的父 结构中,</li></ul><h2 id="paredit-paredit"><a href="#paredit-paredit" class="headerlink" title="paredit paredit"></a>paredit <span class="tag" data-tag-name="paredit"><span class="smallcaps">paredit</span></span></h2><p>该模式下你不能直接编辑括号,而只能通过命令来调整程序结构,主要用于lisp编程</p><ul><li>M-r: 这个命令可以将紧跟着光标后的sexp( <strong>不是当前的sexp, 所以建议将光标放在<br>要操作sexp的左括号的前面</strong>)在树中的位置向上提一层,比如对 <code>let</code><br>中的sexp应用 该命令,那么就可以直接删除 <code>(let ([] ...))</code> 因此该sexp在语法树中的位置就上<br>升了一层,默认该命令会删除该sexp平级的兄弟sexp. 可以通过C-u来指定要将跟着的<br>几个sexp提一层,默认是一个</li><li>M-( : 会用新建() 将跟着光标的sexp包起来</li><li>C-) C-&lt;right&gt; : 会将光标所在的当前表达式的紧挨着的兄弟表达式吞进来</li><li>C-} C-&lt;left&gt; : 将当前sexp包含的最后一个sexp移出去, 可以看作是C-)的逆命令</li><li>M-S : 将一个sexp分成两个sexp,效果就是在光标处添加 “)(“</li><li>M-J : 将两个sexp合并成一个sexp, 比如 <code>(a b) (c d)</code> 变成 <code>(a b c d)</code> 注意<br>光标要放在两个sexp之间,上例中要放在 <code>(a b)</code> 与 <code>(c d)</code> 之间</li></ul><h2 id="ido-Interactively-Do-Things-ido"><a href="#ido-Interactively-Do-Things-ido" class="headerlink" title="ido(Interactively Do Things) ido"></a>ido(Interactively Do Things) <span class="tag" data-tag-name="ido"><span class="smallcaps">ido</span></span></h2><p>使用 <code>C-x b</code> 来切换 <code>buffer</code>,或者使用 <code>C-x C-f</code> 来打开文件时,会自动在 <code>minibuffer</code><br>展示可能的补全项,下面是几个快捷键:</p><ul><li>C-s:后退</li><li>C-r: 前进</li></ul><p>当打开文件时(C-x C-f)时,有以下几个特殊的快捷键</p><ul><li>C-f: 进入emacs内置的find-file</li><li>C-p: 会启动部分匹配，而前面是严格的前缀匹配</li><li>C-t: 正则表达式匹配 eg:*.py$匹配所有python源文件</li><li>C-d: 会使用 <code>dired</code> 打开当前目录</li><li>C-j: 创建新文件(因为当前输入的字符有匹配项时,默认是打开匹配项)</li><li>&#x2F;&#x2F;: 进入根目录</li><li>~&#x2F;: 当前用户的家目录</li><li>M-p: history中的前一条目录</li><li>M-n: history中的后一条目录</li></ul><h3 id="用于编程的命令"><a href="#用于编程的命令" class="headerlink" title="用于编程的命令"></a>用于编程的命令</h3><ul><li>ido-read-file-name: 可以用来读取一个文件名</li><li>ido-read-directory-name: 可以用于获得一个目录名</li><li>idio-read-buffer: 可以用来获得一个buffer name</li><li>ido-completion-read: 这是一个通用的补全命令,需要提供一个列表</li></ul><h3 id="smex-smex"><a href="#smex-smex" class="headerlink" title="smex smex"></a>smex <span class="tag" data-tag-name="smex"><span class="smallcaps">smex</span></span></h3><p>构建于 <code>ido</code> 之上, 在你使用 M-x 运行命令时会提供自动补全</p><h2 id="helm-a-good-alternative-to-ido-helm"><a href="#helm-a-good-alternative-to-ido-helm" class="headerlink" title="helm(a good alternative to ido) helm"></a>helm(a good alternative to ido) <span class="tag" data-tag-name="helm"><span class="smallcaps">helm</span></span></h2><p>一个比较好的可以替换ido,smex的包,功能非常强大, 基本上emacs中出现选择的地方,<br>他都可以用,比如打开文件,切换buffer,kill buffer,<br>M-x等等,下面来说说它的的几 个重点功能</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><ul><li>TAB :打开Action buffer, 对每一个文件可以有许多动作, 比如copy, 比如用外部<br>程序打开,那么这些操作都在这个action buffer中</li><li>C-z: 扩展当前的候选项, 比如你的当前候选项是一个目录, 那么C-z就会进入该目 录,不要按 <code>Enter</code>, 因为那会以<br><code>dired</code> 打开这个目录</li><li>M-&lt;space&gt; : mark 当前的文件</li><li>C-&lt;backspace&gt;: 会禁止自动补全,这在创建新文件与新目录时特别有用(因为如果<br>新的文件名与现在存在的文件名很相似的话,那么helm会自动补全为已存在的文件<br>或目录,因此你也就无法创建新目录)</li><li>新建目录: 在 <code>minibuffer</code> 中正常输入,只是最后要以 &#x2F; 结尾, helm会提示创建 新目录</li><li>复制文件: 先mark文件,然后TAB 选择copy file, 选择目的地就好</li><li>移动文件: 和复制文件类似</li></ul><h3 id="ediff-ediff"><a href="#ediff-ediff" class="headerlink" title="ediff ediff"></a>ediff <span class="tag" data-tag-name="ediff"><span class="smallcaps">ediff</span></span></h3><p>第一个文件TAB上选择ediff action,自动弹出第二个helm-find-files选择第二个文 件, <strong>强力推荐</strong></p><h3 id="grep-increment-grep-grep"><a href="#grep-increment-grep-grep" class="headerlink" title="grep(increment grep) grep"></a>grep(increment grep) <span class="tag" data-tag-name="grep"><span class="smallcaps">grep</span></span></h3><p><strong>helm-do-grep</strong> : helm中执行grep的命令,你也可以使用 helm-find-files然后TAB 选择grep,<br>如果使用 C-u M-x helm-do-grep, 那么就会递归的在目录中搜索</p><h3 id="locate-locate"><a href="#locate-locate" class="headerlink" title="locate locate"></a>locate <span class="tag" data-tag-name="locate"><span class="smallcaps">locate</span></span></h3><p>M-x helm-locate: 使用操作系统的locate所产生的数据库文件来搜索文件</p><h2 id="w3m-w3m-w3c"><a href="#w3m-w3m-w3c" class="headerlink" title="w3m w3m w3c"></a>w3m <span class="tag" data-tag-name="w3m"><span class="smallcaps">w3m</span></span> <span class="tag" data-tag-name="w3c"><span class="smallcaps">w3c</span></span></h2><p>w3m 是一个文本浏览器，它不支持CSS与js，非常适合浏览文本很多的页面，以及避免 在emacs与firefox切换带来的烦恼。。</p><p><strong>links</strong></p><ul><li>g: Prompt for a url in minibuffer (w3m-browse-url)</li><li>G: same as <strong>g</strong> excepte it open a new session(a new tab)</li><li>R: reload the page</li><li>S: search engion</li><li>H: goto home page</li><li>B: go back(history)</li><li>N: go next(hostory)</li><li>u: display the under the point in the echo area</li><li>RET: Display the page pointed by the link under point<br>(w3m-view-this-url)</li><li>\[: move point to previous form</li><li>\]: move point to next form</li><li>TAB: move point to next link</li><li>M-TAB, S-TAB: move point to previous link</li><li>d: download thee url under the point</li><li>M-d: Download the url</li></ul><p><strong>scroll</strong></p><ul><li>SPC: scroll downwards</li><li>&gt;: scroll to the right</li><li>&lt;: scroll to the left</li><li>DEL: scroll upwards</li></ul><p><strong>bookmarks</strong></p><ul><li>v: show all bookmarks</li><li>a: add current url to bookmarks</li><li>M-a: Add the url under point to the bookmark.</li><li>C-k: kill a bookmark</li><li>E: edit bookmark</li></ul><p><strong>move in page</strong></p><ul><li>hjkl: like vim</li></ul><p><strong>switch tabs</strong></p><ul><li>C-c C-n: next tab</li><li>C-c C-p: previous tab</li><li>C-c C-t: new tab</li></ul><p><strong>images</strong></p><ul><li>I: Display the image under point in the external viewer.</li><li>M-i: Save the image under point to a file.</li><li>t: Toggle the visibility of an image under point</li><li>T: Toggle the visibility of all images</li><li>M-T: turn off to display all images</li><li>M-[: zoom in an image on the point</li><li>M-]: zoom out an image on the point</li></ul><h2 id="ansi-term-shell-term"><a href="#ansi-term-shell-term" class="headerlink" title="ansi-term shell term"></a>ansi-term <span class="tag" data-tag-name="shell"><span class="smallcaps">shell</span></span> <span class="tag" data-tag-name="term"><span class="smallcaps">term</span></span></h2><p>终端模拟器,基本上terminal的所有功能.</p><ul><li>C-c C-j: 进入line mode， 可以复制</li><li>C-c C-k: 回到character mod</li></ul><h2 id="magit-magit"><a href="#magit-magit" class="headerlink" title="magit magit"></a>magit <span class="tag" data-tag-name="magit"><span class="smallcaps">magit</span></span></h2><p>一个git扩展,功能强大.这是一篇介绍<a href="http://www.masteringemacs.org/articles/2013/12/06/introduction-magit-emacs-mode-git/">文章</a>,<br>这是一份命令<a href="http://daemianmack.com/magit-cheatsheet.html">列表</a></p><ul><li>M-x magit-status(我的快捷键 M-f12): 进入magit的buffer</li><li>M-[1-4]: 其中我用 M-2 与 M-4,前者只显示文件,后者会显示diff</li><li>1 2 3 4: 和上面类似,只是前面带M则会应用到所有的entry, 而单独按数字只会应用 到当前的entry</li><li>s : stage</li><li>c : commit</li><li>i : 将文件添加到.gitignore</li><li>C-u i : 提示你输入要加入.gitignore的文件或者目录</li><li>b : 切换到一个已存在的分支</li><li>B : 创建并切换到新分支</li></ul><h2 id="我设置的快捷键以及我常用的快捷键，函数-shortcut"><a href="#我设置的快捷键以及我常用的快捷键，函数-shortcut" class="headerlink" title="我设置的快捷键以及我常用的快捷键，函数 shortcut"></a>我设置的快捷键以及我常用的快捷键，函数 <span class="tag" data-tag-name="shortcut"><span class="smallcaps">shortcut</span></span></h2><ul><li><p>M-x browse-url: 通过浏览器打开当前url</p></li><li><p>C-g C-&#x2F;: redo</p></li><li><p>C-x C-v: find-alternate-file(fresh buffer)</p></li><li><p>C-x C-m: 替代M-x,按M很别扭</p></li><li><p>M-c : capticalize-word</p></li><li><p>M-u : upcase-word</p></li><li><p>C-x C-u : upcase-region</p></li><li><p>M-l : downcase-word</p></li><li><p>C-x C-l: downcase-region</p></li><li><p>C-c p: 复制粘贴一行或者选中的region</p></li><li><p>C-c j: 将当前行与上一行合并成一行</p></li><li><p>M-up: Shift lines up</p></li><li><p>M-down: Shift lines down</p></li><li><p>M-x occur: 创建一个新的buffer，然后将当前buffer，所有匹配regex的内容显示其<br>中,进入该buffer，enter就可以跳转</p></li><li><p>M-x imenu：可以根据类型跳转（变量，函数,include等等）</p></li><li><p>C-k: kill the current line</p></li><li><p>C-o: new line and indent,like the ‘o’ in vim</p></li><li><p>M-;: comment or uncomment the region</p></li><li><p>M-j: 这个在多行注释时,可以换行,换行时会在行首自动添加comment-prefix字符(C 语言是*),<br>如果使用C-j或者RET就不会添加该字符</p></li><li><p>C-&#x2F;: undo (same as C-x u and C-_)</p></li><li><p>C-c d: translate the word using sdcv</p></li><li><p>C-c f: 迭代的搜索字符，eg：C-c f g会移到第一个g，在按g移到 第二个g</p></li><li><p>% : jump to the matched parenthesis</p></li><li><p>C-c -: fold the code</p></li><li><p>C-c &#x3D;: unfold the code</p></li><li><p>C-M-f: 表达式的首部</p></li><li><p>C-M-b:</p></li><li><p>C-M-a: 函数的首部</p></li><li><p>C-M-e：</p></li><li><p>C-x backspace: 删除到行首</p></li><li><p>C-M-h: 标记一个函数</p></li><li><p>M-u: 一个字改为大写</p></li><li><p>M-l：一个字改为小写</p></li><li><p>C-x C-u：region to uppercase</p></li><li><p>C-x C-l：区域小写</p></li><li><p>C-t：将光标前后的字符交换</p></li><li><p>C-x C-t: 光标所在行与上一行交换</p></li></ul><h2 id="emacs导出pdf的中文支持-pdf-chinese"><a href="#emacs导出pdf的中文支持-pdf-chinese" class="headerlink" title="emacs导出pdf的中文支持 pdf chinese"></a>emacs导出pdf的中文支持 <span class="tag" data-tag-name="pdf"><span class="smallcaps">pdf</span></span> <span class="tag" data-tag-name="chinese"><span class="smallcaps">chinese</span></span></h2><p>org-mode默认的导出系统对中文支持不好,我参考这篇<a href="http://yzprofile.me/2013/01/14/emacs-org-mode-xelatex.html">文章</a>,<br>将导出中文pdf的方法总结如下:</p><ol><li><p>安装textlive,如果是ubuntu,运行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install texlive texlive-xetex textlive-latex-extra<br></code></pre></td></tr></table></figure><p>textlive-latex-extra一定要装,不装会有File `wrapfig.sty’ not found.的错误</p></li><li><p>在emacs配置文件中添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">;; org-mode &lt; 8.0<br>(setq org-latex-to-pdf-process &#x27;(&quot;xelatex -interaction nonstopmode %f&quot;<br>                                 &quot;xelatex -interaction nonstopmode %f&quot;))<br>;;  org-mode 8.0<br>(setq org-latex-pdf-process &#x27;(&quot;xelatex -interaction nonstopmode %f&quot;<br>                              &quot;xelatex -interaction nonstopmode %f&quot;))<br></code></pre></td></tr></table></figure></li><li><p>在org文档的开头部分添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">#+LATEX_HEADER: \usepackage&#123;xeCJK&#125;<br>#+LATEX_HEADER: \setCJKmainfont&#123;SimSun&#125;<br></code></pre></td></tr></table></figure></li><li><p>找不到<br>【SMIKAI.TTF】字体的错误，参考这篇<a href="https://huxuan.org/2012/07/14/chinese-font-problem-of-ctex-in-texlive-under-linux/">文章</a></p></li></ol><h2 id="emacs的奇淫技巧-face"><a href="#emacs的奇淫技巧-face" class="headerlink" title="emacs的奇淫技巧 face"></a>emacs的奇淫技巧 <span class="tag" data-tag-name="face"><span class="smallcaps">face</span></span></h2><ul><li>M-x flush-lines RET ^$ RET :删除所有的空行（正则匹配）</li><li>M-x list-faces-display: 显示faces，在很多需要颜色，字体样式的命令中需要face参数</li><li>绑定快捷键时用C-h k查询得到的内容可以直接放在kbd后</li><li>indent-region可以格式化所有的代码</li></ul><h2 id="我写的一些命令"><a href="#我写的一些命令" class="headerlink" title="我写的一些命令"></a>我写的一些命令</h2><h3 id="短网址-dwz-tinyurl"><a href="#短网址-dwz-tinyurl" class="headerlink" title="短网址 dwz tinyurl"></a>短网址 <span class="tag" data-tag-name="dwz"><span class="smallcaps">dwz</span></span> <span class="tag" data-tag-name="tinyurl"><span class="smallcaps">tinyurl</span></span></h3><p>使用百度的dwz.cn(之所以不用t.cn, 是因为它的api要求app key,比较麻烦)来缩短网 址,<br>会自动将得到的短网址插入当前buffer, 依赖request, emacs24可以通过<br>M-x package-install request安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(require &#x27;request)<br>(require &#x27;json)<br>(defun dwz-url-shorten (long-url)<br>  &quot;shorten url with dwz.cn&quot;<br>  (interactive (list<br>                (read-string (format &quot;long url (%s): &quot; (thing-at-point &#x27;url))<br>                             nil nil (thing-at-point &#x27;url))))<br>  (request<br>   &quot;http://dwz.cn/create.php&quot;<br>   :type &quot;POST&quot;<br>   ;; :data &#x27;((&quot;url&quot; . long-url))<br>   :data (format &quot;url=%s&quot; long-url)<br>   ;; :data &quot;key=value&amp;key2=value2&quot;  ; this is equivalent<br>   :parser &#x27;json-read<br>   :success (function*<br>             (lambda (&amp;key data &amp;allow-other-keys)<br>               (let ((tinyurl (assoc-default &#x27;tinyurl data))<br>                     (url-boundaries (bounds-of-thing-at-point &#x27;url)))<br>                 (progn<br>                   (message &quot;%S&quot; tinyurl)<br>                   (if url-boundaries<br>                       (goto-char (cdr url-boundaries)))<br>                   (insert &quot; &quot; tinyurl &quot; &quot;)))))))<br><br></code></pre></td></tr></table></figure><p>我写了一个包<a href="https://github.com/yuyang0/url-shortener">url-shortener</a> ,你可以通过<br>elpa 安装,这个包支持 dwz.cn,126.am,bit.ly,goo.gl.</p><h2 id="elpa-elpa"><a href="#elpa-elpa" class="headerlink" title="elpa elpa"></a>elpa <span class="tag" data-tag-name="elpa"><span class="smallcaps">elpa</span></span></h2><h3 id="proxy-goagent代理-proxy"><a href="#proxy-goagent代理-proxy" class="headerlink" title="proxy(goagent代理) proxy"></a>proxy(goagent代理) <span class="tag" data-tag-name="proxy"><span class="smallcaps">proxy</span></span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(setq url-proxy-services &#x27;((&quot;no_proxy&quot; . &quot;work\\.com&quot;)<br>                           (&quot;http&quot; . &quot;localhost:8087&quot;)))<br></code></pre></td></tr></table></figure><h2 id="emacsclient-emacsclient-server"><a href="#emacsclient-emacsclient-server" class="headerlink" title="emacsclient emacsclient server"></a>emacsclient <span class="tag" data-tag-name="emacsclient"><span class="smallcaps">emacsclient</span></span> <span class="tag" data-tag-name="server"><span class="smallcaps">server</span></span></h2><p>使用emacs server配合emacsclient可以很大程度上解决emacs启动慢的烦恼,启动 emaca server的方法有两种:</p><ol><li>shell 中运行 emacs –daemon</li><li>启动的emacs中运行 <code>(server-start)</code> 命令</li></ol><p>我个人在桌面环境中喜欢第二种方法,也就是先打开一个emacs窗口作为server端,以后<br>在打开文件时都使用emacsclient,在emacsclient使用过程中有几个注意事项(server<br>创建的frame称为 Server Frame,emacsclient创建的Frame称为 Client Frame):</p><ol><li>emacsclient创建frame来打开文件时,它创建一个server buffer,如果你在 Client<br>Frame中编辑完成,使用C-x C-c来退出该 Client frame,那么该server<br>buffer就会 从server端删除,但server不会退出</li><li>如果你直接在server端的 Server Frame中编辑server buffer,如果编辑完成那么 你可以按C-x #<br>来kill掉该buffer,同时也会让对应的emacsclient创建的 Client Frame退出</li></ol><h2 id="org-mode-org"><a href="#org-mode-org" class="headerlink" title="org-mode org"></a>org-mode <span class="tag" data-tag-name="org"><span class="smallcaps">org</span></span></h2><p>org-mode是一个神器,有许多强大的功能</p><h3 id="org-mode的快捷键与命令"><a href="#org-mode的快捷键与命令" class="headerlink" title="org-mode的快捷键与命令"></a>org-mode的快捷键与命令</h3><ul><li>org-w3m-copy-for-org-mode: 在w3m中可以带链接，图片拷贝到org中（先选中region）</li><li>tab，S-tab</li><li>C-c C-n: next tiltle</li><li>C-c C-p: prev tilte</li><li>C-c C-f: 平级的上一个标题</li><li>C-c C-b：平级的下一个标题</li><li>C-c C-u：上一级标题：next</li><li>M-RET : 插入同级标题</li><li>M-S RET：插入一个同级的TODO标题</li><li>M-LEFT&#x2F;RIGHT: 标题升&#x2F;降级</li><li>M-S-LEFT&#x2F;RIGHT：子树升&#x2F;降级</li><li>C-c*：将本行设置为标题</li><li>C-c C-l: insert a link</li><li>C-c C-o: open a link</li><li>C-c C-c : 当在标题上时,可以用来插入标签</li><li>C-c C-q : 为当前标题插入标签</li><li>C-c \ : org-match-sparse-tree</li></ul><p><strong>内容元数据及其快捷键：</strong></p><ul><li>&lt;v tab: begin\<sub>verse</sub> 区域内换行</li><li>&lt;s tab: begin\<sub>src</sub> 区域内为代码 按 <strong>C-c C-‘</strong> 进入主模式编辑，在按退出</li><li>&lt;e tab: begin\<sub>example</sub> 例子，每行以：开始</li><li>&lt;q tab: begin\<sub>quote</sub> 区域左右都会留出缩进，用于引用</li><li>&lt;c tab: begin\<sub>center</sub> 居中区域</li><li>&lt;l tab: begin\<sub>latex</sub></li><li>&lt;h tab: begin\<sub>html</sub> 嵌入html</li><li>&lt;a tab: begin\<sub>ascii</sub></li></ul><h3 id="org-mode的一些格式化语法"><a href="#org-mode的一些格式化语法" class="headerlink" title="org-mode的一些格式化语法"></a>org-mode的一些格式化语法</h3><ul><li>链接: “【【link】【descripter】】”（用英文的方括号）</li><li>org-mode能自动识别链接，如http，file等</li><li>有序列表；1. 2. 3.</li><li>无序列表：*，+，-开头都可以</li><li>注解的格式：方括号+数字，或者方括号+fn+数字 C-c C-c可以在注解与正文之间跳转</li></ul><p>(下面的格式，开头结尾必须都是空格或标点)</p><ul><li>粗体(*): <strong>粗体</strong></li><li>斜体(&#x2F;): <em>斜体</em></li><li>删除线(\+): <del>删除线</del></li><li>下划线(\_): <span class="underline">下划线</span></li><li>下标：H<sub>2</sub> O(会将\<sub>后的字符串加上下标</sub>，空格为截止符)</li><li>上标：E&#x3D;mc<sup>2</sup> (同上)</li><li>等宽字: <code>pair?</code> 或者 <code>pair?</code> 在文章中插入一小段代码或者变量时很有用(可以 突出重点)</li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ol><li><p>基本使用</p><p>在某一行的顶格输入‘|’，然后输入第一行第一列，在输入‘|’，接着第一行第二<br>列，依次类推，完成后tab，会将当前行对齐并为你创造表格的下一行，tab和<br>S-tab可以在表格中正向或者反向的移动，在表格的空白项中输入数字eg:&lt;6&gt;则 限定为6个字符长，多余的部分会隐藏，用C-c<br>C-c可以展开</p></li><li><p>技巧</p><ol><li><p>在表格的两行之间之间插入 |- 然后TAB, 可以在表格中插入一个|—<del>—</del>–|类 似的行,可以用于区分表头行与数据行</p></li><li><p>表格内的公式运算</p><table><thead><tr><th align="center">单价</th><th align="center">数量</th><th align="center">总价</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">2.5</td><td align="center">5.</td></tr><tr><td align="center">3</td><td align="center">3.5</td><td align="center">10.5</td></tr><tr><td align="center">4</td><td align="center">4.5</td><td align="center">18.</td></tr></tbody></table><p><img src="/static/img/org-table-formula.gif"> 注意$1 代表第一列, $2代表第二列,<br>一般表格会自动计算,如果要强制自动计算 可以使用C-u C-c C-c或者M-x<br>org-table-recalculate-buffer-tables</p></li></ol></li></ol><h3 id="org-mode-TODO-list"><a href="#org-mode-TODO-list" class="headerlink" title="org-mode TODO list"></a>org-mode TODO list</h3><p>在一个标题上按shift+left&#x2F;right，C-c C-t可以设置todo list的状态</p><h3 id="org-mode-中的latex代码"><a href="#org-mode-中的latex代码" class="headerlink" title="org-mode 中的latex代码"></a>org-mode 中的latex代码</h3><p>为了在org-mode中高亮latex代码,同时使latex能在html以及pdf中都能生效,不要使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">#+BEGIN_LaTeX<br><br>#+END_LaTeX<br></code></pre></td></tr></table></figure><p>上面的代码不能高亮latex代码,同时它只在导出pdf时有效,所以你应该使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example">#+BEGIN_SRC latex :exports results :results value raw<br>  \begin&#123;equation&#125;<br>    P(X=i) = \frac&#123;e^&#123;-\lambda&#125;\lambda^i&#125; &#123;i!&#125;<br>  \end&#123;equation&#125;<br>#+END_SRC<br></code></pre></td></tr></table></figure><p>注意后面的results选项,它会将裸的latex代码直接放入导出的html或者tex文件,org-mode可以自动处理这种裸的latex<br>代码,这种裸的latex代码,可以有以下这几种形式:</p><p>行内latex代码有下面两种界定符(如果你的latex代码有,org-mode会自动识别):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">$\lambda = np$     ==&gt; $与代码之间不要有空格,第二个$后要跟空格,标点符号或破折号<br>\(\lambda=np\)<br></code></pre></td></tr></table></figure><p>多行latex代码时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">\begin&#123;environment&#125;<br>  latex code<br>\end&#123;environment&#125;<br></code></pre></td></tr></table></figure><p>注意begin, end必须位于忽略空格后的行首</p><h3 id="org-mode中的latex代码的预览"><a href="#org-mode中的latex代码的预览" class="headerlink" title="org-mode中的latex代码的预览"></a>org-mode中的latex代码的预览</h3><p>org-mode中的latex代码可以预览,这是官方<a href="http://orgmode.org/worg/org-tutorials/org-latex-preview.html">文档</a>,<br>有以下几个快捷键与命令:</p><ol><li>C-c C-x C-l, 命令是org-preview-latex-fragment.</li><li>C-u C-c C-x C-l: 预览该子树的所有latex代码</li><li>C-u C-u C-c C-x C-l 预览当前buffer中的所有latex代码</li></ol><p>latex代码预览的原理是先创建一个临时的tex文件, 然后调用latex程序来处理该tex文件生成dvi文件,然后根据dvipng或<br>者imagemagick(convert)来生成png图片, 有几点注意事项:</p><ol><li><p>LATEX<sub>HEADER指定的内容会包含进临时的tex文件</sub>, 而<br>LATEX<sub>HEADEREXTRA指定的内容则不会包含进临时tex文件</sub></p></li><li><p>有两种方法来预览latex代码: dvipng(默认) 和 imagemagick,可以通过如下代码设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(setq org-latex-create-formula-image-program &#x27;dvipng)<br>;;; or<br>(setq org-latex-create-formula-image-program &#x27;imagemagick)<br></code></pre></td></tr></table></figure></li><li><p>dvipng会调用标准latex程序(比如latexpdf)来处理tex文件, 这情况下,建议加入额外的不能被标准latex处理的宏包<br>(比如中文的xeCJK)时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">#+LATEX_HEADER_EXTRA: \usepackage&#123;xeCJK&#125;<br>#+LATEX_HEADER_EXTRA: \setCJKmainfont&#123;SimSun&#125;<br></code></pre></td></tr></table></figure><p>而不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">#+LATEX_HEADER: \usepackage&#123;xeCJK&#125;<br>#+LATEX_HEADER: \setCJKmainfont&#123;SimSun&#125;<br></code></pre></td></tr></table></figure><p>因为后者会将xeCJK包含在临时的tex文件中,而这个tex文件需要xetex来处理,所以在预览时会报错</p></li><li><p>会调用org-latex-pdf-process 指定的程序来处理,这种情况不会出现3中的问题,可是据我测试,生成图片的速度比3慢,而<br>且显示图片过大,所以推荐第三种方式</p></li></ol><h3 id="org-mode中latex导出html时的设置"><a href="#org-mode中latex导出html时的设置" class="headerlink" title="org-mode中latex导出html时的设置"></a>org-mode中latex导出html时的设置</h3><ol><li><p>使用MaxJax.js (推荐,默认)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">#+HTML_MATHJAX: align:&quot;left&quot; mathml:t path:&quot;/MathJax/MathJax.js&quot;<br></code></pre></td></tr></table></figure><p>上述代码不是必须的,因为org-mode会自动添加一个org-mode官方的MathJax.js的链接到html,但是为了减轻org-mode<br>服务器的压力,还是建议你加入上述代码并使用MathJax官方的cdn:<br><a href="http://cdn.mathjax.org/mathjax/latest/MathJax.js">http://cdn.mathjax.org/mathjax/latest/MathJax.js</a><br>,更好的做法是在配置文件中加入如下代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs commonlisp">(setq org-html-mathjax-options &#x27;((path &quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;)<br>                                 (scale &quot;100&quot;)<br>                                 (align &quot;center&quot;)<br>                                 (indent &quot;2em&quot;)<br>                                 (mathml t)))<br></code></pre></td></tr></table></figure><p>这是全局的,如果要单个buffer那么就使用 HTML<sub>MATHJAX文件头</sub></p></li><li><p>将latex代码的处理结果导出成图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example"> #+OPTIONS: tex:dvipng<br>or<br> #+OPTIONS: tex:imagemagick<br></code></pre></td></tr></table></figure><p>注意系统中必须要安装dvipng, imagemagik</p></li></ol><h3 id="org-mode导出project以及html的注意事项"><a href="#org-mode导出project以及html的注意事项" class="headerlink" title="org-mode导出project以及html的注意事项"></a>org-mode导出project以及html的注意事项</h3><ol><li>在文件中指定的 <code>#+HTML_HEAD #+HTML_HEAD_EXTRA</code> 会覆盖在<br><code>org-publish-project-alist</code> 中指定的 <code>:html-head :html-head-extra</code>.在配 置中<br>:html-head只能出现一次, 多次出现则只有最后一次生效,因为实际是一个 property list</li><li><code>org-publish-project-alist</code> 的option<br><a href="http://orgmode.org/manual/Publishing-options.html#Publishing-options">文档</a></li><li>html 导出的<a href="http://orgmode.org/manual/HTML-export.html#HTML-export">文档</a></li></ol><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>通过Babel,你可以直接在org-mode中运行各种编程语言的代码,每一个代码片段都组织为一个block,<br>可以向这个代码片段传递参数,同时每一个代码片段都可以产生输出,而这个输出又可以作为输入传递<br>给另一个代码片段,关于Babel的详细介绍可以看这篇官方的<a href="http://orgmode.org/worg/org-contrib/babel/intro.html">Instruction</a><br>与这篇<a href="static/doc/babel.pdf">pdf</a> ,特别是后者, 建议认真看看,只有26页,Babel的基本结构分为数据块和代码块<br>数据块:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>#+name: &lt;name&gt;<br>&lt;data block body&gt;<br><br></code></pre></td></tr></table></figure><p>使用该数据时,直接引用&lt;name&gt;就好 代码块:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>#+name: &lt;name&gt;<br>#+headers: &lt;header arguments&gt;<br>#+begin_src &lt;language&gt; &lt;header arguments&gt;<br> &lt;body&gt;<br>#+end_src<br><br></code></pre></td></tr></table></figure><ul><li><p>name: 如果指定,那么最后得到结果就会赋给该变量,可以通过该变量将代码块的执行结果作为参数传递给其他代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>#+name: ret1<br>#+BEGIN_SRC python :results output<br>print &#x27;hello world&#x27;<br>#+END_SRC<br><br>#+RESULTS: ret1<br>: hello world<br><br>#+BEGIN_SRC sh :var arg=ret1<br>echo $arg<br>#+END_SRC<br><br>#+RESULTS:<br>: hello world<br><br></code></pre></td></tr></table></figure></li><li><p>language: 代码的类型,eg: C, cpp, python, ruby</p></li><li><p>header-arguments: 头部参数,头部参数可以放在两个地方:代码块的上方以及&lt;language&gt;后,常用的头部参数:</p><ol><li><p>:results output(捕捉输出), :results value<br>(default,捕捉最后一个表达式的结果,代码块当做一个函数)</p></li><li><p>:file aa.png (将输出存入文件,下面会加入链接,这对于输出是图片(eg:gunplot)时非常方便)</p></li><li><p>:dir ~&#x2F;Documents (将~&#x2F;Documents 作为运行代码的进程的当前目录)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>#+headers: :dir ~/Documents/blog<br>#+BEGIN_SRC sh<br>echo $PWD<br>#+END_SRC<br><br>#+RESULTS:<br>: /home/yangyu/Documents/blog<br></code></pre></td></tr></table></figure></li><li><p>:var n&#x3D;5 (传递一个变量n给code block,并且其值为5)</p></li><li><p>:exports both (输出code与results), :exports code(默认), :exports<br>results, :exports none</p></li></ol></li></ul><p>现在我放入几个例子:</p><h3 id="dot"><a href="#dot" class="headerlink" title="dot"></a>dot</h3><p>dot语言可以用来画流程图，和Babel结合起来非常方便，这是一份dot语言的<a href="static/doc/dotguide.pdf">guide</a></p><h1 id="emacs让人困惑的问题"><a href="#emacs让人困惑的问题" class="headerlink" title="emacs让人困惑的问题"></a>emacs让人困惑的问题</h1><h2 id="overwrite-mode"><a href="#overwrite-mode" class="headerlink" title="overwrite mode"></a>overwrite mode</h2><p>该mode打开的话，会替换光标后面的字符，而不是插入，非常令人不爽</p><h2 id="whitespace-mode"><a href="#whitespace-mode" class="headerlink" title="whitespace-mode"></a>whitespace-mode</h2><p>该mode打开后,默认会在所有的空格位置显示一个 . ,并且在行尾显示一个$, 可以使 用这个mode来高亮一行中超过80的部分</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emacs</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
