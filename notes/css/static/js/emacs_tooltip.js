// -*- coding: utf-8 -*-

// © 2013 Xah Lee, http://xahlee.info/
// if you use, please give credit and link. Thanks.

"use strict";

var unicodedata =
{
"abbrev-mode":"abbrev-mode is an interactive compiled Lisp function in `abbrev.el'.••(abbrev-mode &amp;optional ARG)••Toggle Abbrev mode in the current buffer.•With a prefix argument ARG, enable Abbrev mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•Abbrev mode if ARG is omitted or nil.••In Abbrev mode, inserting an abbreviation causes it to expand and•be replaced by its expansion.",
"abbrev-prefix-mark":"abbrev-prefix-mark is an interactive compiled Lisp function in•`abbrev.el'.••(abbrev-prefix-mark &amp;optional ARG)••Mark current point as the beginning of an abbrev.•Abbrev to be expanded starts here rather than at beginning of word.•This way, you can expand an abbrev with a prefix: insert the prefix,•use this command, then insert the abbrev.  This command inserts a•temporary hyphen after the prefix (until the intended abbrev•expansion occurs).•If the prefix is itself an abbrev, this command expands it, unless•ARG is non-nil.  Interactively, ARG is the prefix argument.",
"abort-recursive-edit":"abort-recursive-edit is an interactive built-in function in `C source•code'.••(abort-recursive-edit)••Abort the command that requested this recursive edit or minibuffer input.",
"add-hook":"add-hook is a compiled Lisp function in `subr.el'.••(add-hook HOOK FUNCTION &amp;optional APPEND LOCAL)••Add to the value of HOOK the function FUNCTION.•FUNCTION is not added if already present.•FUNCTION is added (if necessary) at the beginning of the hook list•unless the optional argument APPEND is non-nil, in which case•FUNCTION is added at the end.••The optional fourth argument, LOCAL, if non-nil, says to modify•the hook's buffer-local value rather than its global value.•This makes the hook buffer-local, and it makes t a member of the•buffer-local value.  That acts as a flag to run the hook•functions of the global value as well as in the local value.••HOOK should be a symbol, and FUNCTION may be any valid function.  If•HOOK is void, it is first set to nil.  If HOOK's value is a single•function, it is changed to a list of functions.",
"add-to-list":"add-to-list is a compiled Lisp function in `subr.el'.••(add-to-list LIST-VAR ELEMENT &amp;optional APPEND COMPARE-FN)••Add ELEMENT to the value of LIST-VAR if it isn't there yet.•The test for presence of ELEMENT is done with `equal',•or with COMPARE-FN if that's non-nil.•If ELEMENT is added, it is added at the beginning of the list,•unless the optional argument APPEND is non-nil, in which case•ELEMENT is added at the end.••The return value is the new value of LIST-VAR.••If you want to use `add-to-list' on a variable that is not defined•until a certain package is loaded, you should put the call to `add-to-list'•into a hook function that will be run only after loading the package.•`eval-after-load' provides one way to do this.  In some cases•other hooks, such as major mode hooks, can do the job.",
"align-regexp":"align-regexp is an interactive autoloaded Lisp function in `align.el'.••(align-regexp BEG END REGEXP &amp;optional GROUP SPACING REPEAT)••Align the current region using an ad-hoc rule read from the minibuffer.•BEG and END mark the limits of the region.  This function will prompt•for the REGEXP to align with.  If no prefix arg was specified, you•only need to supply the characters to be lined up and any preceding•whitespace is replaced.  If a prefix arg was specified, the full•regexp with parenthesized whitespace should be supplied; it will also•prompt for which parenthesis GROUP within REGEXP to modify, the amount•of SPACING to use, and whether or not to REPEAT the rule throughout•the line.  See `align-rules-list' for more information about these•options.••For example, let's say you had a list of phone numbers, and wanted to•align them so that the opening parentheses would line up:••    Fred (123) 456-7890•    Alice (123) 456-7890•    Mary-Anne (123) 456-7890•    Joe (123) 456-7890••There is no predefined rule to handle this, but you could easily do it•using a REGEXP like ⧷&quote(⧷&quote.  All you would have to do is to mark the•region, call `align-regexp' and type in that regular expression.",
"all-completions":"all-completions is a built-in function in `C source code'.••(all-completions STRING COLLECTION &amp;optional PREDICATE)••Search for partial matches to STRING in COLLECTION.•Test each of the possible completions specified by COLLECTION•to see if it begins with STRING.  The possible completions may be•strings or symbols.  Symbols are converted to strings before testing,•see `symbol-name'.•The value is a list of all the possible completions that match STRING.••If COLLECTION is an alist, the keys (cars of elements) are the•possible completions.  If an element is not a cons cell, then the•element itself is the possible completion.•If COLLECTION is a hash-table, all the keys that are strings or symbols•are the possible completions.•If COLLECTION is an obarray, the names of all symbols in the obarray•are the possible completions.••COLLECTION can also be a function to do the completion itself.•It receives three arguments: the values STRING, PREDICATE and t.•Whatever it returns becomes the value of `all-completions'.••If optional third argument PREDICATE is non-nil,•it is used to test each possible match.•The match is a candidate only if PREDICATE returns non-nil.•The argument given to PREDICATE is the alist element•or the symbol from the obarray.  If COLLECTION is a hash-table,•predicate is called with two arguments: the key and the value.•Additionally to this predicate, `completion-regexp-list'•is used to further constrain the set of candidates.••An obsolete optional fourth argument HIDE-SPACES is still accepted for•backward compatibility.  If non-nil, strings in COLLECTION that start•with a space are ignored unless STRING itself starts with a space.",
"and":"and is a special form in `C source code'.••(and CONDITIONS...)••Eval args until one of them yields nil, then return nil.•The remaining args are not evalled at all.•If no arg yields nil, return the last arg's value.",
"append":"append is a built-in function in `C source code'.••(append &amp;rest SEQUENCES)••Concatenate all the arguments and make the result a list.•The result is a list whose elements are the elements of all the arguments.•Each argument may be a list, vector or string.•The last argument is not copied, just used as the tail of the new list.",
"append-next-kill":"append-next-kill is an interactive compiled Lisp function in•`simple.el'.••(append-next-kill &amp;optional INTERACTIVE)••Cause following command, if it kills, to append to previous kill.•The argument is used for internal purposes; do not supply one.",
"append-to-file":"append-to-file is an interactive compiled Lisp function in `files.el'.••(append-to-file START END FILENAME)••Append the contents of the region to the end of file FILENAME.•When called from a function, expects three arguments,•START, END and FILENAME.  START and END are normally buffer positions•specifying the part of the buffer to write.•If START is nil, that means to use the entire buffer contents.•If START is a string, then output that string to the file•instead of any buffer contents; END is ignored.••This does character code conversion and applies annotations•like `write-region' does.",
"apply":"apply is a built-in function in `C source code'.••(apply FUNCTION &amp;rest ARGUMENTS)••Call FUNCTION with our remaining args, using our last arg as list of args.•Then return the value FUNCTION returns.•Thus, (apply '+ 1 2 '(3 4)) returns 10.",
"apply-macro-to-region-lines":"apply-macro-to-region-lines is an interactive autoloaded compiled Lisp•function in `macros.el'.••(apply-macro-to-region-lines TOP BOTTOM &amp;optional MACRO)••Apply last keyboard macro to all lines in the region.•For each line that begins in the region, move to the beginning of•the line, and run the last keyboard macro.••When called from lisp, this function takes two arguments TOP and•BOTTOM, describing the current region.  TOP must be before BOTTOM.•The optional third argument MACRO specifies a keyboard macro to•execute.••This is useful for quoting or unquoting included text, adding and•removing comments, or producing tables where the entries are regular.••For example, in Usenet articles, sections of text quoted from another•author are indented, or have each line start with `&gt;'.  To quote a•section of text, define a keyboard macro which inserts `&gt;', put point•and mark at opposite ends of the quoted section, and use•`C-x C-k C-r' to mark the entire section.••Suppose you wanted to build a keyword table in C where each entry•looked like this:••    { ⧷&quotefoo⧷&quote, foo_data, foo_function },•    { ⧷&quotebar⧷&quote, bar_data, bar_function },•    { ⧷&quotebaz⧷&quote, baz_data, baz_function },••You could enter the names in this format:••    foo•    bar•    baz••and write a macro to massage a word into a table entry:••    ⧷C-x (•       ⧷M-d { ⧷&quote⧷C-y⧷&quote, ⧷C-y_data, ⧷C-y_function },•    ⧷C-x )••and then select the region of un-tablified names and use•`C-x C-k C-r' to build the table from the names.",
"apropos":"apropos is an interactive autoloaded compiled Lisp function in•`apropos.el'.••(apropos PATTERN &amp;optional DO-ALL)••Show all meaningful Lisp symbols whose names match PATTERN.•Symbols are shown if they are defined as functions, variables, or•faces, or if they have nonempty property lists.••PATTERN can be a word, a list of words (separated by spaces),•or a regexp (using some regexp special characters).  If it is a word,•search for matches for that word as a substring.  If it is a list of words,•search for matches for any two (or more) of those words.••With C-u prefix, or if `apropos-do-all' is non-nil,•consider all symbols (if they match PATTERN).••Returns list of symbols and documentation found.",
"apropos-command":"apropos-command is an interactive autoloaded compiled Lisp function in•`apropos.el'.••(apropos-command PATTERN &amp;optional DO-ALL VAR-PREDICATE)••Show commands (interactively callable functions) that match PATTERN.•PATTERN can be a word, a list of words (separated by spaces),•or a regexp (using some regexp special characters).  If it is a word,•search for matches for that word as a substring.  If it is a list of words,•search for matches for any two (or more) of those words.••With C-u prefix, or if `apropos-do-all' is non-nil, also show•noninteractive functions.••If VAR-PREDICATE is non-nil, show only variables, and only those that•satisfy the predicate VAR-PREDICATE.••When called from a Lisp program, a string PATTERN is used as a regexp,•while a list of strings is used as a word list.",
"apropos-value":"apropos-value is an interactive autoloaded compiled Lisp function in•`apropos.el'.••(apropos-value PATTERN &amp;optional DO-ALL)••Show all symbols whose value's printed representation matches PATTERN.•PATTERN can be a word, a list of words (separated by spaces),•or a regexp (using some regexp special characters).  If it is a word,•search for matches for that word as a substring.  If it is a list of words,•search for matches for any two (or more) of those words.••With C-u prefix, or if `apropos-do-all' is non-nil, also looks•at function definitions (arguments, documentation and body) and at the•names and values of properties.••Returns list of symbols and values found.",
"aref":"aref is a built-in function in `C source code'.••(aref ARRAY IDX)••Return the element of ARRAY at index IDX.•ARRAY may be a vector, a string, a char-table, a bool-vector,•or a byte-code object.  IDX starts at 0.",
"artist-mode":"artist-mode is an interactive autoloaded compiled Lisp function in•`artist.el'.••(artist-mode &amp;optional ARG)••Toggle Artist mode.•With argument ARG, turn Artist mode on if ARG is positive.•Artist lets you draw lines, squares, rectangles and poly-lines,•ellipses and circles with your mouse and/or keyboard.••How to quit Artist mode•• Type M-x artist-mode-off to quit artist-mode.•••How to submit a bug report•• Type M-x artist-submit-bug-report to submit a bug report.•••Drawing with the mouse:•• mouse-2• shift mouse-2	Pops up a menu where you can select what to draw with•		mouse-1, and where you can do some settings (described•		below).•• mouse-1• shift mouse-1	Draws lines, rectangles or poly-lines, erases, cuts, copies•		or pastes:••		Operation	Not shifted		  Shifted•		--------------------------------------------------------------•                Pen             fill-char at point        line from last point•                                                          to new point•		--------------------------------------------------------------•		Line		Line in any direction	  Straight line•		--------------------------------------------------------------•		Rectangle	Rectangle		  Square•		--------------------------------------------------------------•		Poly-line	Poly-line in any dir	  Straight poly-lines•		--------------------------------------------------------------•		Ellipses	Ellipses		  Circles•		--------------------------------------------------------------•		Text		Text (see thru)		  Text (overwrite)•		--------------------------------------------------------------•		Spray-can	Spray-can		  Set size for spray•		--------------------------------------------------------------•		Erase		Erase character		  Erase rectangle•		--------------------------------------------------------------•		Vaporize	Erase single line	  Erase connected•							  lines•		--------------------------------------------------------------•		Cut		Cut rectangle		  Cut square•		--------------------------------------------------------------•		Copy		Copy rectangle		  Copy square•		--------------------------------------------------------------•		Paste		Paste			  Paste•		--------------------------------------------------------------•		Flood-fill	Flood-fill		  Flood-fill•		--------------------------------------------------------------••		* Straight lines can only go horizontally, vertically•		  or diagonally.••		* Poly-lines are drawn while holding mouse-1 down.  When you•		  release the button, the point is set.  If you want a segment•		  to be straight, hold down shift before pressing the•		  mouse-1 button.  Click mouse-2 or mouse-3 to stop drawing•		  poly-lines.••		* See thru for text means that text already in the buffer•		  will be visible through blanks in the text rendered, while•		  overwrite means the opposite.••		* Vaporizing connected lines only vaporizes lines whose•		  _endpoints_ are connected.  See also the variable•		  `artist-vaporize-fuzziness'.••		* Cut copies, then clears the rectangle/square.••		* When drawing lines or poly-lines, you can set arrows.•		  See below under ``Arrows'' for more info.••		* The mode line shows the currently selected drawing operation.•		  In addition, if it has an asterisk (*) at the end, you•		  are currently drawing something.••		* Be patient when flood-filling -- large areas take quite•		  some time to fill.••• mouse-3	Erases character under pointer• shift mouse-3	Erases rectangle•••Settings•• Set fill	Sets the character used when filling rectangles/squares•• Set line	Sets the character used when drawing lines•• Erase char	Sets the character used when erasing•• Rubber-banding	Toggles rubber-banding•• Trimming	Toggles trimming of line-endings (that is: when the shape•		is drawn, extraneous white-space at end of lines is removed)•• Borders        Toggles the drawing of line borders around filled shapes•••Drawing with keys•• M-x artist-key-set-point		Does one of the following:•		For lines/rectangles/squares: sets the first/second endpoint•		For poly-lines: sets a point (use C-u M-x artist-key-set-point to set last point)•		When erase characters: toggles erasing•		When cutting/copying: Sets first/last endpoint of rect/square•		When pasting: Pastes•• M-x artist-select-operation	Selects what to draw•• Move around with M-x artist-next-line, M-x artist-previous-line, M-x artist-forward-char and M-x artist-backward-char.•• M-x artist-select-fill-char	Sets the character to use when filling• M-x artist-select-line-char	Sets the character to use when drawing• M-x artist-select-erase-char	Sets the character to use when erasing• M-x artist-toggle-rubber-banding	Toggles rubber-banding• M-x artist-toggle-trim-line-endings	Toggles trimming of line-endings• M-x artist-toggle-borderless-shapes	Toggles borders on drawn shapes•••Arrows•• M-x artist-toggle-first-arrow		Sets/unsets an arrow at the beginning•		of the line/poly-line•• M-x artist-toggle-second-arrow		Sets/unsets an arrow at the end•		of the line/poly-line•••Selecting operation•• There are some keys for quickly selecting drawing operations:•• M-x artist-select-op-line	Selects drawing lines• M-x artist-select-op-straight-line	Selects drawing straight lines• M-x artist-select-op-rectangle	Selects drawing rectangles• M-x artist-select-op-square	Selects drawing squares• M-x artist-select-op-poly-line	Selects drawing poly-lines• M-x artist-select-op-straight-poly-line	Selects drawing straight poly-lines• M-x artist-select-op-ellipse	Selects drawing ellipses• M-x artist-select-op-circle	Selects drawing circles• M-x artist-select-op-text-see-thru	Selects rendering text (see thru)• M-x artist-select-op-text-overwrite	Selects rendering text (overwrite)• M-x artist-select-op-spray-can	Spray with spray-can• M-x artist-select-op-spray-set-size	Set size for the spray-can• M-x artist-select-op-erase-char	Selects erasing characters• M-x artist-select-op-erase-rectangle	Selects erasing rectangles• M-x artist-select-op-vaporize-line	Selects vaporizing single lines• M-x artist-select-op-vaporize-lines	Selects vaporizing connected lines• M-x artist-select-op-cut-rectangle	Selects cutting rectangles• M-x artist-select-op-copy-rectangle	Selects copying rectangles• M-x artist-select-op-paste	Selects pasting• M-x artist-select-op-flood-fill	Selects flood-filling•••Variables•• This is a brief overview of the different variables.  For more info,• see the documentation for the variables (type C-h 2 &lt;variable&gt; RET).•• artist-rubber-banding		Interactively do rubber-banding or not• artist-first-char		What to set at first/second point...• artist-second-char		...when not rubber-banding• artist-interface-with-rect	If cut/copy/paste should interface with rect• artist-arrows			The arrows to use when drawing arrows• artist-aspect-ratio		Character height-to-width for squares• artist-trim-line-endings	Trimming of line endings• artist-flood-fill-right-border	Right border when flood-filling• artist-flood-fill-show-incrementally	Update display while filling• artist-pointer-shape		Pointer shape to use while drawing• artist-ellipse-left-char	Character to use for narrow ellipses• artist-ellipse-right-char	Character to use for narrow ellipses• artist-borderless-shapes       If shapes should have borders• artist-picture-compatibility   Whether or not to be picture mode compatible• artist-vaporize-fuzziness      Tolerance when recognizing lines• artist-spray-interval          Seconds between repeated sprayings• artist-spray-radius            Size of the spray-area• artist-spray-chars             The spray-``color''• artist-spray-new-chars         Initial spray-``color''••Hooks•• Turning the mode on or off runs `artist-mode-hook'.•••Keymap summary••key             binding•---             -------••C-b             artist-backward-char•C-c             Prefix Command•C-f             artist-forward-char•RET             artist-key-set-point•C-n             artist-next-line•C-p             artist-previous-line•&lt;               artist-toggle-first-arrow•&gt;               artist-toggle-second-arrow•&lt;C-mouse-4&gt;     artist-select-prev-op-in-list•&lt;C-mouse-5&gt;     artist-select-next-op-in-list•&lt;S-down-mouse-1&gt;                artist-down-mouse-1•&lt;S-down-mouse-2&gt;                artist-mouse-choose-operation•&lt;S-down-mouse-3&gt;                artist-down-mouse-3•&lt;down&gt;          artist-next-line•&lt;down-mouse-1&gt;  artist-down-mouse-1•&lt;down-mouse-2&gt;  artist-mouse-choose-operation•&lt;down-mouse-3&gt;  artist-down-mouse-3•&lt;left&gt;          artist-backward-char•&lt;right&gt;         artist-forward-char•&lt;up&gt;            artist-previous-line••C-c C-a         Prefix Command•C-c C-c         artist-mode-off••C-c C-a C-b     artist-submit-bug-report•C-c C-a C-d     artist-select-op-erase-char•C-c C-a C-e     artist-select-erase-char•C-c C-a C-f     artist-select-fill-char•C-c C-a C-k     artist-select-op-cut-rectangle•C-c C-a C-l     artist-select-line-char•C-c C-a C-o     artist-select-operation•C-c C-a C-r     artist-toggle-rubber-banding•C-c C-a C-s     artist-toggle-borderless-shapes•C-c C-a C-t     artist-toggle-trim-line-endings•C-c C-a C-y     artist-select-op-paste•C-c C-a ESC     Prefix Command•C-c C-a E       artist-select-op-erase-rectangle•C-c C-a L       artist-select-op-straight-line•C-c C-a P       artist-select-op-straight-poly-line•C-c C-a R       artist-select-op-square•C-c C-a S       artist-select-op-spray-can•C-c C-a T       artist-select-op-text-overwrite•C-c C-a V       artist-select-op-vaporize-lines•C-c C-a c       artist-select-op-circle•C-c C-a e       artist-select-op-ellipse•C-c C-a f       artist-select-op-flood-fill•C-c C-a l       artist-select-op-line•C-c C-a p       artist-select-op-poly-line•C-c C-a r       artist-select-op-rectangle•C-c C-a s       artist-select-op-square•C-c C-a t       artist-select-op-text-see-thru•C-c C-a v       artist-select-op-vaporize-line•C-c C-a z       artist-select-op-spray-set-size••C-c C-a M-w     artist-select-op-copy-rectangle••",
"aset":"aset is a built-in function in `C source code'.••(aset ARRAY IDX NEWELT)••Store into the element of ARRAY at index IDX the value NEWELT.•Return NEWELT.  ARRAY may be a vector, a string, a char-table or a•bool-vector.  IDX starts at 0.",
"assoc":"assoc is a built-in function in `C source code'.••(assoc KEY LIST)••Return non-nil if KEY is `equal' to the car of an element of LIST.•The value is actually the first element of LIST whose car equals KEY.",
"async-shell-command":"async-shell-command is an interactive compiled Lisp function in•`simple.el'.••(async-shell-command COMMAND &amp;optional OUTPUT-BUFFER ERROR-BUFFER)••Execute string COMMAND asynchronously in background.••Like `shell-command', but adds `&amp;' at the end of COMMAND•to execute it asynchronously.••The output appears in the buffer `*Async Shell Command*'.•That buffer is in shell mode.••In Elisp, you will often be better served by calling `start-process'•directly, since it offers more control and does not impose the use of a•shell (with its need to quote arguments).",
"auto-complete":"auto-complete is an interactive compiled Lisp function in•`auto-complete.el'.••(auto-complete &amp;optional SOURCES)••Start auto-completion at current point.",
"auto-fill-mode":"auto-fill-mode is an interactive compiled Lisp function in•`simple.el'.••(auto-fill-mode &amp;optional ARG)••Toggle automatic line breaking (Auto Fill mode).•With a prefix argument ARG, enable Auto Fill mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••When Auto Fill mode is enabled, inserting a space at a column•beyond `current-fill-column' automatically breaks the line at a•previous space.••When `auto-fill-mode' is on, the `auto-fill-function' variable is•non-`nil'.••The value of `normal-auto-fill-function' specifies the function to use•for `auto-fill-function' when turning Auto Fill mode on.",
"autoload":"autoload is a built-in function in `C source code'.••(autoload FUNCTION FILE &amp;optional DOCSTRING INTERACTIVE TYPE)••Define FUNCTION to autoload from FILE.•FUNCTION is a symbol; FILE is a file name string to pass to `load'.•Third arg DOCSTRING is documentation for the function.•Fourth arg INTERACTIVE if non-nil says function can be called interactively.•Fifth arg TYPE indicates the type of the object:•   nil or omitted says FUNCTION is a function,•   `keymap' says FUNCTION is really a keymap, and•   `macro' or t says FUNCTION is really a macro.•Third through fifth args give info about the real definition.•They default to nil.•If FUNCTION is already defined other than as an autoload,•this does nothing and returns nil.",
"back-to-indentation":"back-to-indentation is an interactive compiled Lisp function in•`simple.el'.••(back-to-indentation)••Move point to the first non-whitespace character on this line.",
"backward-char":"backward-char is an interactive built-in function in `C source code'.••(backward-char &amp;optional N)••Move point N characters backward (forward if N is negative).•On attempt to pass beginning or end of buffer, stop and signal error.•Interactively, N is the numeric prefix argument.••Depending on the bidirectional context, the movement may be to the•right or to the left on the screen.  This is in contrast with•&lt;left&gt;, which see.••This subr is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `backward-char'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-backward-char-keymap'.",
"backward-delete-char-untabify":"backward-delete-char-untabify is an interactive compiled Lisp function•in `simple.el'.••(backward-delete-char-untabify ARG &amp;optional KILLP)••Delete characters backward, changing tabs into spaces.•The exact behavior depends on `backward-delete-char-untabify-method'.•Delete ARG chars, and kill (save in kill ring) if KILLP is non-nil.•Interactively, ARG is the prefix arg (default 1)•and KILLP is t if a prefix arg was specified.",
"backward-kill-word":"backward-kill-word is an interactive compiled Lisp function in•`simple.el'.••(backward-kill-word ARG)••Kill characters backward until encountering the beginning of a word.•With argument ARG, do this that many times.",
"backward-list":"backward-list is an interactive compiled Lisp function in `lisp.el'.••(backward-list &amp;optional ARG)••Move backward across one balanced group of parentheses.•With ARG, do it that many times.•Negative arg -N means move forward across N groups of parentheses.•This command assumes point is not in a string or comment.",
"backward-page":"backward-page is an interactive compiled Lisp function in `page.el'.••(backward-page &amp;optional COUNT)••Move backward to page boundary.  With arg, repeat, or go fwd if negative.•A page boundary is any line whose beginning matches the regexp•`page-delimiter'.",
"backward-paragraph":"backward-paragraph is an interactive compiled Lisp function in•`paragraphs.el'.••(backward-paragraph &amp;optional ARG)••Move backward to start of paragraph.•With argument ARG, do it ARG times;•a negative argument ARG = -N means move forward N paragraphs.••A paragraph start is the beginning of a line which is a•`paragraph-start' or which is ordinary text and follows a•`paragraph-separate'ing line; except: if the first real line of a•paragraph is preceded by a blank line, the paragraph starts at that•blank line.••See `forward-paragraph' for more information.",
"backward-sentence":"backward-sentence is an interactive compiled Lisp function in•`paragraphs.el'.••(backward-sentence &amp;optional ARG)••Move backward to start of sentence.  With arg, do it arg times.•See `forward-sentence' for more information.",
"backward-sexp":"backward-sexp is an interactive compiled Lisp function in `lisp.el'.••(backward-sexp &amp;optional ARG)••Move backward across one balanced expression (sexp).•With ARG, do it that many times.  Negative arg -N means•move forward across N balanced expressions.•This command assumes point is not in a string or comment.",
"backward-up-list":"backward-up-list is an interactive compiled Lisp function in•`lisp.el'.••(backward-up-list &amp;optional ARG)••Move backward out of one level of parentheses.•With ARG, do this that many times.•A negative argument means move forward but still to a less deep spot.•This command assumes point is not in a string or comment.",
"backward-word":"backward-word is an interactive compiled Lisp function in `simple.el'.••(backward-word &amp;optional ARG)••Move backward until encountering the beginning of a word.•With argument ARG, do this that many times.••This function is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `backward-word'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-backward-word-keymap'.•",
"balance-windows":"balance-windows is an interactive compiled Lisp function in•`window.el'.••(balance-windows &amp;optional WINDOW-OR-FRAME)••Balance the sizes of windows of WINDOW-OR-FRAME.•WINDOW-OR-FRAME is optional and defaults to the selected frame.•If WINDOW-OR-FRAME denotes a frame, balance the sizes of all•windows of that frame.  If WINDOW-OR-FRAME denotes a window,•recursively balance the sizes of all child windows of that•window.",
"beep":"beep is an alias for `ding' in `subr.el'.••(beep &amp;optional ARG)••Beep, or flash the screen.•Also, unless an argument is given,•terminate any keyboard macro currently executing.",
"beginning-of-buffer":"beginning-of-buffer is an interactive compiled Lisp function in•`simple.el'.••(beginning-of-buffer &amp;optional ARG)••Move point to the beginning of the buffer.•With numeric arg N, put point N/10 of the way from the beginning.•If the buffer is narrowed, this command uses the beginning of the•accessible part of the buffer.••If Transient Mark mode is disabled, leave mark at previous•position, unless a C-u prefix is supplied.••Don't use this command in Lisp programs!•(goto-char (point-min)) is faster.••This function is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `beginning-of-buffer'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-beginning-of-buffer-keymap'.•",
"beginning-of-defun":"beginning-of-defun is an interactive compiled Lisp function in•`lisp.el'.••(beginning-of-defun &amp;optional ARG)••Move backward to the beginning of a defun.•With ARG, do it that many times.  Negative ARG means move forward•to the ARGth following beginning of defun.••If search is successful, return t; point ends up at the beginning•of the line where the search succeeded.  Otherwise, return nil.••When `open-paren-in-column-0-is-defun-start' is non-nil, a defun•is assumed to start where there is a char with open-parenthesis•syntax at the beginning of a line.  If `defun-prompt-regexp' is•non-nil, then a string which matches that regexp may also precede•the open-parenthesis.  If `defun-prompt-regexp' and•`open-paren-in-column-0-is-defun-start' are both nil, this•function instead finds an open-paren at the outermost level.••If the variable `beginning-of-defun-function' is non-nil, its•value is called as a function, with argument ARG, to find the•defun's beginning.••Regardless of the values of `defun-prompt-regexp' and•`beginning-of-defun-function', point always moves to the•beginning of the line whenever the search is successful.",
"beginning-of-line":"beginning-of-line is an interactive built-in function in `C source•code'.••(beginning-of-line &amp;optional N)••Move point to beginning of current line (in the logical order).•With argument N not nil or 1, move forward N - 1 lines first.•If point reaches the beginning or end of buffer, it stops there.••This function constrains point to the current field unless this moves•point to a different line than the original, unconstrained result.•If N is nil or 1, and a front-sticky field starts at point, the point•does not move.  To ignore field boundaries bind•`inhibit-field-text-motion' to t, or use the `forward-line' function•instead.  For instance, `(forward-line 0)' does the same thing as•`(beginning-of-line)', except that it ignores field boundaries.",
"benchmark-run":"benchmark-run is an autoloaded Lisp macro in `benchmark.el'.••(benchmark-run &amp;optional REPETITIONS &amp;rest FORMS)••Time execution of FORMS.•If REPETITIONS is supplied as a number, run forms that many times,•accounting for the overhead of the resulting loop.  Otherwise run•FORMS once.•Return a list of the total elapsed time for execution, the number of•garbage collections that ran, and the time taken by garbage collection.•See also `benchmark-run-compiled'.",
"bookmark-bmenu-list":"bookmark-bmenu-list is an interactive autoloaded compiled Lisp•function in `bookmark.el'.••(bookmark-bmenu-list)••Display a list of existing bookmarks.•The list is displayed in a buffer named `*Bookmark List*'.•The leftmost column displays a D if the bookmark is flagged for•deletion, or &gt; if it is flagged for displaying.",
"bookmark-save":"bookmark-save is an interactive autoloaded compiled Lisp function in•`bookmark.el'.••(bookmark-save &amp;optional PARG FILE)••Save currently defined bookmarks.•Saves by default in the file defined by the variable•`bookmark-default-file'.  With a prefix arg, save it in file FILE•(second argument).••If you are calling this from Lisp, the two arguments are PARG and•FILE, and if you just want it to write to the default file, then•pass no arguments.  Or pass in nil and FILE, and it will save in FILE•instead.  If you pass in one argument, and it is non-nil, then the•user will be interactively queried for a file to save in.••When you want to load in the bookmarks from a file, use•`bookmark-load', M-x bookmark-load.  That function will prompt you•for a file, defaulting to the file defined by variable•`bookmark-default-file'.",
"bookmark-set":"bookmark-set is an interactive autoloaded compiled Lisp function in•`bookmark.el'.••(bookmark-set &amp;optional NAME NO-OVERWRITE)••Set a bookmark named NAME at the current location.•If name is nil, then prompt the user.••With a prefix arg (non-nil NO-OVERWRITE), do not overwrite any•existing bookmark that has the same name as NAME, but instead push the•new bookmark onto the bookmark alist.  The most recently set bookmark•with name NAME is thus the one in effect at any given time, but the•others are still there, should the user decide to delete the most•recent one.••To yank words from the text of the buffer and use them as part of the•bookmark name, type C-w while setting a bookmark.  Successive C-w's•yank successive words.••Typing C-u inserts (at the bookmark name prompt) the name of the last•bookmark used in the document where the new bookmark is being set;•this helps you use a single bookmark name to track progress through a•large document.  If there is no prior bookmark for this document, then•C-u inserts an appropriate name based on the buffer or file.••Use M-x bookmark-delete to remove bookmarks (you give it a name and•it removes only the first instance of a bookmark with that name from•the list of bookmarks.)",
"boundp":"boundp is a built-in function in `C source code'.••(boundp SYMBOL)••Return t if SYMBOL's value is not void.•Note that if `lexical-binding' is in effect, this refers to the•global value outside of any lexical scope.",
"bounds-of-thing-at-point":"bounds-of-thing-at-point is an autoloaded compiled Lisp function in•`thingatpt.el'.••(bounds-of-thing-at-point THING)••Determine the start and end buffer locations for the THING at point.•THING should be a symbol specifying a type of syntactic entity.•Possibilities include `symbol', `list', `sexp', `defun',•`filename', `url', `email', `word', `sentence', `whitespace',•`line', and `page'.••See the file `thingatpt.el' for documentation on how to define a•valid THING.••Return a cons cell (START . END) giving the start and end•positions of the thing found.",
"browse-url":"browse-url is an interactive autoloaded compiled Lisp function in•`browse-url.el'.••(browse-url URL &amp;rest ARGS)••Ask a WWW browser to load URL.•Prompts for a URL, defaulting to the URL at or before point.  Variable•`browse-url-browser-function' says which browser to use.•If the URL is a mailto: URL, consult `browse-url-mailto-function'•first, if that exists.",
"browse-url-firefox":"browse-url-firefox is an interactive autoloaded compiled Lisp function•in `browse-url.el'.••(browse-url-firefox URL &amp;optional NEW-WINDOW)••Ask the Firefox WWW browser to load URL.•Default to the URL around or before point.  The strings in•variable `browse-url-firefox-arguments' are also passed to•Firefox.••When called interactively, if variable•`browse-url-new-window-flag' is non-nil, load the document in a•new Firefox window, otherwise use a random existing one.  A•non-nil interactive prefix argument reverses the effect of•`browse-url-new-window-flag'.••If `browse-url-firefox-new-window-is-tab' is non-nil, then•whenever a document would otherwise be loaded in a new window, it•is loaded in a new tab in an existing window instead.••When called non-interactively, optional second argument•NEW-WINDOW is used instead of `browse-url-new-window-flag'.••On MS-Windows systems the optional `new-window' parameter is•ignored.  Firefox for Windows does not support the ⧷&quote-remote⧷&quote•command line parameter.  Therefore, the•`browse-url-new-window-flag' and `browse-url-firefox-new-window-is-tab'•are ignored as well.  Firefox on Windows will always open the requested•URL in a new window.",
"browse-url-of-buffer":"browse-url-of-buffer is an interactive autoloaded compiled Lisp•function in `browse-url.el'.••(browse-url-of-buffer &amp;optional BUFFER)••Ask a WWW browser to display BUFFER.•Display the current buffer if BUFFER is nil.  Display only the•currently visible part of BUFFER (from a temporary file) if buffer is•narrowed.",
"buffer-file-name":"buffer-file-name is a built-in function in `C source code'.••(buffer-file-name &amp;optional BUFFER)••Return name of file BUFFER is visiting, or nil if none.•No argument or nil as argument means use the current buffer.",
"buffer-modified-p":"buffer-modified-p is a built-in function in `C source code'.••(buffer-modified-p &amp;optional BUFFER)••Return t if BUFFER was modified since its file was last read or saved.•No argument or nil as argument means use current buffer as BUFFER.",
"buffer-name":"buffer-name is a built-in function in `C source code'.••(buffer-name &amp;optional BUFFER)••Return the name of BUFFER, as a string.•BUFFER defaults to the current buffer.•Return nil if BUFFER has been killed.",
"buffer-string":"buffer-string is a built-in function in `C source code'.••(buffer-string)••Return the contents of the current buffer as a string.•If narrowing is in effect, this function returns only the visible part•of the buffer.",
"buffer-substring":"buffer-substring is a built-in function in `C source code'.••(buffer-substring START END)••Return the contents of part of the current buffer as a string.•The two arguments START and END are character positions;•they can be in either order.•The string returned is multibyte if the buffer is multibyte.••This function copies the text properties of that part of the buffer•into the result string; if you don't want the text properties,•use `buffer-substring-no-properties' instead.",
"buffer-substring-no-properties":"buffer-substring-no-properties is a built-in function in `C source•code'.••(buffer-substring-no-properties START END)••Return the characters of part of the buffer, without the text properties.•The two arguments START and END are character positions;•they can be in either order.",
"bury-buffer":"bury-buffer is an interactive compiled Lisp function in `window.el'.••(bury-buffer &amp;optional BUFFER-OR-NAME)••Put BUFFER-OR-NAME at the end of the list of all buffers.•There it is the least likely candidate for `other-buffer' to•return; thus, the least likely buffer for C-x b to•select by default.••You can specify a buffer name as BUFFER-OR-NAME, or an actual•buffer object.  If BUFFER-OR-NAME is nil or omitted, bury the•current buffer.  Also, if BUFFER-OR-NAME is nil or omitted,•remove the current buffer from the selected window if it is•displayed there.",
"byte-compile-file":"byte-compile-file is an interactive autoloaded compiled Lisp function•in `bytecomp.el'.••(byte-compile-file FILENAME &amp;optional LOAD)••Compile a file of Lisp code named FILENAME into a file of byte code.•The output file's name is generated by passing FILENAME to the•function `byte-compile-dest-file' (which see).•With prefix arg (noninteractively: 2nd arg), LOAD the file after compiling.•The value is non-nil if there were no errors, nil if errors.",
"calc":"calc is an interactive autoloaded compiled Lisp function in `calc.el'.••(calc &amp;optional ARG FULL-DISPLAY INTERACTIVE)••The Emacs Calculator.  Full documentation is listed under ⧷&quotecalc-mode⧷&quote.",
"calendar":"calendar is an interactive autoloaded compiled Lisp function in•`calendar.el'.••(calendar &amp;optional ARG)••Display a three-month Gregorian calendar.•The three months appear side by side, with the current month in•the middle surrounded by the previous and next months.  The•cursor is put on today's date.  If optional prefix argument ARG•is non-nil, prompts for the central month and year.••Once in the calendar window, future or past months can be moved•into view.  Arbitrary months can be displayed, or the calendar•can be scrolled forward or backward.  The cursor can be moved•forward or backward by one day, one week, one month, or one year.•All of these commands take prefix arguments which, when negative,•cause movement in the opposite direction.  For convenience, the•digit keys and the minus sign are automatically prefixes.  Use•M-x describe-mode for details of the key bindings in the calendar•window.••Displays the calendar in a separate window, or optionally in a•separate frame, depending on the value of `calendar-setup'.••If `calendar-view-diary-initially-flag' is non-nil, also displays the•diary entries for the current date (or however many days•`diary-number-of-entries' specifies).  This variable can be•overridden by `calendar-setup'.  As well as being displayed,•diary entries can also be marked on the calendar (see•`calendar-mark-diary-entries-flag').••Runs the following hooks:••`calendar-load-hook' - after loading calendar.el•`calendar-today-visible-hook', `calendar-today-invisible-hook' - after•   generating a calendar, if today's date is visible or not, respectively•`calendar-initial-window-hook' - after first creating a calendar••This function is suitable for execution in an init file.",
"called-interactively-p":"called-interactively-p is a built-in function in `C source code'.••(called-interactively-p KIND)••Return t if the containing function was called by `call-interactively'.•If KIND is `interactive', then only return t if the call was made•interactively by the user, i.e. not in `noninteractive' mode nor•when `executing-kbd-macro'.•If KIND is `any', on the other hand, it will return t for any kind of•interactive call, including being called as the binding of a key, or•from a keyboard macro, or in `noninteractive' mode.••The only known proper use of `interactive' for KIND is in deciding•whether to display a helpful message, or how to display it.  If you're•thinking of using it for any other purpose, it is quite likely that•you're making a mistake.  Think: what do you want to do when the•command is called from a keyboard macro?••Instead of using this function, it is sometimes cleaner to give your•function an extra optional argument whose `interactive' spec specifies•non-nil unconditionally (⧷&quotep⧷&quote is a good way to do this), or via•(not (or executing-kbd-macro noninteractive)).",
"call-last-kbd-macro":"call-last-kbd-macro is an interactive built-in function in `C source•code'.••(call-last-kbd-macro &amp;optional PREFIX LOOPFUNC)••Call the last keyboard macro that you defined with M-x start-kbd-macro.••A prefix argument serves as a repeat count.  Zero means repeat until error.••To make a macro permanent so you can call it even after•defining others, use M-x name-last-kbd-macro.••In Lisp, optional second arg LOOPFUNC may be a function that is called prior to•each iteration of the macro.  Iteration stops if LOOPFUNC returns nil.",
"call-process":"call-process is a built-in function in `C source code'.••(call-process PROGRAM &amp;optional INFILE BUFFER DISPLAY &amp;rest ARGS)••Call PROGRAM synchronously in separate process.•The remaining arguments are optional.•The program's input comes from file INFILE (nil means `/dev/null').•Insert output in BUFFER before point; t means current buffer; nil for BUFFER• means discard it; 0 means discard and don't wait; and `(:file FILE)', where• FILE is a file name string, means that it should be written to that file• (if the file already exists it is overwritten).•BUFFER can also have the form (REAL-BUFFER STDERR-FILE); in that case,•REAL-BUFFER says what to do with standard output, as above,•while STDERR-FILE says what to do with standard error in the child.•STDERR-FILE may be nil (discard standard error output),•t (mix it with ordinary output), or a file name string.••Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.•Remaining arguments are strings passed as command arguments to PROGRAM.••If executable PROGRAM can't be found as an executable, `call-process'•signals a Lisp error.  `call-process' reports errors in execution of•the program only through its return and output.••If BUFFER is 0, `call-process' returns immediately with value nil.•Otherwise it waits for PROGRAM to terminate•and returns a numeric exit status or a signal description string.•If you quit, the process is killed with SIGINT, or SIGKILL if you quit again.",
"capitalize":"capitalize is a built-in function in `C source code'.••(capitalize OBJ)••Convert argument to capitalized form and return that.•This means that each word's first character is upper case•and the rest is lower case.•The argument may be a character or string.  The result has the same type.•The argument object is not altered--the value is a copy.",
"capitalize-region":"capitalize-region is an interactive built-in function in `C source•code'.••(capitalize-region BEG END)••Convert the region to capitalized form.•Capitalized form means each word's first character is upper case•and the rest of it is lower case.•In programs, give two arguments, the starting and ending•character positions to operate on.",
"capitalize-word":"capitalize-word is an interactive built-in function in `C source•code'.••(capitalize-word ARG)••Capitalize the following word (or ARG words), moving over.•This gives the word(s) a first character in upper case•and the rest lower case.•With negative argument, capitalize previous words but do not move.",
"car":"car is a built-in function in `C source code'.••(car LIST)••Return the car of LIST.  If arg is nil, return nil.•Error if arg is not nil and not a cons cell.  See also `car-safe'.••See Info node `(elisp)Cons Cells' for a discussion of related basic•Lisp concepts such as car, cdr, cons cell and list.",
"catch":"catch is a special form in `C source code'.••(catch TAG BODY...)••Eval BODY allowing nonlocal exits using `throw'.•TAG is evalled to get the tag to use; it must not be nil.••Then the BODY is executed.•Within BODY, a call to `throw' with the same TAG exits BODY and this `catch'.•If no throw happens, `catch' returns the value of the last BODY form.•If a throw happens, it specifies the value to return from `catch'.",
"cdr":"cdr is a built-in function in `C source code'.••(cdr LIST)••Return the cdr of LIST.  If arg is nil, return nil.•Error if arg is not nil and not a cons cell.  See also `cdr-safe'.••See Info node `(elisp)Cons Cells' for a discussion of related basic•Lisp concepts such as cdr, car, cons cell and list.",
"center-line":"center-line is an interactive compiled Lisp function in•`text-mode.el'.••(center-line &amp;optional NLINES)••Center the line point is on, within the width specified by `fill-column'.•This means adjusting the indentation so that it equals•the distance between the end of the text and `fill-column'.•The argument NLINES says how many lines to center.",
"char-to-string":"char-to-string is a built-in function in `C source code'.••(char-to-string CHAR)••Convert arg CHAR to a string containing that character.",
"clean-buffer-list":"clean-buffer-list is an interactive autoloaded Lisp function in•`midnight.el'.••(clean-buffer-list)••Kill old buffers that have not been displayed recently.•The relevant variables are `clean-buffer-list-delay-general',•`clean-buffer-list-delay-special', `clean-buffer-list-kill-buffer-names',•`clean-buffer-list-kill-never-buffer-names',•`clean-buffer-list-kill-regexps' and•`clean-buffer-list-kill-never-regexps'.•While processing buffers, this procedure displays messages containing•the current date/time, buffer name, how many seconds ago it was•displayed (can be nil if the buffer was never displayed) and its•lifetime, i.e., its ⧷&quoteage⧷&quote when it will be purged.",
"clear-rectangle":"clear-rectangle is an interactive autoloaded compiled Lisp function in•`rect.el'.••(clear-rectangle START END &amp;optional FILL)••Blank out the region-rectangle.•The text previously in the region is overwritten with blanks.••When called from a program the rectangle's corners are START and END.•With a prefix (or a FILL) argument, also fill with blanks the parts of the•rectangle which were empty.",
"clojure-mode":"clojure-mode is an interactive autoloaded compiled Lisp function in•`clojure-mode.el'.••(clojure-mode)••Parent mode: `clojure-parent-mode'.••Major mode for editing Clojure code - similar to Lisp mode.•Commands:•Delete converts tabs to spaces as it moves back.•Blank lines separate paragraphs.  Semicolons start comments.•key             binding•---             -------••C-c             Prefix Command•C-x             Prefix Command•ESC             Prefix Command•DEL             backward-delete-char-untabify••C-c C-e         lisp-eval-last-sexp•C-c C-l         clojure-load-file•C-c C-r         lisp-eval-region•C-c C-t         clojure-jump-between-tests-and-code•C-c C-z         clojure-display-inferior-lisp-buffer•C-c ESC         Prefix Command••C-x C-e         lisp-eval-last-sexp••C-M-x           lisp-eval-defun••C-M-q           indent-sexp••C-c M-q         clojure-fill-docstring•••Note that `run-lisp' may be used either to start an inferior Lisp job•or to switch back to an existing one.••Entry to this mode calls the value of `clojure-mode-hook'•if that value is non-nil.",
"clone-buffer":"clone-buffer is an interactive compiled Lisp function in `simple.el'.••(clone-buffer &amp;optional NEWNAME DISPLAY-FLAG)••Create and return a twin copy of the current buffer.•Unlike an indirect buffer, the new buffer can be edited•independently of the old one (if it is not read-only).•NEWNAME is the name of the new buffer.  It may be modified by•adding or incrementing &lt;N&gt; at the end as necessary to create a•unique buffer name.  If nil, it defaults to the name of the•current buffer, with the proper suffix.  If DISPLAY-FLAG is•non-nil, the new buffer is shown with `pop-to-buffer'.  Trying to•clone a file-visiting buffer, or a buffer whose major mode symbol•has a non-nil `no-clone' property, results in an error.••Interactively, DISPLAY-FLAG is t and NEWNAME is the name of the•current buffer with appropriate suffix.  However, if a prefix•argument is given, then the command prompts for NEWNAME in the•minibuffer.••This runs the normal hook `clone-buffer-hook' in the new buffer•after it has been set up properly in other respects.",
"close-rectangle":"close-rectangle is an alias for `delete-whitespace-rectangle' in•`rect.el'.••(close-rectangle START END &amp;optional FILL)••Delete all whitespace following a specified column in each line.•The left edge of the rectangle specifies the position in each line•at which whitespace deletion should begin.  On each line in the•rectangle, all continuous whitespace starting at that column is deleted.••When called from a program the rectangle's corners are START and END.•With a prefix (or a FILL) argument, also fill too short lines.",
"cmd-shell":"cmd-shell is an interactive Lisp function in `init_functions.el'.••(cmd-shell &amp;optional ARG)••Run cmd.exe (WinNT) or command.com shell. A numeric prefix•arg switches to the specified session, creating it if necessary.",
"c-mode":"c-mode is an interactive autoloaded compiled Lisp function in•`cc-mode.el'.••(c-mode)••Parent mode: `prog-mode'.••Major mode for editing K&amp;R and ANSI C code.•To submit a problem report, enter `M-x c-submit-bug-report' from a•c-mode buffer.  This automatically sets up a mail buffer with version•information already added.  You just need to add a description of the•problem, including a reproducible test case, and send the message.••To see what version of CC Mode you are running, enter `M-x c-version'.••The hook `c-mode-common-hook' is run with no args at mode•initialization, then `c-mode-hook'.••Key bindings:•key             binding•---             -------••C-c             Prefix Command•C-d             c-electric-delete-forward•TAB             c-indent-line-or-region•ESC             Prefix Command•#               c-electric-pound•( .. )          c-electric-paren•*               c-electric-star•,               c-electric-semi&amp;comma•/               c-electric-slash•:               c-electric-colon•;               c-electric-semi&amp;comma•{               c-electric-brace•}               c-electric-brace•DEL             c-electric-backspace••C-c C-e         c-macro-expand••C-c C-a         c-toggle-auto-newline•C-c C-b         c-submit-bug-report•C-c C-c         comment-region•C-c C-d         c-hungry-delete-forward•C-c C-l         c-toggle-electric-state•C-c C-n         c-forward-conditional•C-c C-o         c-set-offset•C-c C-p         c-backward-conditional•C-c C-q         c-indent-defun•C-c C-s         c-show-syntactic-information•C-c C-u         c-up-conditional•C-c C-w         subword-mode•C-c C-⧷         c-backslash-region•C-c .           c-set-style•C-c DEL         c-hungry-delete-backwards•C-c C-DEL       c-hungry-delete-backwards•C-c &lt;C-backspace&gt;               c-hungry-delete-backwards•C-c &lt;C-delete&gt;                  c-hungry-delete-forward•C-c &lt;C-deletechar&gt;              c-hungry-delete-forward•C-c &lt;deletechar&gt;                c-hungry-delete-forward••C-M-a           c-beginning-of-defun•C-M-e           c-end-of-defun•C-M-h           c-mark-function•C-M-j           c-indent-new-comment-line•C-M-q           c-indent-exp••",
"column-number-mode":"column-number-mode is an interactive compiled Lisp function in•`simple.el'.••(column-number-mode &amp;optional ARG)••Toggle column number display in the mode line (Column Number mode).•With a prefix argument ARG, enable Column Number mode if ARG is•positive, and disable it otherwise.••If called from Lisp, enable the mode if ARG is omitted or nil.",
"command-execute":"command-execute is a built-in function in `C source code'.••(command-execute CMD &amp;optional RECORD-FLAG KEYS SPECIAL)••Execute CMD as an editor command.•CMD must be a symbol that satisfies the `commandp' predicate.•Optional second arg RECORD-FLAG non-nil•means unconditionally put this command in `command-history'.•Otherwise, that is done only if an arg is read using the minibuffer.•The argument KEYS specifies the value to use instead of (this-command-keys)•when reading the arguments; if it is nil, (this-command-keys) is used.•The argument SPECIAL, if non-nil, means that this command is executing•a special event, so ignore the prefix argument and don't clear it.",
"comment-dwim":"comment-dwim is an interactive compiled Lisp function in•`newcomment.el'.••(comment-dwim ARG)••Call the comment command you want (Do What I Mean).•If the region is active and `transient-mark-mode' is on, call•`comment-region' (unless it only consists of comments, in which•case it calls `uncomment-region').•Else, if the current line is empty, call `comment-insert-comment-function'•if it is defined, otherwise insert a comment and indent it.•Else if a prefix ARG is specified, call `comment-kill'.•Else, call `comment-indent'.•You can configure `comment-style' to change the way regions are commented.",
"comment-region":"comment-region is an interactive compiled Lisp function in•`newcomment.el'.••(comment-region BEG END &amp;optional ARG)••Comment or uncomment each line in the region.•With just C-u prefix arg, uncomment each line in region BEG .. END.•Numeric prefix ARG means use ARG comment characters.•If ARG is negative, delete that many comment characters instead.••The strings used as comment starts are built from `comment-start'•and `comment-padding'; the strings used as comment ends are built•from `comment-end' and `comment-padding'.••By default, the `comment-start' markers are inserted at the•current indentation of the region, and comments are terminated on•each line (even for syntaxes in which newline does not end the•comment and blank lines do not get comments).  This can be•changed with `comment-style'.",
"concat":"concat is a built-in function in `C source code'.••(concat &amp;rest SEQUENCES)••Concatenate all the arguments and make the result a string.•The result is a string whose elements are the elements of all the arguments.•Each argument may be a string or a list or vector of characters (integers).",
"cond":"cond is a special form in `C source code'.••(cond CLAUSES...)••Try each clause until one succeeds.•Each clause looks like (CONDITION BODY...).  CONDITION is evaluated•and, if the value is non-nil, this clause succeeds:•then the expressions in BODY are evaluated and the last one's•value is the value of the cond-form.•If no clause succeeds, cond returns nil.•If a clause has one element, as in (CONDITION),•CONDITION's value if non-nil is returned from the cond-form.",
"condition-case":"condition-case is a special form in `C source code'.••(condition-case VAR BODYFORM &amp;rest HANDLERS)••Regain control when an error is signaled.•Executes BODYFORM and returns its value if no error happens.•Each element of HANDLERS looks like (CONDITION-NAME BODY...)•where the BODY is made of Lisp expressions.••A handler is applicable to an error•if CONDITION-NAME is one of the error's condition names.•If an error happens, the first applicable handler is run.••The car of a handler may be a list of condition names instead of a•single condition name; then it handles all of them.  If the special•condition name `debug' is present in this list, it allows another•condition in the list to run the debugger if `debug-on-error' and the•other usual mechanisms says it should (otherwise, `condition-case'•suppresses the debugger).••When a handler handles an error, control returns to the `condition-case'•and it executes the handler's BODY...•with VAR bound to (ERROR-SYMBOL . SIGNAL-DATA) from the error.•(If VAR is nil, the handler can't access that information.)•Then the value of the last BODY form is returned from the `condition-case'•expression.••See also the function `signal' for more info.",
"cons":"cons is a built-in function in `C source code'.••(cons CAR CDR)••Create a new cons, give it CAR and CDR as components, and return it.",
"copy-directory":"copy-directory is an interactive compiled Lisp function in `files.el'.••(copy-directory DIRECTORY NEWNAME &amp;optional KEEP-TIME PARENTS•COPY-CONTENTS)••Copy DIRECTORY to NEWNAME.  Both args must be strings.•This function always sets the file modes of the output files to match•the corresponding input file.••The third arg KEEP-TIME non-nil means give the output files the same•last-modified time as the old ones.  (This works on only some systems.)••A prefix arg makes KEEP-TIME non-nil.••Noninteractively, the last argument PARENTS says whether to•create parent directories if they don't exist.  Interactively,•this happens by default.••If NEWNAME names an existing directory, copy DIRECTORY as a•subdirectory there.  However, if called from Lisp with a non-nil•optional argument COPY-CONTENTS, copy the contents of DIRECTORY•directly into NEWNAME instead.",
"copy-file":"copy-file is an interactive built-in function in `C source code'.••(copy-file FILE NEWNAME &amp;optional OK-IF-ALREADY-EXISTS KEEP-TIME•PRESERVE-UID-GID PRESERVE-SELINUX-CONTEXT)••Copy FILE to NEWNAME.  Both args must be strings.•If NEWNAME names a directory, copy FILE there.••This function always sets the file modes of the output file to match•the input file.••The optional third argument OK-IF-ALREADY-EXISTS specifies what to do•if file NEWNAME already exists.  If OK-IF-ALREADY-EXISTS is nil, we•signal a `file-already-exists' error without overwriting.  If•OK-IF-ALREADY-EXISTS is a number, we request confirmation from the user•about overwriting; this is what happens in interactive use with M-x.•Any other value for OK-IF-ALREADY-EXISTS means to overwrite the•existing file.••Fourth arg KEEP-TIME non-nil means give the output file the same•last-modified time as the old one.  (This works on only some systems.)••A prefix arg makes KEEP-TIME non-nil.••If PRESERVE-UID-GID is non-nil, we try to transfer the•uid and gid of FILE to NEWNAME.••If PRESERVE-SELINUX-CONTEXT is non-nil and SELinux is enabled•on the system, we copy the SELinux context of FILE to NEWNAME.",
"copy-to-register":"copy-to-register is an interactive compiled Lisp function in•`register.el'.••(copy-to-register REGISTER START END &amp;optional DELETE-FLAG)••Copy region into register REGISTER.•With prefix arg, delete as well.•Called from program, takes four args: REGISTER, START, END and DELETE-FLAG.•START and END are buffer positions indicating what to copy.",
"count-lines":"count-lines is a compiled Lisp function in `simple.el'.••(count-lines START END)••Return number of lines between START and END.•This is usually the number of newlines between them,•but can be one more if START is not equal to END•and the greater of them is not at the start of a line.",
"count-words":"count-words is an interactive compiled Lisp function in `simple.el'.••(count-words START END)••Count words between START and END.•If called interactively, START and END are normally the start and•end of the buffer; but if the region is active, START and END are•the start and end of the region.  Print a message reporting the•number of lines, words, and chars.••If called from Lisp, return the number of words between START and•END, without printing any message.",
"cperl-electric-backspace":"cperl-electric-backspace is an interactive compiled Lisp function in•`cperl-mode.el'.••(cperl-electric-backspace ARG)••Backspace, or remove whitespace around the point inserted by an electric key.•Will untabify if `cperl-electric-backspace-untabify' is non-nil.",
"cperl-mode":"cperl-mode is an interactive autoloaded compiled Lisp function in•`cperl-mode.el'.••(cperl-mode)••Parent mode: `prog-mode'.••Major mode for editing Perl code.•Expression and list commands understand all C brackets.•Tab indents for Perl code.•Paragraphs are separated by blank lines only.•Delete converts tabs to spaces as it moves back.••Various characters in Perl almost always come in pairs: {}, (), [],•sometimes &lt;&gt;.  When the user types the first, she gets the second as•well, with optional special formatting done on {}.  (Disabled by•default.)  You can always quote (with C-q) the left•⧷&quoteparen⧷&quote to avoid the expansion.  The processing of &lt; is special,•since most the time you mean ⧷&quoteless⧷&quote.  CPerl mode tries to guess•whether you want to type pair &lt;&gt;, and inserts is if it•appropriate.  You can set `cperl-electric-parens-string' to the string that•contains the parens from the above list you want to be electrical.•Electricity of parens is controlled by `cperl-electric-parens'.•You may also set `cperl-electric-parens-mark' to have electric parens•look for active mark and ⧷&quoteembrace⧷&quote a region if possible.'••CPerl mode provides expansion of the Perl control constructs:••   if, else, elsif, unless, while, until, continue, do,•   for, foreach, formy and foreachmy.••and POD directives (Disabled by default, see `cperl-electric-keywords'.)••The user types the keyword immediately followed by a space, which•causes the construct to be expanded, and the point is positioned where•she is most likely to want to be.  E.g., when the user types a space•following ⧷&quoteif⧷&quote the following appears in the buffer: if () { or if ()•} { } and the cursor is between the parentheses.  The user can then•type some boolean expression within the parens.  Having done that,•typing M-x cperl-linefeed places you - appropriately indented - on a•new line between the braces (if you typed M-x cperl-linefeed in a POD•directive line, then appropriate number of new lines is inserted).••If CPerl decides that you want to insert ⧷&quoteEnglish⧷&quote style construct like••            bite if angry;••it will not do any expansion.  See also help on variable•`cperl-extra-newline-before-brace'.  (Note that one can switch the•help message on expansion by setting `cperl-message-electric-keyword'•to nil.)••M-x cperl-linefeed is a convenience replacement for typing carriage•return.  It places you in the next line with proper indentation, or if•you type it inside the inline block of control construct, like••            foreach (@lines) {print; print}••and you are on a boundary of a statement inside braces, it will•transform the construct into a multiline and will place you into an•appropriately indented blank line.  If you need a usual•`newline-and-indent' behavior, it is on M-x newline-and-indent,•see documentation on `cperl-electric-linefeed'.••Use M-x cperl-invert-if-unless to change a construction of the form••	    if (A) { B }••into••            B if A;••key             binding•---             -------••C-c             Prefix Command•TAB             cperl-indent-command•C-j             newline-and-indent•ESC             Prefix Command•(               cperl-electric-paren•)               cperl-electric-rparen•:               cperl-electric-terminator•;               cperl-electric-semi•&lt;               cperl-electric-paren•[               cperl-electric-paren•]               cperl-electric-rparen•{               cperl-electric-lbrace•}               cperl-electric-brace•DEL             cperl-electric-backspace•&lt;menu&gt;          Prefix Command••&lt;menu&gt; &lt;tab&gt;    cperl-indent-region••C-M-q           cperl-indent-exp•C-M-⧷           cperl-indent-region•C-M-|           cperl-lineup••C-c C-a         cperl-toggle-auto-newline•C-c C-b         cperl-find-bad-style•C-c C-d         cperl-here-doc-spell•C-c C-e         cperl-toggle-electric•C-c C-f         auto-fill-mode•C-c C-h         Prefix Command•C-c C-j         cperl-linefeed•C-c C-k         cperl-toggle-abbrev•C-c C-n         cperl-narrow-to-here-doc•C-c C-p         cperl-pod-spell•C-c C-t         cperl-invert-if-unless•C-c C-v         cperl-next-interpolated-REx•C-c C-w         cperl-toggle-construct-fix•C-c C-x         cperl-next-interpolated-REx-0•C-c C-y         cperl-next-interpolated-REx-1••C-c C-h F       cperl-info-on-command•C-c C-h P       cperl-perldoc-at-point•C-c C-h a       cperl-toggle-autohelp•C-c C-h f       cperl-info-on-current-command•C-c C-h p       cperl-perldoc•C-c C-h v       cperl-get-help••••Setting the variable `cperl-font-lock' to t switches on font-lock-mode•(even with older Emacsen), `cperl-electric-lbrace-space' to t switches•on electric space between $ and {, `cperl-electric-parens-string' is•the string that contains parentheses that should be electric in CPerl•(see also `cperl-electric-parens-mark' and `cperl-electric-parens'),•setting `cperl-electric-keywords' enables electric expansion of•control structures in CPerl.  `cperl-electric-linefeed' governs which•one of two linefeed behavior is preferable.  You can enable all these•options simultaneously (recommended mode of use) by setting•`cperl-hairy' to t.  In this case you can switch separate options off•by setting them to `null'.  Note that one may undo the extra•whitespace inserted by semis and braces in `auto-newline'-mode by•consequent M-x cperl-electric-backspace.••If your site has perl5 documentation in info format, you can use commands•M-x cperl-info-on-current-command and M-x cperl-info-on-command to access it.•These keys run commands `cperl-info-on-current-command' and•`cperl-info-on-command', which one is which is controlled by variable•`cperl-info-on-command-no-prompt' and `cperl-clobber-lisp-bindings'•(in turn affected by `cperl-hairy').••Even if you have no info-format documentation, short one-liner-style•help is available on M-x cperl-get-help, and one can run perldoc or•man via menu.••It is possible to show this help automatically after some idle time.•This is regulated by variable `cperl-lazy-help-time'.  Default with•`cperl-hairy' (if the value of `cperl-lazy-help-time' is nil) is 5•secs idle time .  It is also possible to switch this on/off from the•menu, or via M-x cperl-toggle-autohelp.  Requires `run-with-idle-timer'.••Use M-x cperl-lineup to vertically lineup some construction - put the•beginning of the region at the start of construction, and make region•span the needed amount of lines.••Variables `cperl-pod-here-scan', `cperl-pod-here-fontify',•`cperl-pod-face', `cperl-pod-head-face' control processing of POD and•here-docs sections.  With capable Emaxen results of scan are used•for indentation too, otherwise they are used for highlighting only.••Variables controlling indentation style:• `cperl-tab-always-indent'•    Non-nil means TAB in CPerl mode should always reindent the current line,•    regardless of where in the line point is when the TAB command is used.• `cperl-indent-left-aligned-comments'•    Non-nil means that the comment starting in leftmost column should indent.• `cperl-auto-newline'•    Non-nil means automatically newline before and after braces,•    and after colons and semicolons, inserted in Perl code.  The following•    M-x cperl-electric-backspace will remove the inserted whitespace.•    Insertion after colons requires both this variable and•    `cperl-auto-newline-after-colon' set.• `cperl-auto-newline-after-colon'•    Non-nil means automatically newline even after colons.•    Subject to `cperl-auto-newline' setting.• `cperl-indent-level'•    Indentation of Perl statements within surrounding block.•    The surrounding block's indentation is the indentation•    of the line on which the open-brace appears.• `cperl-continued-statement-offset'•    Extra indentation given to a substatement, such as the•    then-clause of an if, or body of a while, or just a statement continuation.• `cperl-continued-brace-offset'•    Extra indentation given to a brace that starts a substatement.•    This is in addition to `cperl-continued-statement-offset'.• `cperl-brace-offset'•    Extra indentation for line if it starts with an open brace.• `cperl-brace-imaginary-offset'•    An open brace following other text is treated as if it the line started•    this far to the right of the actual line indentation.• `cperl-label-offset'•    Extra indentation for line that is a label.• `cperl-min-label-indent'•    Minimal indentation for line that is a label.••Settings for classic indent-styles: K&amp;R BSD=C++ GNU PerlStyle=Whitesmith•  `cperl-indent-level'                5   4       2   4•  `cperl-brace-offset'                0   0       0   0•  `cperl-continued-brace-offset'     -5  -4       0   0•  `cperl-label-offset'               -5  -4      -2  -4•  `cperl-continued-statement-offset'  5   4       2   4••CPerl knows several indentation styles, and may bulk set the•corresponding variables.  Use M-x cperl-set-style to do this.  Use•M-x cperl-set-style-back to restore the memorized preexisting values•(both available from menu).  See examples in `cperl-style-examples'.••Part of the indentation style is how different parts of if/elsif/else•statements are broken into lines; in CPerl, this is reflected on how•templates for these constructs are created (controlled by•`cperl-extra-newline-before-brace'), and how reflow-logic should treat•⧷&quotecontinuation⧷&quote blocks of else/elsif/continue, controlled by the same•variable, and by `cperl-extra-newline-before-brace-multiline',•`cperl-merge-trailing-else', `cperl-indent-region-fix-constructs'.••If `cperl-indent-level' is 0, the statement after opening brace in•column 0 is indented on•`cperl-brace-offset'+`cperl-continued-statement-offset'.••Turning on CPerl mode calls the hooks in the variable `cperl-mode-hook'•with no args.••DO NOT FORGET to read micro-docs (available from `Perl' menu)•or as help on variables `cperl-tips', `cperl-problems',•`cperl-praise', `cperl-speed'.",
"cua-mode":"cua-mode is an interactive autoloaded compiled Lisp function in•`cua-base.el'.••(cua-mode &amp;optional ARG)••Toggle Common User Access style editing (CUA mode).•With a prefix argument ARG, enable CUA mode if ARG is positive,•and disable it otherwise.  If called from Lisp, enable the mode•if ARG is omitted or nil.••CUA mode is a global minor mode.  When enabled, typed text•replaces the active selection, and you can use C-z, C-x, C-c, and•C-v to undo, cut, copy, and paste in addition to the normal Emacs•bindings.  The C-x and C-c keys only do cut and copy when the•region is active, so in most cases, they do not conflict with the•normal function of these prefix keys.••If you really need to perform a command which starts with one of•the prefix keys even when the region is active, you have three•options:•- press the prefix key twice very quickly (within 0.2 seconds),•- press the prefix key and the following key within 0.2 seconds, or•- use the SHIFT key with the prefix key, i.e. C-S-x or C-S-c.••You can customize `cua-enable-cua-keys' to completely disable the•CUA bindings, or `cua-prefix-override-inhibit-delay' to change•the prefix fallback behavior.••CUA mode manages Transient Mark mode internally.  Trying to disable•Transient Mark mode while CUA mode is enabled does not work; if you•only want to highlight the region when it is selected using a•shifted movement key, set `cua-highlight-region-shift-only'.",
"current-buffer":"current-buffer is a built-in function in `C source code'.••(current-buffer)••Return the current buffer as a Lisp object.",
"customize-group":"customize-group is an interactive autoloaded compiled Lisp function in•`cus-edit.el'.••(customize-group &amp;optional GROUP OTHER-WINDOW)••Customize GROUP, which must be a customization group.•If OTHER-WINDOW is non-nil, display in another window.",
"customize-variable":"customize-variable is an alias for `customize-option' in•`cus-edit.el'.••(customize-variable SYMBOL)••Customize SYMBOL, which must be a user option.",
"custom-set-faces":"custom-set-faces is a compiled Lisp function in `cus-face.el'.••(custom-set-faces &amp;rest ARGS)••Initialize faces according to user preferences.•This associates the settings with the `user' theme.•The arguments should be a list where each entry has the form:••  (FACE SPEC [NOW [COMMENT]])••SPEC is stored as the saved value for FACE, as well as the value for the•`user' theme.  The `user' theme is one of the default themes known to Emacs.•See `custom-known-themes' for more information on the known themes.•See `custom-theme-set-faces' for more information on the interplay•between themes and faces.•See `defface' for the format of SPEC.••If NOW is present and non-nil, FACE is created now, according to SPEC.•COMMENT is a string comment about FACE.",
"custom-set-variables":"custom-set-variables is a compiled Lisp function in `custom.el'.••(custom-set-variables &amp;rest ARGS)••Install user customizations of variable values specified in ARGS.•These settings are registered as theme `user'.•The arguments should each be a list of the form:••  (SYMBOL EXP [NOW [REQUEST [COMMENT]]])••This stores EXP (without evaluating it) as the saved value for SYMBOL.•If NOW is present and non-nil, then also evaluate EXP and set•the default value for the SYMBOL to the value of EXP.••REQUEST is a list of features we must require in order to•handle SYMBOL properly.•COMMENT is a comment string about SYMBOL.",
"cycle-font":"cycle-font is an interactive compiled Lisp function in•`xah_emacs_font.el'.••(cycle-font Ξ-N)••Change font in current frame.•Each time this is called, font cycles thru a predefined list of fonts in the variable `ξ-font-list' .•If ξ-n is 1, cycle forward.•If ξ-n is -1, cycle backward.",
"cycle-hyphen-underscore-space":"cycle-hyphen-underscore-space is an interactive compiled Lisp function•in `xah_emacs_str_replacement.el'.••(cycle-hyphen-underscore-space)••Cyclically replace {underscore, space, hypen} chars on current word or text selection.•When called repeatedly, this command cycles the {“ ”, “_”, “-”} characters.",
"dabbrev-expand":"dabbrev-expand is an interactive autoloaded compiled Lisp function in•`dabbrev.el'.••(dabbrev-expand ARG)••Expand previous word ⧷&quotedynamically⧷&quote.••Expands to the most recent, preceding word for which this is a prefix.•If no suitable preceding word is found, words following point are•considered.  If still no suitable word is found, then look in the•buffers accepted by the function pointed out by variable•`dabbrev-friend-buffer-function'.••A positive prefix argument, N, says to take the Nth backward *distinct*•possibility.  A negative argument says search forward.••If the cursor has not moved from the end of the previous expansion and•no argument is given, replace the previously-made expansion•with the next possible expansion not yet tried.••The variable `dabbrev-backward-only' may be used to limit the•direction of search to backward if set non-nil.••See also `dabbrev-abbrev-char-regexp' and C-M-/.",
"deactivate-mark":"deactivate-mark is a compiled Lisp function in `simple.el'.••(deactivate-mark &amp;optional FORCE)••Deactivate the mark.•If Transient Mark mode is disabled, this function normally does•nothing; but if FORCE is non-nil, it deactivates the mark anyway.••Deactivating the mark sets `mark-active' to nil, updates the•primary selection according to `select-active-regions', and runs•`deactivate-mark-hook'.••If Transient Mark mode was temporarily enabled, reset the value•of the variable `transient-mark-mode'; if this causes Transient•Mark mode to be disabled, don't change `mark-active' to nil or•run `deactivate-mark-hook'.",
"defadvice":"defadvice is an autoloaded Lisp macro in `advice.el'.••(defadvice FUNCTION ARGS &amp;rest BODY)••Define a piece of advice for FUNCTION (a symbol).•The syntax of `defadvice' is as follows:••  (defadvice FUNCTION (CLASS NAME [POSITION] [ARGLIST] FLAG...)•    [DOCSTRING] [INTERACTIVE-FORM]•    BODY...)••FUNCTION ::= Name of the function to be advised.•CLASS ::= `before' | `around' | `after' | `activation' | `deactivation'.•NAME ::= Non-nil symbol that names this piece of advice.•POSITION ::= `first' | `last' | NUMBER. Optional, defaults to `first',•    see also `ad-add-advice'.•ARGLIST ::= An optional argument list to be used for the advised function•    instead of the argument list of the original.  The first one found in•    before/around/after-advices will be used.•FLAG ::= `protect'|`disable'|`activate'|`compile'|`preactivate'|`freeze'.•    All flags can be specified with unambiguous initial substrings.•DOCSTRING ::= Optional documentation for this piece of advice.•INTERACTIVE-FORM ::= Optional interactive form to be used for the advised•    function.  The first one found in before/around/after-advices will be used.•BODY ::= Any s-expression.••Semantics of the various flags:•`protect': The piece of advice will be protected against non-local exits in•any code that precedes it.  If any around-advice of a function is protected•then automatically all around-advices will be protected (the complete onion).••`activate': All advice of FUNCTION will be activated immediately if•FUNCTION has been properly defined prior to this application of `defadvice'.••`compile': In conjunction with `activate' specifies that the resulting•advised function should be compiled.••`disable': The defined advice will be disabled, hence, it will not be used•during activation until somebody enables it.••`preactivate': Preactivates the advised FUNCTION at macro-expansion/compile•time.  This generates a compiled advised definition according to the current•advice state that will be used during activation if appropriate.  Only use•this if the `defadvice' gets actually compiled.••`freeze': Expands the `defadvice' into a redefining `defun/defmacro' according•to this particular single advice.  No other advice information will be saved.•Frozen advices cannot be undone, they behave like a hard redefinition of•the advised function.  `freeze' implies `activate' and `preactivate'.  The•documentation of the advised function can be dumped onto the `DOC' file•during preloading.••See Info node `(elisp)Advising Functions' for comprehensive documentation.•usage: (defadvice FUNCTION (CLASS NAME [POSITION] [ARGLIST] FLAG...)•          [DOCSTRING] [INTERACTIVE-FORM]•          BODY...)",
"defalias":"defalias is a built-in function in `C source code'.••(defalias SYMBOL DEFINITION &amp;optional DOCSTRING)••Set SYMBOL's function definition to DEFINITION.•Associates the function with the current load file, if any.•The optional third argument DOCSTRING specifies the documentation string•for SYMBOL; if it is omitted or nil, SYMBOL uses the documentation string•determined by DEFINITION.•The return value is undefined.",
"defcustom":"defcustom is a Lisp macro in `custom.el'.••(defcustom SYMBOL STANDARD DOC &amp;rest ARGS)••Declare SYMBOL as a customizable variable.•SYMBOL is the variable name; it should not be quoted.•STANDARD is an expression specifying the variable's standard•value.  It should not be quoted.  It is evaluated once by•`defcustom', and the value is assigned to SYMBOL if the variable•is unbound.  The expression itself is also stored, so that•Customize can re-evaluate it later to get the standard value.•DOC is the variable documentation.••This macro uses `defvar' as a subroutine, which also marks the•variable as ⧷&quotespecial⧷&quote, so that it is always dynamically bound•even when `lexical-binding' is t.••The remaining arguments to `defcustom' should have the form••   [KEYWORD VALUE]...••The following keywords are meaningful:••:type	VALUE should be a widget type for editing the symbol's value.•:options VALUE should be a list of valid members of the widget type.•:initialize•	VALUE should be a function used to initialize the•	variable.  It takes two arguments, the symbol and value•	given in the `defcustom' call.  The default is•	`custom-initialize-reset'.•:set	VALUE should be a function to set the value of the symbol•        when using the Customize user interface.•	It takes two arguments, the symbol to set and the value to•	give it.  The default choice of function is `set-default'.•:get	VALUE should be a function to extract the value of symbol.•	The function takes one argument, a symbol, and should return•	the current value for that symbol.  The default choice of function•	is `default-value'.•:require•	VALUE should be a feature symbol.  If you save a value•	for this option, then when your init file loads the value,•	it does (require VALUE) first.•:set-after VARIABLES•	Specifies that SYMBOL should be set after the list of variables•        VARIABLES when both have been customized.•:risky	Set SYMBOL's `risky-local-variable' property to VALUE.•:safe	Set SYMBOL's `safe-local-variable' property to VALUE.•        See Info node `(elisp) File Local Variables'.••The following common keywords are also meaningful.••:group  VALUE should be a customization group.•        Add SYMBOL (or FACE with `defface') to that group.•:link LINK-DATA•        Include an external link after the documentation string for this•        item.  This is a sentence containing an active field which•        references some other documentation.••        There are several alternatives you can use for LINK-DATA:••        (custom-manual INFO-NODE)•             Link to an Info node; INFO-NODE is a string which specifies•             the node name, as in ⧷&quote(emacs)Top⧷&quote.••        (info-link INFO-NODE)•             Like `custom-manual' except that the link appears in the•             customization buffer with the Info node name.••        (url-link URL)•             Link to a web page; URL is a string which specifies the URL.••        (emacs-commentary-link LIBRARY)•             Link to the commentary section of LIBRARY.••        (emacs-library-link LIBRARY)•             Link to an Emacs Lisp LIBRARY file.••        (file-link FILE)•             Link to FILE.••        (function-link FUNCTION)•             Link to the documentation of FUNCTION.••        (variable-link VARIABLE)•             Link to the documentation of VARIABLE.••        (custom-group-link GROUP)•             Link to another customization GROUP.••        You can specify the text to use in the customization buffer by•        adding `:tag NAME' after the first element of the LINK-DATA; for•        example, (info-link :tag ⧷&quotefoo⧷&quote ⧷&quote(emacs)Top⧷&quote) makes a link to the•        Emacs manual which appears in the buffer as `foo'.••        An item can have more than one external link; however, most items•        have none at all.•:version•        VALUE should be a string specifying that the variable was•        first introduced, or its default value was changed, in Emacs•        version VERSION.•:package-version•        VALUE should be a list with the form (PACKAGE . VERSION)•        specifying that the variable was first introduced, or its•        default value was changed, in PACKAGE version VERSION.  This•        keyword takes priority over :version.  The PACKAGE and VERSION•        must appear in the alist `customize-package-emacs-version-alist'.•        Since PACKAGE must be unique and the user might see it in an•        error message, a good choice is the official name of the•        package, such as MH-E or Gnus.•:tag LABEL•        Use LABEL, a string, instead of the item's name, to label the item•        in customization menus and buffers.•:load FILE•        Load file FILE (a string) before displaying this customization•        item.  Loading is done with `load', and only if the file is•        not already loaded.••If SYMBOL has a local binding, then this form affects the local•binding.  This is normally not what you want.  Thus, if you need•to load a file defining variables with this form, or with•`defvar' or `defconst', you should always load that file•_outside_ any bindings for these variables.  (`defvar' and•`defconst' behave similarly in this respect.)••See Info node `(elisp) Customization' in the Emacs Lisp manual•for more information.",
"define-derived-mode":"define-derived-mode is an autoloaded Lisp macro in `derived.el'.••(define-derived-mode CHILD PARENT NAME &amp;optional DOCSTRING &amp;rest BODY)••Create a new mode as a variant of an existing mode.••The arguments to this command are as follow:••CHILD:     the name of the command for the derived mode.•PARENT:    the name of the command for the parent mode (e.g. `text-mode')•           or nil if there is no parent.•NAME:      a string which will appear in the status line (e.g. ⧷&quoteHypertext⧷&quote)•DOCSTRING: an optional documentation string--if you do not supply one,•           the function will attempt to invent something useful.•BODY:      forms to execute just before running the•           hooks for the new mode.  Do not use `interactive' here.••BODY can start with a bunch of keyword arguments.  The following keyword•  arguments are currently understood:•:group GROUP•	Declare the customization group that corresponds to this mode.•	The command `customize-mode' uses this.•:syntax-table TABLE•	Use TABLE instead of the default (CHILD-syntax-table).•	A nil value means to simply use the same syntax-table as the parent.•:abbrev-table TABLE•	Use TABLE instead of the default (CHILD-abbrev-table).•	A nil value means to simply use the same abbrev-table as the parent.••Here is how you could define LaTeX-Thesis mode as a variant of LaTeX mode:••  (define-derived-mode LaTeX-thesis-mode LaTeX-mode ⧷&quoteLaTeX-Thesis⧷&quote)••You could then make new key bindings for `LaTeX-thesis-mode-map'•without changing regular LaTeX mode.  In this example, BODY is empty,•and DOCSTRING is generated by default.••On a more complicated level, the following command uses `sgml-mode' as•the parent, and then sets the variable `case-fold-search' to nil:••  (define-derived-mode article-mode sgml-mode ⧷&quoteArticle⧷&quote•    ⧷&quoteMajor mode for editing technical articles.⧷&quote•    (setq case-fold-search nil))••Note that if the documentation string had been left out, it would have•been generated automatically, with a reference to the keymap.••The new mode runs the hook constructed by the function•`derived-mode-hook-name'.••See Info node `(elisp)Derived Modes' for more details.",
"define-key":"define-key is a built-in function in `C source code'.••(define-key KEYMAP KEY DEF)••In KEYMAP, define key sequence KEY as DEF.•KEYMAP is a keymap.••KEY is a string or a vector of symbols and characters, representing a•sequence of keystrokes and events.  Non-ASCII characters with codes•above 127 (such as ISO Latin-1) can be represented by vectors.•Two types of vector have special meanings:• [remap COMMAND] remaps any key binding for COMMAND.• [t] creates a default definition, which applies to any event with no•    other definition in KEYMAP.••DEF is anything that can be a key's definition:• nil (means key is undefined in this keymap),• a command (a Lisp function suitable for interactive calling),• a string (treated as a keyboard macro),• a keymap (to define a prefix key),• a symbol (when the key is looked up, the symbol will stand for its•    function definition, which should at that time be one of the above,•    or another symbol whose function definition is used, etc.),• a cons (STRING . DEFN), meaning that DEFN is the definition•    (DEFN should be a valid definition in its own right),• or a cons (MAP . CHAR), meaning use definition of CHAR in keymap MAP,• or an extended menu item definition.• (See info node `(elisp)Extended Menu Items'.)••If KEYMAP is a sparse keymap with a binding for KEY, the existing•binding is altered.  If there is no binding for KEY, the new pair•binding KEY to DEF is added at the front of KEYMAP.••This subr is advised.••Around-advice `ergoemacs-define-key-advice':•This does the right thing when modifying `ergoemacs-keymap'",
"defun":"defun is a Lisp macro in `byte-run.el'.••(defun NAME ARGLIST &amp;optional DOCSTRING DECL &amp;rest BODY)••Define NAME as a function.•The definition is (lambda ARGLIST [DOCSTRING] BODY...).•See also the function `interactive'.•DECL is a declaration, optional, of the form (declare DECLS...) where•DECLS is a list of elements of the form (PROP . VALUES).  These are•interpreted according to `defun-declarations-alist'.•The return value is undefined.",
"defvar":"defvar is a special form in `C source code'.••(defvar SYMBOL &amp;optional INITVALUE DOCSTRING)••Define SYMBOL as a variable, and return SYMBOL.•You are not required to define a variable in order to use it, but•defining it lets you supply an initial value and documentation, which•can be referred to by the Emacs help facilities and other programming•tools.  The `defvar' form also declares the variable as ⧷&quotespecial⧷&quote,•so that it is always dynamically bound even if `lexical-binding' is t.••The optional argument INITVALUE is evaluated, and used to set SYMBOL,•only if SYMBOL's value is void.  If SYMBOL is buffer-local, its•default value is what is set; buffer-local values are not affected.•If INITVALUE is missing, SYMBOL's value is not set.••If SYMBOL has a local binding, then this form affects the local•binding.  This is usually not what you want.  Thus, if you need to•load a file defining variables, with this form or with `defconst' or•`defcustom', you should always load that file _outside_ any bindings•for these variables.  (`defconst' and `defcustom' behave similarly in•this respect.)••The optional argument DOCSTRING is a documentation string for the•variable.••To define a user option, use `defcustom' instead of `defvar'.",
"delete-backward-char":"delete-backward-char is an interactive compiled Lisp function in•`simple.el'.••(delete-backward-char N &amp;optional KILLFLAG)••Delete the previous N characters (following if N is negative).•If Transient Mark mode is enabled, the mark is active, and N is 1,•delete the text in the region and deactivate the mark instead.•To disable this, set `delete-active-region' to nil.••Optional second arg KILLFLAG, if non-nil, means to kill (save in•kill ring) instead of delete.  Interactively, N is the prefix•arg, and KILLFLAG is set if N is explicitly specified.••In Overwrite mode, single character backward deletion may replace•tabs with spaces so as to back over columns, unless point is at•the end of the line.",
"delete-blank-lines":"delete-blank-lines is an interactive compiled Lisp function in•`simple.el'.••(delete-blank-lines)••On blank line, delete all surrounding blank lines, leaving just one.•On isolated blank line, delete that one.•On nonblank line, delete any immediately following blank lines.",
"delete-char":"delete-char is an interactive built-in function in `C source code'.••(delete-char N &amp;optional KILLFLAG)••Delete the following N characters (previous if N is negative).•Optional second arg KILLFLAG non-nil means kill instead (save in kill ring).•Interactively, N is the prefix arg, and KILLFLAG is set if•N was explicitly specified.••The command `delete-forward-char' is preferable for interactive use.",
"delete-directory":"delete-directory is an interactive compiled Lisp function in•`files.el'.••(delete-directory DIRECTORY &amp;optional RECURSIVE TRASH)••Delete the directory named DIRECTORY.  Does not follow symlinks.•If RECURSIVE is non-nil, all files in DIRECTORY are deleted as well.•TRASH non-nil means to trash the directory instead, provided•`delete-by-moving-to-trash' is non-nil.••When called interactively, TRASH is t if no prefix argument is•given.  With a prefix argument, TRASH is nil.",
"delete-file":"delete-file is an interactive built-in function in `C source code'.••(delete-file FILENAME &amp;optional TRASH)••Delete file named FILENAME.  If it is a symlink, remove the symlink.•If file has multiple names, it continues to exist with the other names.•TRASH non-nil means to trash the file instead of deleting, provided•`delete-by-moving-to-trash' is non-nil.••When called interactively, TRASH is t if no prefix argument is given.•With a prefix argument, TRASH is nil.",
"delete-horizontal-space":"delete-horizontal-space is an interactive compiled Lisp function in•`simple.el'.••(delete-horizontal-space &amp;optional BACKWARD-ONLY)••Delete all spaces and tabs around point.•If BACKWARD-ONLY is non-nil, only delete them before point.",
"delete-indentation":"delete-indentation is an interactive compiled Lisp function in•`simple.el'.••(delete-indentation &amp;optional ARG)••Join this line to previous and fix up whitespace at join.•If there is a fill prefix, delete it from the beginning of this line.•With argument, join this line to following line.",
"delete-matching-lines":"delete-matching-lines is an alias for `flush-lines' in `replace.el'.••(delete-matching-lines REGEXP &amp;optional RSTART REND INTERACTIVE)••Delete lines containing matches for REGEXP.•When called from Lisp (and usually when called interactively as•well, see below), applies to the part of the buffer after point.•The line point is in is deleted if and only if it contains a•match for regexp starting after point.••If REGEXP contains upper case characters (excluding those preceded by `⧷')•and `search-upper-case' is non-nil, the matching is case-sensitive.••Second and third arg RSTART and REND specify the region to operate on.•Lines partially contained in this region are deleted if and only if•they contain a match entirely contained in it.••Interactively, in Transient Mark mode when the mark is active, operate•on the contents of the region.  Otherwise, operate from point to the•end of (the accessible portion of) the buffer.  When calling this function•from Lisp, you can pretend that it was called interactively by passing•a non-nil INTERACTIVE argument.••If a match is split across lines, all the lines it lies in are deleted.•They are deleted _before_ looking for the next match.  Hence, a match•starting on the same line at which another match ended is ignored.",
"delete-non-matching-lines":"delete-non-matching-lines is an alias for `keep-lines' in•`replace.el'.••(delete-non-matching-lines REGEXP &amp;optional RSTART REND INTERACTIVE)••Delete all lines except those containing matches for REGEXP.•A match split across lines preserves all the lines it lies in.•When called from Lisp (and usually interactively as well, see below)•applies to all lines starting after point.••If REGEXP contains upper case characters (excluding those preceded by `⧷')•and `search-upper-case' is non-nil, the matching is case-sensitive.••Second and third arg RSTART and REND specify the region to operate on.•This command operates on (the accessible part of) all lines whose•accessible part is entirely contained in the region determined by RSTART•and REND.  (A newline ending a line counts as part of that line.)••Interactively, in Transient Mark mode when the mark is active, operate•on all lines whose accessible part is entirely contained in the region.•Otherwise, the command applies to all lines starting after point.•When calling this function from Lisp, you can pretend that it was•called interactively by passing a non-nil INTERACTIVE argument.••This function starts looking for the next match from the end of•the previous match.  Hence, it ignores matches that overlap•a previously found match.",
"delete-other-windows":"delete-other-windows is an interactive compiled Lisp function in•`window.el'.••(delete-other-windows &amp;optional WINDOW)••Make WINDOW fill its frame.•WINDOW must be a valid window and defaults to the selected one.•Return nil.••If the variable `ignore-window-parameters' is non-nil or the•`delete-other-windows' parameter of WINDOW equals t, do not•process any parameters of WINDOW.  Otherwise, if the•`delete-other-windows' parameter of WINDOW specifies a function,•call that function with WINDOW as its sole argument and return•the value returned by that function.••Otherwise, if WINDOW is part of an atomic window, call this•function with the root of the atomic window as its argument.  If•WINDOW is a non-side window, make WINDOW the only non-side window•on the frame.  Side windows are not deleted.  If WINDOW is a side•window signal an error.",
"delete-rectangle":"delete-rectangle is an interactive autoloaded compiled Lisp function•in `rect.el'.••(delete-rectangle START END &amp;optional FILL)••Delete (don't save) text in the region-rectangle.•The same range of columns is deleted in each line starting with the•line where the region begins and ending with the line where the region•ends.••When called from a program the rectangle's corners are START and END.•With a prefix (or a FILL) argument, also fill lines where nothing has•to be deleted.",
"delete-region":"delete-region is an interactive built-in function in `C source code'.••(delete-region START END)••Delete the text between START and END.•If called interactively, delete the region between point and mark.•This command deletes buffer text without modifying the kill ring.",
"delete-selection-mode":"delete-selection-mode is an interactive autoloaded compiled Lisp•function in `delsel.el'.••(delete-selection-mode &amp;optional ARG)••Toggle Delete Selection mode.•With a prefix argument ARG, enable Delete Selection mode if ARG•is positive, and disable it otherwise.  If called from Lisp,•enable the mode if ARG is omitted or nil.••When Delete Selection mode is enabled, Transient Mark mode is also•enabled and typed text replaces the selection if the selection is•active.  Otherwise, typed text is just inserted at point regardless of•any selection.",
"delete-trailing-whitespace":"delete-trailing-whitespace is an interactive compiled Lisp function in•`simple.el'.••(delete-trailing-whitespace &amp;optional START END)••Delete trailing whitespace between START and END.•If called interactively, START and END are the start/end of the•region if the mark is active, or of the buffer's accessible•portion if the mark is inactive.••This command deletes whitespace characters after the last•non-whitespace character in each line between START and END.  It•does not consider formfeed characters to be whitespace.••If this command acts on the entire buffer (i.e. if called•interactively with the mark inactive, or called from Lisp with•END nil), it also deletes all trailing lines at the end of the•buffer if the variable `delete-trailing-lines' is non-nil.",
"delete-whitespace-rectangle":"delete-whitespace-rectangle is an interactive autoloaded compiled Lisp•function in `rect.el'.••(delete-whitespace-rectangle START END &amp;optional FILL)••Delete all whitespace following a specified column in each line.•The left edge of the rectangle specifies the position in each line•at which whitespace deletion should begin.  On each line in the•rectangle, all continuous whitespace starting at that column is deleted.••When called from a program the rectangle's corners are START and END.•With a prefix (or a FILL) argument, also fill too short lines.",
"delete-window":"delete-window is an interactive compiled Lisp function in `window.el'.••(delete-window &amp;optional WINDOW)••Delete WINDOW.•WINDOW must be a valid window and defaults to the selected one.•Return nil.••If the variable `ignore-window-parameters' is non-nil or the•`delete-window' parameter of WINDOW equals t, do not process any•parameters of WINDOW.  Otherwise, if the `delete-window'•parameter of WINDOW specifies a function, call that function with•WINDOW as its sole argument and return the value returned by that•function.••Otherwise, if WINDOW is part of an atomic window, call•`delete-window' with the root of the atomic window as its•argument.  Signal an error if WINDOW is either the only window on•its frame, the last non-side window, or part of an atomic window•that is its frame's root window.",
"delimit-columns-rectangle":"delimit-columns-rectangle is an interactive autoloaded Lisp function•in `delim-col.el'.••(delimit-columns-rectangle START END)••Prettify all columns in a text rectangle.••START and END delimits the corners of text rectangle.",
"describe-bindings":"describe-bindings is an interactive compiled Lisp function in•`help.el'.••(describe-bindings &amp;optional PREFIX BUFFER)••Show a list of all defined keys, and their definitions.•We put that list in a buffer, and display the buffer.••The optional argument PREFIX, if non-nil, should be a key sequence;•then we display only bindings that start with that prefix.•The optional argument BUFFER specifies which buffer's bindings•to display (default, the current buffer).  BUFFER can be a buffer•or a buffer name.",
"describe-char":"describe-char is an interactive autoloaded compiled Lisp function in•`descr-text.el'.••(describe-char POS &amp;optional BUFFER)••Describe position POS (interactively, point) and the char after POS.•POS is taken to be in BUFFER, or the current buffer if BUFFER is nil.•The information is displayed in buffer `*Help*'.••The position information includes POS; the total size of BUFFER; the•region limits, if narrowed; the column number; and the horizontal•scroll amount, if the buffer is horizontally scrolled.••The character information includes the character code; charset and•code points in it; syntax; category; how the character is encoded in•BUFFER and in BUFFER's file; character composition information (if•relevant); the font and font glyphs used to display the character;•the character's canonical name and other properties defined by the•Unicode Data Base; and widgets, buttons, overlays, and text properties•relevant to POS.",
"describe-coding-system":"describe-coding-system is an interactive autoloaded Lisp function in•`mule-diag.el'.••(describe-coding-system CODING-SYSTEM)••Display information about CODING-SYSTEM.",
"describe-function":"describe-function is an interactive autoloaded compiled Lisp function•in `help-fns.el'.••(describe-function FUNCTION)••Display the full documentation of FUNCTION (a symbol).",
"describe-key":"describe-key is an interactive compiled Lisp function in `help.el'.••(describe-key &amp;optional KEY UNTRANSLATED UP-EVENT)••Display documentation of the function invoked by KEY.•KEY can be any kind of a key sequence; it can include keyboard events,•mouse events, and/or menu events.  When calling from a program,•pass KEY as a string or a vector.••If non-nil, UNTRANSLATED is a vector of the corresponding untranslated events.•It can also be a number, in which case the untranslated events from•the last key sequence entered are used.•UP-EVENT is the up-event that was discarded by reading KEY, or nil.••If KEY is a menu item or a tool-bar button that is disabled, this command•temporarily enables it to allow getting help on disabled items and buttons.",
"describe-mode":"describe-mode is an interactive compiled Lisp function in `help.el'.••(describe-mode &amp;optional BUFFER)••Display documentation of current major mode and minor modes.•A brief summary of the minor modes comes first, followed by the•major mode description.  This is followed by detailed•descriptions of the minor modes, each on a separate page.••For this to work correctly for a minor mode, the mode's indicator•variable (listed in `minor-mode-alist') must also be a function•whose documentation describes the minor mode.••If called from Lisp with a non-nil BUFFER argument, display•documentation for the major and minor modes of that buffer.",
"describe-package":"describe-package is an interactive autoloaded compiled Lisp function•in `package.el'.••(describe-package PACKAGE)••Display the full documentation of PACKAGE (a symbol).",
"describe-syntax":"describe-syntax is an interactive autoloaded compiled Lisp function in•`help-fns.el'.••(describe-syntax &amp;optional BUFFER)••Describe the syntax specifications in the syntax table of BUFFER.•The descriptions are inserted in a help buffer, which is then displayed.•BUFFER defaults to the current buffer.",
"describe-variable":"describe-variable is an interactive autoloaded compiled Lisp function•in `help-fns.el'.••(describe-variable VARIABLE &amp;optional BUFFER FRAME)••Display the full documentation of VARIABLE (a symbol).•Returns the documentation as a string, also.•If VARIABLE has a buffer-local value in BUFFER or FRAME•(default to the current buffer and current frame),•it is displayed along with the global value.",
"desktop-save-mode":"desktop-save-mode is an interactive autoloaded compiled Lisp function•in `desktop.el'.••(desktop-save-mode &amp;optional ARG)••Toggle desktop saving (Desktop Save mode).•With a prefix argument ARG, enable Desktop Save mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••If Desktop Save mode is enabled, the state of Emacs is saved from•one session to another.  See variable `desktop-save' and function•`desktop-read' for details.",
"diff":"diff is an interactive autoloaded compiled Lisp function in `diff.el'.••(diff OLD NEW &amp;optional SWITCHES NO-ASYNC)••Find and display the differences between OLD and NEW files.•When called interactively, read NEW, then OLD, using the•minibuffer.  The default for NEW is the current buffer's file•name, and the default for OLD is a backup file for NEW, if one•exists.  If NO-ASYNC is non-nil, call diff synchronously.••When called interactively with a prefix argument, prompt•interactively for diff switches.  Otherwise, the switches•specified in `diff-switches' are passed to the diff command.",
"diff-backup":"diff-backup is an interactive autoloaded compiled Lisp function in•`diff.el'.••(diff-backup FILE &amp;optional SWITCHES)••Diff this file with its backup file or vice versa.•Uses the latest backup, if there are several numerical backups.•If this file is a backup, diff it with its original.•The backup file is the first file given to `diff'.•With prefix arg, prompt for diff switches.",
"digit-argument":"digit-argument is an interactive compiled Lisp function in•`simple.el'.••(digit-argument ARG)••Part of the numeric argument for the next command.•C-u following digits or minus sign ends the argument.",
"directory-files":"directory-files is a built-in function in `C source code'.••(directory-files DIRECTORY &amp;optional FULL MATCH NOSORT)••Return a list of names of files in DIRECTORY.•There are three optional arguments:•If FULL is non-nil, return absolute file names.  Otherwise return names• that are relative to the specified directory.•If MATCH is non-nil, mention only file names that match the regexp MATCH.•If NOSORT is non-nil, the list is not sorted--its order is unpredictable.• Otherwise, the list returned is sorted with `string-lessp'.• NOSORT is useful if you plan to sort the result yourself.",
"dired":"dired is an interactive autoloaded compiled Lisp function in•`dired.el'.••(dired DIRNAME &amp;optional SWITCHES)••⧷&quoteEdit⧷&quote directory DIRNAME--delete, rename, print, etc. some files in it.•Optional second argument SWITCHES specifies the `ls' options used.•(Interactively, use a prefix argument to be able to specify SWITCHES.)•Dired displays a list of files in DIRNAME (which may also have•shell wildcards appended to select certain files).  If DIRNAME is a cons,•its first element is taken as the directory name and the rest as an explicit•list of files to make directory entries for.•You can flag files for deletion with d and then•delete them by typing x.•Type h after entering Dired for more info.••If DIRNAME is already in a dired buffer, that buffer is used without refresh.",
"dired-copy-filename-as-kill":"dired-copy-filename-as-kill is an interactive compiled Lisp function•in `dired.el'.••(dired-copy-filename-as-kill &amp;optional ARG)••Copy names of marked (or next ARG) files into the kill ring.•The names are separated by a space.•With a zero prefix arg, use the absolute file name of each marked file.•With C-u, use the file name relative to the dired buffer's•`default-directory'.  (This still may contain slashes if in a subdirectory.)••If on a subdir headerline, use absolute subdirname instead;•prefix arg and marked files are ignored in this case.••You can then feed the file name(s) to other commands with C-v.",
"dired-do-byte-compile":"dired-do-byte-compile is an interactive Lisp function in `dired+.el'.••(dired-do-byte-compile &amp;optional ARG)••Byte compile marked (or next prefix argument) Emacs Lisp files.•A prefix argument ARG specifies files to use instead of marked.• An integer means use the next ARG files (previous -ARG, if &lt; 0).• `C-u': Use the current file (whether or not any are marked).• `C-u C-u': Use all files in Dired, except directories.• `C-u C-u C-u': Use all files and directories, except `.' and `..'.• `C-u C-u C-u C-u': Use all files and all directories.",
"dired-do-kill-lines":"dired-do-kill-lines is an interactive autoloaded compiled Lisp•function in `dired-aux.el'.••(dired-do-kill-lines &amp;optional ARG FMT)••Kill all marked lines (not the files).•With a prefix argument, kill that many lines starting with the current line.•(A negative argument kills backward.)•If you use this command with a prefix argument to kill the line•for a file that is a directory, which you have inserted in the•Dired buffer as a subdirectory, then it deletes that subdirectory•from the buffer as well.•To kill an entire subdirectory (without killing its line in the•parent directory), go to its directory header line and use this•command with a prefix argument (the value does not matter).",
"dired-do-query-replace-regexp":"dired-do-query-replace-regexp is an interactive autoloaded compiled•Lisp function in `dired-aux.el'.••(dired-do-query-replace-regexp FROM TO &amp;optional DELIMITED)••Do `query-replace-regexp' of FROM with TO, on all marked files.•Third arg DELIMITED (prefix arg) means replace only word-delimited matches.•If you exit (C-g, RET or q), you can resume the query replace•with the command &lt;C-kp-0&gt;.",
"dired-do-rename-regexp":"dired-do-rename-regexp is an interactive autoloaded compiled Lisp•function in `dired-aux.el'.••(dired-do-rename-regexp REGEXP NEWNAME &amp;optional ARG WHOLE-NAME)••Rename selected files whose names match REGEXP to NEWNAME.••With non-zero prefix argument ARG, the command operates on the next ARG•files.  Otherwise, it operates on all the marked files, or the current•file if none are marked.••As each match is found, the user must type a character saying•  what to do with it.  For directions, type &lt;help&gt; at that time.•NEWNAME may contain ⧷&lt;n&gt; or ⧷&amp; as in `query-replace-regexp'.•REGEXP defaults to the last regexp used.••With a zero prefix arg, renaming by regexp affects the absolute file name.•Normally, only the non-directory part of the file name is used and changed.",
"dired-do-search":"dired-do-search is an interactive autoloaded compiled Lisp function in•`dired-aux.el'.••(dired-do-search REGEXP)••Search through all marked files for a match for REGEXP.•Stops when a match is found.•To continue searching for next match, use command &lt;C-kp-0&gt;.",
"dired-get-marked-files":"dired-get-marked-files is a Lisp function in `dired+.el'.••(dired-get-marked-files &amp;optional LOCALP ARG FILTER•DISTINGUISH-ONE-MARKED)••Return names of the marked files as a list of strings.•The list is in the same order as the buffer, that is, the car is the•  first marked file.•Values returned are normally absolute file names.•Optional arg LOCALP as in `dired-get-filename'.•Optional second argument ARG specifies files to use instead of marked.• Usually ARG comes from the command's prefix arg.• If ARG is an integer, use the next ARG files (previous -ARG, if &lt; 0).• If ARG is a cons with element 16, 64, or 256, corresponding to•  `C-u C-u', `C-u C-u C-u', or `C-u C-u C-u C-u', then use all files•  in the Dired buffer, where:•    16 includes NO directories (including `.' and `..')•    64 includes directories EXCEPT `.' and `..'•   256 includes ALL directories (including `.' and `..')• If ARG is otherwise non-nil, use the current file.•Optional third argument FILTER, if non-nil, is a function to select• some of the files: those for which (funcall FILTER FILENAME) is• non-nil.•If DISTINGUISH-ONE-MARKED is non-nil, then return (t FILENAME) instead• of (FILENAME), if only one file is marked.  Do not use non-nil• DISTINGUISH-ONE-MARKED together with FILTER.",
"dired-jump":"dired-jump is an interactive autoloaded compiled Lisp function in•`dired-x.el'.••(dired-jump &amp;optional OTHER-WINDOW FILE-NAME)••Jump to dired buffer corresponding to current buffer.•If in a file, dired the current directory and move to file's line.•If in Dired already, pop up a level and goto old directory's line.•In case the proper dired file line cannot be found, refresh the dired•buffer and try again.•When OTHER-WINDOW is non-nil, jump to dired buffer in other window.•Interactively with prefix argument, read FILE-NAME and•move to its line in dired.",
"dired-mark-files-regexp":"dired-mark-files-regexp is an interactive Lisp function in•`dired+.el'.••(dired-mark-files-regexp REGEXP &amp;optional MARKER-CHAR)••Mark all files matching REGEXP for use in later commands.•A prefix argument means to unmark them instead.•`.' and `..' are never marked.••REGEXP is an Emacs regexp, not a shell wildcard.  Thus, use `⧷.o$' for•object files--just `.o' will mark more than you might think.••REGEXP is added to `regexp-search-ring', for regexp search.",
"dired-mode":"dired-mode is an autoloaded compiled Lisp function in `dired.el'.••(dired-mode &amp;optional DIRNAME SWITCHES)••Mode for ⧷&quoteediting⧷&quote directory listings.•In Dired, you are ⧷&quoteediting⧷&quote a list of the files in a directory and•  (optionally) its subdirectories, in the format of `ls -lR'.•  Each directory is a page: use C-x [ and C-x ] to move pagewise.•⧷&quoteEditing⧷&quote means that you can run shell commands on files, visit,•  compress, load or byte-compile them, change their file attributes•  and insert subdirectories into the same buffer.  You can ⧷&quotemark⧷&quote•  files for later commands or ⧷&quoteflag⧷&quote them for deletion, either file•  by file or all files matching certain criteria.•You can move using the usual cursor motion commands.•The buffer is read-only.  Digits are prefix arguments.•Type d to flag a file `D' for deletion.•Type m to Mark a file or subdirectory for later commands.•  Most commands operate on the marked files and use the current file•  if no files are marked.  Use a numeric prefix argument to operate on•  the next ARG (or previous -ARG if ARG&lt;0) files, or just `1'•  to operate on the current file only.  Prefix arguments override marks.•  Mark-using commands display a list of failures afterwards.  Type ?•  to see why something went wrong.•Type u to Unmark a file or all files of an inserted subdirectory.•Type DEL to back up one line and unmark or unflag.•Type x to delete (eXecute) the files flagged `D'.•Type RET to Find the current line's file•  (or dired it in another buffer, if it is a directory).•Type o to find file or dired directory in Other window.•Type i to Insert a subdirectory in this buffer.•Type R to Rename a file or move the marked files to another directory.•Type C to Copy files.•Type s to toggle Sorting by name/date or change the `ls' switches.•Type g to read all currently expanded directories aGain.•  This retains all marks and hides subdirs again that were hidden before.•Use `SPC' and `DEL' to move down and up by lines.••If Dired ever gets confused, you can either type g to read the•directories again, type l to relist the file at point or the marked files or a•subdirectory, or type M-x dired-build-subdir-alist to parse the buffer•again for the directory tree.••Customization variables (rename this buffer and type C-h v on each line•for more info):••  `dired-listing-switches'•  `dired-trivial-filenames'•  `dired-marker-char'•  `dired-del-marker'•  `dired-keep-marker-rename'•  `dired-keep-marker-copy'•  `dired-keep-marker-hardlink'•  `dired-keep-marker-symlink'••Hooks (use C-h v to see their documentation):••  `dired-before-readin-hook'•  `dired-after-readin-hook'•  `dired-mode-hook'•  `dired-load-hook'••Keybindings:•key             binding•---             -------••e .. f          dired-find-file••C-h             Prefix Command•RET             dired-find-file•C-o             diredp-find-file-other-frame•C-t             Prefix Command•ESC             Prefix Command•SPC             dired-next-line•!               dired-do-shell-command•#               dired-flag-auto-save-files•$               dired-hide-subdir•%               Prefix Command•&amp;               dired-do-async-shell-command•*               Prefix Command•+               dired-create-directory•-               negative-argument•.               dired-clean-directory•0 .. 9          digit-argument•:               Prefix Command•&lt;               dired-prev-dirline•=               diredp-ediff•&gt;               dired-next-dirline•?               dired-summary•A               dired-do-search•B               dired-do-byte-compile•C               dired-do-copy•D               dired-do-delete•F               dired-do-find-marked-files•G               dired-do-chgrp•H               dired-do-hardlink•I               dired-info•L               dired-do-load•M               dired-do-chmod•N               dired-man•O               dired-do-chown•P               dired-do-print•Q               dired-do-query-replace-regexp•R               dired-do-rename•S               dired-do-symlink•T               Prefix Command•U               dired-unmark-all-marks•V               dired-do-run-mail•X               dired-do-shell-command•Y               dired-do-relsymlink•Z               dired-do-compress•^               dired-up-directory•_               dired-show-file-type•a               dired-find-alternate-file•b               diredp-byte-compile-this-file•d               dired-flag-file-deletion•g               revert-buffer•h               describe-mode•i               dired-maybe-insert-subdir•j               dired-goto-file•k               dired-do-kill-lines•l               dired-do-redisplay•m               dired-mark•n               dired-next-line•o               dired-find-file-other-window•p               dired-previous-line•q               quit-window•r               diredp-rename-this-file•s               dired-sort-toggle-or-edit•t               dired-toggle-marks•u               dired-unmark•v               dired-view-file•w               dired-copy-filename-as-kill•x               dired-do-flagged-delete•y               diredp-relsymlink-this-file•z               diredp-compress-this-file•~               dired-flag-backup-files•DEL             dired-unmark-backward•C-S-b           diredp-bookmark-this-file•&lt;M-mouse-2&gt;     diredp-mouse-find-file-other-frame•&lt;S-down-mouse-1&gt;                ignore•&lt;S-down-mouse-2&gt;                diredp-mouse-find-file•&lt;S-mouse-1&gt;                     diredp-mouse-mark-region-files•&lt;S-mouse-2&gt;                     ignore•&lt;deleteline&gt;                    diredp-delete-this-file•&lt;down-mouse-3&gt;                  diredp-mouse-3-menu•&lt;f1&gt;            Prefix Command•&lt;follow-link&gt;   mouse-face•&lt;help&gt;          Prefix Command•&lt;menu&gt;          Prefix Command•&lt;mouse-2&gt;       dired-mouse-find-file-other-window•&lt;mouse-3&gt;       ignore•&lt;remap&gt;         Prefix Command••C-h RET         diredp-describe-file•C-h m           diredp-describe-mode•C-h &lt;C-return&gt;  diredp-describe-file••C-t C-t         image-dired-dired-toggle-marked-thumbs•C-t .           image-dired-display-thumb•C-t a           image-dired-display-thumbs-append•C-t c           image-dired-dired-comment-files•C-t d           image-dired-display-thumbs•C-t e           image-dired-dired-edit-comment-and-tags•C-t f           image-dired-mark-tagged-files•C-t i           image-dired-dired-display-image•C-t j           image-dired-jump-thumbnail-buffer•C-t r           image-dired-delete-tag•C-t t           image-dired-tag-files•C-t x           image-dired-dired-display-external••C-M-b           diredp-set-bookmark-file-bookmark-for-marked•C-M-d           dired-tree-down•C-M-n           dired-next-subdir•C-M-o           dired-display-file•C-M-p           dired-prev-subdir•C-M-u           dired-tree-up•M-!             dired-smart-shell-command•M-$             dired-hide-all•M-(             dired-mark-sexp•M-+             Prefix Command•M-G             dired-goto-subdir•M-M             diredp-chmod-this-file•M-T             diredp-touch-this-file•M-b             diredp-do-bookmark•M-c             diredp-capitalize-this-file•M-g             diredp-do-grep•M-i             diredp-insert-subdirs•M-l             diredp-downcase-this-file•M-o             dired-omit-mode•M-p             diredp-print-this-file•M-s             Prefix Command•M-u             diredp-upcase-this-file•M-{             dired-prev-marked-file•M-}             dired-next-marked-file•M-DEL           dired-unmark-all-files•C-M-S-b         diredp-do-bookmark-in-bookmark-file•C-M-S-t         dired-do-touch•C-M-*           diredp-marked-other-window••M-s a           Prefix Command•M-s f           Prefix Command••M-+ C-t         Prefix Command•M-+ ESC         Prefix Command•M-+ !           diredp-do-shell-command-recursive•M-+ %           Prefix Command•M-+ :           Prefix Command•M-+ A           diredp-do-search-recursive•M-+ C           diredp-do-copy-recursive•M-+ F           diredp-do-find-marked-files-recursive•M-+ H           diredp-do-hardlink-recursive•M-+ M           diredp-do-chmod-recursive•M-+ P           diredp-do-print-recursive•M-+ Q           diredp-do-query-replace-regexp-recursive•M-+ R           diredp-do-move-recursive•M-+ S           diredp-do-symlink-recursive•M-+ Y           diredp-do-relsymlink-recursive•M-+ l           diredp-list-marked-recursive••% &amp;             dired-flag-garbage-files•% C             dired-do-copy-regexp•% H             dired-do-hardlink-regexp•% R             dired-do-rename-regexp•% S             dired-do-symlink-regexp•% Y             dired-do-relsymlink-regexp•% c             diredp-capitalize•% d             dired-flag-files-regexp•% g             dired-mark-files-containing-regexp•% l             dired-downcase•% m             dired-mark-files-regexp•% r             dired-do-rename-regexp•% u             dired-upcase••* C-n           dired-next-marked-file•* C-p           dired-prev-marked-file•* !             dired-unmark-all-marks•* %             dired-mark-files-regexp•* (             dired-mark-sexp•* *             dired-mark-executables•* .             diredp-mark/unmark-extension•* /             dired-mark-directories•* ?             dired-unmark-all-files•* @             dired-mark-symlinks•* O             dired-mark-omitted•* c             dired-change-marks•* m             dired-mark•* s             dired-mark-subdir-files•* t             dired-toggle-marks•* u             dired-unmark•* DEL           dired-unmark-backward••: d             epa-dired-do-decrypt•: e             epa-dired-do-encrypt•: s             epa-dired-do-sign•: v             epa-dired-do-verify••T C-y           diredp-paste-add-tags-this-file•T ESC           Prefix Command•T +             diredp-tag-this-file•T -             diredp-untag-this-file•T 0             diredp-remove-all-tags-this-file•T &gt;             Prefix Command•T c             diredp-copy-tags-this-file•T m             Prefix Command•T p             diredp-paste-add-tags-this-file•T q             diredp-paste-replace-tags-this-file•T u             Prefix Command•T v             diredp-set-tag-value-this-file••&lt;menu&gt; e        Prefix Command••&lt;help&gt; m        diredp-describe-mode••&lt;f1&gt; m          diredp-describe-mode••&lt;remap&gt; &lt;advertised-undo&gt;       dired-undo•&lt;remap&gt; &lt;next-line&gt;             dired-next-line•&lt;remap&gt; &lt;previous-line&gt;         dired-previous-line•&lt;remap&gt; &lt;read-only-mode&gt;        dired-toggle-read-only•&lt;remap&gt; &lt;toggle-read-only&gt;      dired-toggle-read-only•&lt;remap&gt; &lt;undo&gt;                  dired-undo••M-s f C-s       dired-isearch-filenames•M-s f ESC       Prefix Command••M-s a C-s       dired-do-isearch•M-s a ESC       Prefix Command••M-+ C-t c       diredp-image-dired-comment-files-recursive•M-+ C-t d       diredp-image-dired-display-thumbs-recursive•M-+ C-t r       diredp-image-dired-delete-tag-recursive•M-+ C-t t       diredp-image-dired-tag-files-recursive••M-+ C-M-b       diredp-set-bookmark-file-bookmark-for-marked-recursive•M-+ M-b         diredp-do-bookmark-recursive•M-+ M-g         diredp-do-grep-recursive•M-+ M-i         diredp-insert-subdirs-recursive•M-+ M-s         Prefix Command•M-+ M-w         diredp-copy-filename-as-kill-recursive•M-+ C-M-S-b     diredp-do-bookmark-in-bookmark-file-recursive•M-+ C-M-S-t     diredp-do-touch-recursive•M-+ C-M-*       diredp-marked-recursive-other-window••M-+ M-s a       Prefix Command••M-+ % c         diredp-capitalize-recursive•M-+ % l         diredp-downcase-recursive•M-+ % u         diredp-upcase-recursive••M-+ : d         diredp-do-decrypt-recursive•M-+ : e         diredp-do-encrypt-recursive•M-+ : s         diredp-do-sign-recursive•M-+ : v         diredp-do-verify-recursive••T u %           diredp-unmark-files-tagged-regexp•T u *           diredp-unmark-files-tagged-all•T u +           diredp-unmark-files-tagged-some•T u ~           Prefix Command••T m %           diredp-mark-files-tagged-regexp•T m *           diredp-mark-files-tagged-all•T m +           diredp-mark-files-tagged-some•T m ~           Prefix Command••T &gt; C-y         diredp-do-paste-add-tags•T &gt; +           diredp-do-tag•T &gt; -           diredp-do-untag•T &gt; 0           diredp-do-remove-all-tags•T &gt; p           diredp-do-paste-add-tags•T &gt; q           diredp-do-paste-replace-tags•T &gt; v           diredp-do-set-tag-value••T M-w           diredp-copy-tags-this-file••&lt;menu&gt; e 8      wdired-change-to-wdired-mode••M-s f C-M-s     dired-isearch-filenames-regexp••M-s a C-M-s     dired-do-isearch-regexp••M-+ M-s a C-s   diredp-do-isearch-recursive•M-+ M-s a ESC   Prefix Command••T u ~ *         diredp-unmark-files-tagged-not-all•T u ~ +         diredp-unmark-files-tagged-none••T m ~ *         diredp-mark-files-tagged-not-all•T m ~ +         diredp-mark-files-tagged-none••M-+ M-s a C-M-s                 diredp-do-isearch-regexp-recursive••",
"diredp-byte-compile-this-file":"diredp-byte-compile-this-file is an interactive Lisp function in•`dired+.el'.••(diredp-byte-compile-this-file)••In Dired, byte compile the (Lisp source) file on the cursor line.",
"dired-toggle-read-only":"dired-toggle-read-only is an interactive compiled Lisp function in•`dired.el'.••(dired-toggle-read-only)••Edit Dired buffer with Wdired, or make it read-only.•If the current buffer can be edited with Wdired, (i.e. the major•mode is `dired-mode'), call `wdired-change-to-wdired-mode'.•Otherwise, call `toggle-read-only'.",
"display-completion-list":"display-completion-list is a compiled Lisp function in•`minibuffer.el'.••(display-completion-list COMPLETIONS &amp;optional COMMON-SUBSTRING)••Display the list of completions, COMPLETIONS, using `standard-output'.•Each element may be just a symbol or string•or may be a list of two strings to be printed as if concatenated.•If it is a list of two strings, the first is the actual completion•alternative, the second serves as annotation.•`standard-output' must be a buffer.•The actual completion alternatives, as inserted, are given `mouse-face'•properties of `highlight'.•At the end, this runs the normal hook `completion-setup-hook'.•It can find the completion buffer in `standard-output'.••The obsolete optional arg COMMON-SUBSTRING, if non-nil, should be a string•specifying a common substring for adding the faces•`completions-first-difference' and `completions-common-part' to•the completions buffer.",
"doc-view-mode":"doc-view-mode is an interactive autoloaded compiled Lisp function in•`doc-view.el'.••(doc-view-mode)••Major mode in DocView buffers.••DocView Mode is an Emacs document viewer.  It displays PDF, PS•and DVI files (as PNG images) in Emacs buffers.••You can use C-c C-c to•toggle between displaying the document or editing it as text.•key             binding•---             -------••C-c             Prefix Command•RET             image-next-line•C-n             doc-view-next-line-or-next-page•C-p             doc-view-previous-line-or-previous-page•C-r             doc-view-search-backward•C-s             doc-view-search•C-t             doc-view-show-tooltip•ESC             Prefix Command•SPC             doc-view-scroll-up-or-next-page•+               doc-view-enlarge•-               doc-view-shrink•0 .. 9          digit-argument•&lt;               beginning-of-buffer•&gt;               end-of-buffer•?               describe-mode•H               doc-view-fit-height-to-window•K               doc-view-kill-proc•P               doc-view-fit-page-to-window•W               doc-view-fit-width-to-window•g               doc-view-revert-buffer•h               describe-mode•k               doc-view-kill-proc-and-buffer•n               doc-view-next-page•p               doc-view-previous-page•q               quit-window•r               doc-view-revert-buffer•s               Prefix Command•DEL             doc-view-scroll-down-or-previous-page•&lt;down&gt;          doc-view-next-line-or-next-page•&lt;find&gt;          doc-view-search•&lt;next&gt;          forward-page•&lt;prior&gt;         backward-page•&lt;remap&gt;         Prefix Command•&lt;up&gt;            doc-view-previous-line-or-previous-page••C-c C-c         doc-view-toggle-display•C-c C-t         doc-view-open-text••s b             doc-view-set-slice-from-bounding-box•s m             doc-view-set-slice-using-mouse•s r             doc-view-reset-slice•s s             doc-view-set-slice••M-&lt;             doc-view-first-page•M-&gt;             doc-view-last-page••&lt;remap&gt; &lt;backward-page&gt;         doc-view-previous-page•&lt;remap&gt; &lt;forward-page&gt;          doc-view-next-page•&lt;remap&gt; &lt;goto-line&gt;             doc-view-goto-page••&lt;remap&gt; &lt;backward-char&gt;         image-backward-hscroll•&lt;remap&gt; &lt;beginning-of-buffer&gt;   image-bob•&lt;remap&gt; &lt;end-of-buffer&gt;         image-eob•&lt;remap&gt; &lt;forward-char&gt;          image-forward-hscroll•&lt;remap&gt; &lt;left-char&gt;             image-backward-hscroll•&lt;remap&gt; &lt;move-beginning-of-line&gt;•                                image-bol•&lt;remap&gt; &lt;move-end-of-line&gt;      image-eol•&lt;remap&gt; &lt;next-line&gt;             image-next-line•&lt;remap&gt; &lt;previous-line&gt;         image-previous-line•&lt;remap&gt; &lt;right-char&gt;            image-forward-hscroll•&lt;remap&gt; &lt;scroll-down&gt;           image-scroll-down•&lt;remap&gt; &lt;scroll-down-command&gt;   image-scroll-down•&lt;remap&gt; &lt;scroll-up&gt;             image-scroll-up•&lt;remap&gt; &lt;scroll-up-command&gt;     image-scroll-up••C-c C-c         image-toggle-display•  (that binding is currently shadowed by another mode)••",
"dolist":"dolist is an alias for `cl-dolist' in `cl.el'.••(dolist (VAR LIST [RESULT]) BODY...)••Loop over a list.•Evaluate BODY with VAR bound to each `car' from LIST, in turn.•Then evaluate RESULT to get return value, default nil.•An implicit nil block is established around the loop.",
"dotimes":"dotimes is an alias for `cl-dotimes' in `cl.el'.••(dotimes (VAR COUNT [RESULT]) BODY...)••Loop a certain number of times.•Evaluate BODY with VAR bound to successive integers from 0, inclusive,•to COUNT, exclusive.  Then evaluate RESULT to get return value, default•nil.",
"downcase":"downcase is a built-in function in `C source code'.••(downcase OBJ)••Convert argument to lower case and return that.•The argument may be a character or string.  The result has the same type.•The argument object is not altered--the value is a copy.",
"downcase-region":"downcase-region is an interactive built-in function in `C source•code'.••(downcase-region BEG END)••Convert the region to lower case.  In programs, wants two arguments.•These arguments specify the starting and ending character numbers of•the region to operate on.  When used as a command, the text between•point and the mark is operated on.",
"downcase-word":"downcase-word is an interactive built-in function in `C source code'.••(downcase-word ARG)••Convert following word (or ARG words) to lower case, moving over.•With negative argument, convert previous words but do not move.",
"down-list":"down-list is an interactive compiled Lisp function in `lisp.el'.••(down-list &amp;optional ARG)••Move forward down one level of parentheses.•With ARG, do this that many times.•A negative argument means move backward but still go down a level.•This command assumes point is not in a string or comment.",
"ediff":"ediff is an alias for `ediff-files' in `ediff.el'.••(ediff FILE-A FILE-B &amp;optional STARTUP-HOOKS)••Run Ediff on a pair of files, FILE-A and FILE-B.",
"electric-pair-mode":"electric-pair-mode is an interactive autoloaded compiled Lisp function•in `electric.el'.••(electric-pair-mode &amp;optional ARG)••Toggle automatic parens pairing (Electric Pair mode).•With a prefix argument ARG, enable Electric Pair mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••Electric Pair mode is a global minor mode.  When enabled, typing•an open parenthesis automatically inserts the corresponding•closing parenthesis.  (Likewise for brackets, etc.)••See options `electric-pair-pairs' and `electric-pair-skip-self'.",
"elisp-index-search":"elisp-index-search is an interactive compiled Lisp function in•`menu-bar.el'.••(elisp-index-search TOPIC)••Look up TOPIC in the indices of the Emacs Lisp Reference Manual.••This function is advised.••Before-advice `interactive-default':•Provide the symbol at point as the default when reading TOPIC interactively.",
"elt":"elt is a built-in function in `C source code'.••(elt SEQUENCE N)••Return element of SEQUENCE at index N.",
"emacs-index-search":"emacs-index-search is an interactive compiled Lisp function in•`menu-bar.el'.••(emacs-index-search TOPIC)••Look up TOPIC in the indices of the Emacs User Manual.",
"emacs-lisp-mode":"emacs-lisp-mode is an interactive compiled Lisp function in•`lisp-mode.el'.••(emacs-lisp-mode)••Parent mode: `prog-mode'.••Major mode for editing Lisp code to run in Emacs.•Commands:•Delete converts tabs to spaces as it moves back.•Blank lines separate paragraphs.  Semicolons start comments.••key             binding•---             -------••ESC             Prefix Command•DEL             backward-delete-char-untabify••C-M-i           completion-at-point•C-M-q           indent-pp-sexp•C-M-x           eval-defun••C-M-q           indent-sexp•  (that binding is currently shadowed by another mode)•••Entry to this mode calls the value of `emacs-lisp-mode-hook'•if that value is non-nil.",
"end-kbd-macro":"end-kbd-macro is an interactive built-in function in `C source code'.••(end-kbd-macro &amp;optional REPEAT LOOPFUNC)••Finish defining a keyboard macro.•The definition was started by M-x start-kbd-macro.•The macro is now available for use via M-x call-last-kbd-macro,•or it can be given a name with M-x name-last-kbd-macro and then invoked•under that name.••With numeric arg, repeat macro now that many times,•counting the definition just completed as the first repetition.•An argument of zero means repeat until error.••In Lisp, optional second arg LOOPFUNC may be a function that is called prior to•each iteration of the macro.  Iteration stops if LOOPFUNC returns nil.",
"end-of-buffer":"end-of-buffer is an interactive compiled Lisp function in `simple.el'.••(end-of-buffer &amp;optional ARG)••Move point to the end of the buffer.•With numeric arg N, put point N/10 of the way from the end.•If the buffer is narrowed, this command uses the end of the•accessible part of the buffer.••If Transient Mark mode is disabled, leave mark at previous•position, unless a C-u prefix is supplied.••Don't use this command in Lisp programs!•(goto-char (point-max)) is faster.••This function is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `end-of-buffer'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-end-of-buffer-keymap'.•",
"end-of-defun":"end-of-defun is an interactive compiled Lisp function in `lisp.el'.••(end-of-defun &amp;optional ARG)••Move forward to next end of defun.•With argument, do it that many times.•Negative argument -N means move back to Nth preceding end of defun.••An end of a defun occurs right after the close-parenthesis that•matches the open-parenthesis that starts a defun; see function•`beginning-of-defun'.••If variable `end-of-defun-function' is non-nil, its value•is called as a function to find the defun's end.",
"end-of-line":"end-of-line is an interactive built-in function in `C source code'.••(end-of-line &amp;optional N)••Move point to end of current line (in the logical order).•With argument N not nil or 1, move forward N - 1 lines first.•If point reaches the beginning or end of buffer, it stops there.•To ignore intangibility, bind `inhibit-point-motion-hooks' to t.••This function constrains point to the current field unless this moves•point to a different line than the original, unconstrained result.  If•N is nil or 1, and a rear-sticky field ends at point, the point does•not move.  To ignore field boundaries bind `inhibit-field-text-motion'•to t.",
"enlarge-window":"enlarge-window is an interactive compiled Lisp function in•`window.el'.••(enlarge-window DELTA &amp;optional HORIZONTAL)••Make the selected window DELTA lines taller.•Interactively, if no argument is given, make the selected window•one line taller.  If optional argument HORIZONTAL is non-nil,•make selected window wider by DELTA columns.  If DELTA is•negative, shrink selected window by -DELTA lines or columns.",
"enlarge-window-horizontally":"enlarge-window-horizontally is an interactive compiled Lisp function•in `window.el'.••(enlarge-window-horizontally DELTA)••Make selected window DELTA columns wider.•Interactively, if no argument is given, make selected window one•column wider.",
"enriched-mode":"enriched-mode is an interactive autoloaded compiled Lisp function in•`enriched.el'.••(enriched-mode &amp;optional ARG)••Minor mode for editing text/enriched files.•These are files with embedded formatting information in the MIME standard•text/enriched format.••With a prefix argument ARG, enable the mode if ARG is positive,•and disable it otherwise.  If called from Lisp, enable the mode•if ARG is omitted or nil.••Turning the mode on or off runs `enriched-mode-hook'.••More information about Enriched mode is available in the file•etc/enriched.doc in the Emacs distribution directory.••Commands:••key             binding•---             -------••C-c             Prefix Command•RET             reindent-then-newline-and-indent•C-x             Prefix Command•ESC             Prefix Command•&lt;remap&gt;         Prefix Command••C-c [           set-left-margin•C-c ]           set-right-margin••C-x TAB         increase-left-margin••M-S             set-justification-center•M-j             facemenu-justification-menu••M-j b           set-justification-full•M-j c           set-justification-center•M-j l           set-justification-left•M-j r           set-justification-right•M-j u           set-justification-none••&lt;remap&gt; &lt;move-beginning-of-line&gt;•                                beginning-of-line-text•&lt;remap&gt; &lt;newline-and-indent&gt;    reindent-then-newline-and-indent••",
"eq":"eq is a built-in function in `C source code'.••(eq OBJ1 OBJ2)••Return t if the two args are the same Lisp object.",
"equal":"equal is a built-in function in `C source code'.••(equal O1 O2)••Return t if two Lisp objects have similar structure and contents.•They must have the same data type.•Conses are compared by comparing the cars and the cdrs.•Vectors and strings are compared element by element.•Numbers are compared by value, but integers cannot equal floats.• (Use `=' if you want integers and floats to be able to be equal.)•Symbols must match exactly.",
"erase-buffer":"erase-buffer is an interactive built-in function in `C source code'.••(erase-buffer)••Delete the entire contents of the current buffer.•Any narrowing restriction in effect (see `narrow-to-region') is removed,•so the buffer is truly empty after this.",
"ergoemacs-close-current-buffer":"ergoemacs-close-current-buffer is an interactive compiled Lisp•function in `ergoemacs-functions.el'.••(ergoemacs-close-current-buffer)••Close the current buffer.••Similar to (kill-buffer (current-buffer)) with the following addition:••• prompt user to save if the buffer has been modified even if the buffer is not associated with a file.•• make sure the buffer shown after closing is a user buffer.•• if the buffer is a file, add the path to the list `recently-closed-buffers'.••A emacs buffer is one who's name starts with *.•Else it is a user buffer.",
"ergoemacs-extras":"ergoemacs-extras is an interactive compiled Lisp function in•`ergoemacs-extras.el'.••(ergoemacs-extras &amp;optional LAYOUTS)••Generate layout diagram, and other scripts for system-wide ErgoEmacs keybinding.••The following are generated:•• SVG Diagram for ErgoEmacs command layouts in SVG format.•• Bash 〔.inputrc〕 code.•• Mac OS X 〔DefaultKeyBinding.dict〕 code.•• AutoHotkey script for Microsoft Windows.••Files are generated in the dir 〔ergoemacs-extras〕 at `user-emacs-directory'.",
"ergoemacs-mode":"ergoemacs-mode is an interactive compiled Lisp function in•`ergoemacs-mode.el'.••(ergoemacs-mode &amp;optional ARG)••Toggle ergoemacs keybinding minor mode.•This minor mode changes your emacs keybinding.••Without argument, toggles the minor mode.•If optional argument is 1, turn it on.•If optional argument is 0, turn it off.••Home page URL `http://ergoemacs.org/emacs/ergonomic_emacs_keybinding.html'••For the standard layout, with A QWERTY keyboard the `execute-extended-command' 【Alt+x】 is now 【Alt+a】 or the PC keyboard's 【Menu】 key.",
"ergoemacs-next-user-buffer":"ergoemacs-next-user-buffer is an interactive compiled Lisp function in•`ergoemacs-functions.el'.••(ergoemacs-next-user-buffer)••Switch to the next user buffer.•User buffers are those whose name does not start with *.",
"ergoemacs-previous-user-buffer":"ergoemacs-previous-user-buffer is an interactive compiled Lisp•function in `ergoemacs-functions.el'.••(ergoemacs-previous-user-buffer)••Switch to the previous user buffer.•User buffers are those whose name does not start with *.",
"ergoemacs-switch-to-next-frame":"ergoemacs-switch-to-next-frame is an interactive compiled Lisp•function in `ergoemacs-functions.el'.••(ergoemacs-switch-to-next-frame &amp;optional NUMBER)••Select the next frame on current display, and raise it.",
"error":"error is a compiled Lisp function in `subr.el'.••(error STRING &amp;rest ARGS)••Signal an error, making error message by passing all args to `format'.•In Emacs, the convention is that error messages start with a capital•letter but *do not* end with a period.  Please follow this convention•for the sake of consistency.",
"eshell":"eshell is an interactive autoloaded Lisp function in `eshell.el'.••(eshell &amp;optional ARG)••Create an interactive Eshell buffer.•The buffer used for Eshell sessions is determined by the value of•`eshell-buffer-name'.  If there is already an Eshell session active in•that buffer, Emacs will simply switch to it.  Otherwise, a new session•will begin.  A numeric prefix arg (as in `C-u 42 M-x eshell RET')•switches to the session with that number, creating it if necessary.  A•nonnumeric prefix arg means to create a new session.  Returns the•buffer selected (or created).",
"eval-buffer":"eval-buffer is an interactive built-in function in `C source code'.••(eval-buffer &amp;optional BUFFER PRINTFLAG FILENAME UNIBYTE•DO-ALLOW-PRINT)••Execute the current buffer as Lisp code.•When called from a Lisp program (i.e., not interactively), this•function accepts up to five optional arguments:•BUFFER is the buffer to evaluate (nil means use current buffer).•PRINTFLAG controls printing of output:• A value of nil means discard it; anything else is stream for print.•FILENAME specifies the file name to use for `load-history'.•UNIBYTE, if non-nil, specifies `load-convert-to-unibyte' for this• invocation.•DO-ALLOW-PRINT, if non-nil, specifies that `print' and related• functions should work normally even if PRINTFLAG is nil.••This function preserves the position of point.",
"eval-defun":"eval-defun is an interactive compiled Lisp function in `lisp-mode.el'.••(eval-defun EDEBUG-IT)••Evaluate the top-level form containing point, or after point.••If the current defun is actually a call to `defvar' or `defcustom',•evaluating it this way resets the variable using its initial value•expression even if the variable already has some other value.•(Normally `defvar' and `defcustom' do not alter the value if there•already is one.)  In an analogous way, evaluating a `defface'•overrides any customizations of the face, so that it becomes•defined exactly as the `defface' expression says.••If `eval-expression-debug-on-error' is non-nil, which is the default,•this command arranges for all errors to enter the debugger.••With a prefix argument, instrument the code for Edebug.••If acting on a `defun' for FUNCTION, and the function was•instrumented, `Edebug: FUNCTION' is printed in the minibuffer.  If not•instrumented, just FUNCTION is printed.••If not acting on a `defun', the result of evaluation is displayed in•the minibuffer.  This display is controlled by the variables•`eval-expression-print-length' and `eval-expression-print-level',•which see.",
"eval-expression":"eval-expression is an interactive compiled Lisp function in•`simple.el'.••(eval-expression EVAL-EXPRESSION-ARG &amp;optional•EVAL-EXPRESSION-INSERT-VALUE)••Evaluate EVAL-EXPRESSION-ARG and print value in the echo area.•When called interactively, read an Emacs Lisp expression and•evaluate it.•Value is also consed on to front of the variable `values'.•Optional argument EVAL-EXPRESSION-INSERT-VALUE non-nil (interactively,•with prefix argument) means insert the result into the current buffer•instead of printing it in the echo area.  Truncates long output•according to the value of the variables `eval-expression-print-length'•and `eval-expression-print-level'.••If `eval-expression-debug-on-error' is non-nil, which is the default,•this command arranges for all errors to enter the debugger.",
"eval-last-sexp":"eval-last-sexp is an interactive compiled Lisp function in•`lisp-mode.el'.••(eval-last-sexp EVAL-LAST-SEXP-ARG-INTERNAL)••Evaluate sexp before point; print value in minibuffer.•Interactively, with prefix argument, print output into current buffer.•Truncates long output according to the value of the variables•`eval-expression-print-length' and `eval-expression-print-level'.••If `eval-expression-debug-on-error' is non-nil, which is the default,•this command arranges for all errors to enter the debugger.",
"eval-region":"eval-region is an interactive built-in function in `C source code'.••(eval-region START END &amp;optional PRINTFLAG READ-FUNCTION)••Execute the region as Lisp code.•When called from programs, expects two arguments,•giving starting and ending indices in the current buffer•of the text to be executed.•Programs can pass third argument PRINTFLAG which controls output:•A value of nil means discard it; anything else is stream for printing it.•Also the fourth argument READ-FUNCTION, if non-nil, is used•instead of `read' to read each expression.  It gets one argument•which is the input stream for reading characters.••This function does not move point.",
"exchange-point-and-mark":"exchange-point-and-mark is an interactive compiled Lisp function in•`simple.el'.••(exchange-point-and-mark &amp;optional ARG)••Put the mark where point is now, and point where the mark is now.•This command works even when the mark is not active,•and it reactivates the mark.••If Transient Mark mode is on, a prefix ARG deactivates the mark•if it is active, and otherwise avoids reactivating it.  If•Transient Mark mode is off, a prefix ARG enables Transient Mark•mode temporarily.",
"execute-extended-command":"execute-extended-command is an interactive compiled Lisp function in•`simple.el'.••(execute-extended-command PREFIXARG &amp;optional COMMAND-NAME)••Read function name, then read its arguments and call it.••To pass a numeric argument to the command you are invoking, specify•the numeric argument to this command.••Noninteractively, the argument PREFIXARG is the prefix argument to•give to the command you invoke, if it asks for an argument.",
"exit-minibuffer":"exit-minibuffer is an interactive compiled Lisp function in•`minibuffer.el'.••(exit-minibuffer)••Terminate this minibuffer argument.",
"expand-file-name":"expand-file-name is a built-in function in `C source code'.••(expand-file-name NAME &amp;optional DEFAULT-DIRECTORY)••Convert filename NAME to absolute, and canonicalize it.•Second arg DEFAULT-DIRECTORY is directory to start with if NAME is relative•(does not start with slash or tilde); if DEFAULT-DIRECTORY is nil or missing,•the current buffer's value of `default-directory' is used.•NAME should be a string that is a valid file name for the underlying•filesystem.•File name components that are `.' are removed, and•so are file name components followed by `..', along with the `..' itself;•note that these simplifications are done without checking the resulting•file names in the file system.•Multiple consecutive slashes are collapsed into a single slash,•except at the beginning of the file name when they are significant (e.g.,•UNC file names on MS-Windows.)•An initial `~/' expands to your home directory.•An initial `~USER/' expands to USER's home directory.•See also the function `substitute-in-file-name'.••For technical reasons, this function can return correct but•non-intuitive results for the root directory; for instance,•(expand-file-name ⧷&quote..⧷&quote ⧷&quote/⧷&quote) returns ⧷&quote/..⧷&quote.  For this reason, use•(directory-file-name (file-name-directory dirname)) to traverse a•filesystem tree, not (expand-file-name ⧷&quote..⧷&quote  dirname).",
"expt":"expt is a built-in function in `C source code'.••(expt ARG1 ARG2)••Return the exponential ARG1 ** ARG2.",
"extract-rectangle":"extract-rectangle is an autoloaded compiled Lisp function in•`rect.el'.••(extract-rectangle START END)••Return the contents of the rectangle with corners at START and END.•Return it as a list of strings, one for each line of the rectangle.",
"face-font":"face-font is a built-in function in `C source code'.••(face-font FACE &amp;optional FRAME CHARACTER)••Return the font name of face FACE, or nil if it is unspecified.•The font name is, by default, for ASCII characters.•If the optional argument FRAME is given, report on face FACE in that frame.•If FRAME is t, report on the defaults for face FACE (for new frames).•  The font default for a face is either nil, or a list•  of the form (bold), (italic) or (bold italic).•If FRAME is omitted or nil, use the selected frame.  And, in this case,•if the optional third argument CHARACTER is given,•return the font name used for CHARACTER.",
"face-foreground":"face-foreground is a compiled Lisp function in `faces.el'.••(face-foreground FACE &amp;optional FRAME INHERIT)••Return the foreground color name of FACE, or nil if unspecified.•If the optional argument FRAME is given, report on face FACE in that frame.•If FRAME is t, report on the defaults for face FACE (for new frames).•If FRAME is omitted or nil, use the selected frame.••If INHERIT is nil, only a foreground color directly defined by FACE is•  considered, so the return value may be nil.•If INHERIT is t, and FACE doesn't define a foreground color, then any•  foreground color that FACE inherits through its `:inherit' attribute•  is considered as well; however the return value may still be nil.•If INHERIT is a face or a list of faces, then it is used to try to•  resolve an unspecified foreground color.••To ensure that a valid color is always returned, use a value of•`default' for INHERIT; this will resolve any unspecified values by•merging with the `default' face (which is always completely specified).",
"fboundp":"fboundp is a built-in function in `C source code'.••(fboundp SYMBOL)••Return t if SYMBOL's function definition is not void.",
"featurep":"featurep is a built-in function in `C source code'.••(featurep FEATURE &amp;optional SUBFEATURE)••This function has a compiler macro.••Return t if FEATURE is present in this Emacs.••Use this to conditionalize execution of lisp code based on the•presence or absence of Emacs or environment extensions.•Use `provide' to declare that a feature is available.  This function•looks at the value of the variable `features'.  The optional argument•SUBFEATURE can be used to check a specific subfeature of FEATURE.",
"ffap":"ffap is an alias for `find-file-at-point' in `ffap.el'.••(ffap &amp;optional FILENAME)••Find FILENAME, guessing a default from text around point.•If `ffap-url-regexp' is not nil, the FILENAME may also be an URL.•With a prefix, this command behaves exactly like `ffap-file-finder'.•If `ffap-require-prefix' is set, the prefix meaning is reversed.•See also the variables `ffap-dired-wildcards', `ffap-newfile-prompt',•and the functions `ffap-file-at-point' and `ffap-url-at-point'.",
"file-exists-p":"file-exists-p is a built-in function in `C source code'.••(file-exists-p FILENAME)••Return t if file FILENAME exists (whether or not you can read it.)•See also `file-readable-p' and `file-attributes'.•This returns nil for a symlink to a nonexistent file.•Use `file-symlink-p' to test for such links.",
"file-name-directory":"file-name-directory is a built-in function in `C source code'.••(file-name-directory FILENAME)••Return the directory component in file name FILENAME.•Return nil if FILENAME does not include a directory.•Otherwise return a directory name.•Given a Unix syntax file name, returns a string ending in slash.",
"file-name-extension":"file-name-extension is a compiled Lisp function in `files.el'.••(file-name-extension FILENAME &amp;optional PERIOD)••Return FILENAME's final ⧷&quoteextension⧷&quote.•The extension, in a file name, is the part that follows the last `.',•excluding version numbers and backup suffixes,•except that a leading `.', if any, doesn't count.•Return nil for extensionless file names such as `foo'.•Return the empty string for file names such as `foo.'.••If PERIOD is non-nil, then the returned value includes the period•that delimits the extension, and if FILENAME has no extension,•the value is ⧷&quote⧷&quote.",
"file-name-nondirectory":"file-name-nondirectory is a built-in function in `C source code'.••(file-name-nondirectory FILENAME)••Return file name FILENAME sans its directory.•For example, in a Unix-syntax file name,•this is everything after the last slash,•or the entire name if it contains no slash.",
"file-name-sans-extension":"file-name-sans-extension is a compiled Lisp function in `files.el'.••(file-name-sans-extension FILENAME)••Return FILENAME sans final ⧷&quoteextension⧷&quote.•The extension, in a file name, is the part that follows the last `.',•except that a leading `.', if any, doesn't count.",
"file-relative-name":"file-relative-name is a compiled Lisp function in `files.el'.••(file-relative-name FILENAME &amp;optional DIRECTORY)••Convert FILENAME to be relative to DIRECTORY (default: `default-directory').•This function returns a relative file name which is equivalent to FILENAME•when used with that default directory as the default.•If FILENAME and DIRECTORY lie on different machines or on different drives•on a DOS/Windows machine, it returns FILENAME in expanded form.",
"fill-flowed":"fill-flowed is an autoloaded Lisp function in `flow-fill.el'.••(fill-flowed &amp;optional BUFFER DELETE-SPACE)••Not documented.",
"fill-paragraph":"fill-paragraph is an interactive compiled Lisp function in `fill.el'.••(fill-paragraph &amp;optional JUSTIFY REGION)••Fill paragraph at or after point.••If JUSTIFY is non-nil (interactively, with prefix argument), justify as well.•If `sentence-end-double-space' is non-nil, then period followed by one•space does not end a sentence, so don't break a line there.•The variable `fill-column' controls the width for filling.••If `fill-paragraph-function' is non-nil, we call it (passing our•argument to it), and if it returns non-nil, we simply return its value.••If `fill-paragraph-function' is nil, return the `fill-prefix' used for filling.••The REGION argument is non-nil if called interactively; in that•case, if Transient Mark mode is enabled and the mark is active,•call `fill-region' to fill each of the paragraphs in the active•region, instead of just filling the current paragraph.",
"fill-region":"fill-region is an interactive compiled Lisp function in `fill.el'.••(fill-region FROM TO &amp;optional JUSTIFY NOSQUEEZE TO-EOP)••Fill each of the paragraphs in the region.•A prefix arg means justify as well.•The `fill-column' variable controls the width.••Noninteractively, the third argument JUSTIFY specifies which•kind of justification to do: `full', `left', `right', `center',•or `none' (equivalent to nil).  A value of t means handle each•paragraph as specified by its text properties.••The fourth arg NOSQUEEZE non-nil means to leave whitespace other•than line breaks untouched, and fifth arg TO-EOP non-nil means•to keep filling to the end of the paragraph (or next hard newline,•if variable `use-hard-newlines' is on).••Return the fill-prefix used for filling the last paragraph.••If `sentence-end-double-space' is non-nil, then period followed by one•space does not end a sentence, so don't break a line there.",
"find":"find is an alias for `cl-find' in `cl.el'.••(find ITEM SEQ [KEYWORD VALUE]...)••Find the first occurrence of ITEM in SEQ.•Return the matching ITEM, or nil if not found.••Keywords supported:  :test :test-not :key :start :end :from-end",
"find-dired":"find-dired is an interactive autoloaded Lisp function in•`find-dired.el'.••(find-dired DIR ARGS)••Run `find' and go into Dired mode on a buffer of the output.•The command run (after changing into DIR) is essentially••    find . ⧷( ARGS ⧷) -ls••except that the car of the variable `find-ls-option' specifies what to•use in place of ⧷&quote-ls⧷&quote as the final argument.",
"find-file":"find-file is an interactive compiled Lisp function in `files.el'.••(find-file FILENAME &amp;optional WILDCARDS)••Edit file FILENAME.•Switch to a buffer visiting file FILENAME,•creating one if none already exists.•Interactively, the default if you just type RET is the current directory,•but the visited file name is available through the minibuffer history:•type M-n to pull it into the minibuffer.••You can visit files on remote machines by specifying something•like /ssh:SOME_REMOTE_MACHINE:FILE for the file name.  You can•also visit local files as a different user by specifying•/sudo::FILE for the file name.•See the Info node `(tramp)Filename Syntax' in the Tramp Info•manual, for more about this.••Interactively, or if WILDCARDS is non-nil in a call from Lisp,•expand wildcards (if any) and visit multiple files.  You can•suppress wildcard expansion by setting `find-file-wildcards' to nil.••To visit a file without any kind of conversion and without•automatically choosing a major mode, use M-x find-file-literally.",
"find-file-at-point":"find-file-at-point is an interactive autoloaded Lisp function in•`ffap.el'.••(find-file-at-point &amp;optional FILENAME)••Find FILENAME, guessing a default from text around point.•If `ffap-url-regexp' is not nil, the FILENAME may also be an URL.•With a prefix, this command behaves exactly like `ffap-file-finder'.•If `ffap-require-prefix' is set, the prefix meaning is reversed.•See also the variables `ffap-dired-wildcards', `ffap-newfile-prompt',•and the functions `ffap-file-at-point' and `ffap-url-at-point'.",
"find-file-literally":"find-file-literally is an interactive compiled Lisp function in•`files.el'.••(find-file-literally FILENAME)••Visit file FILENAME with no conversion of any kind.•Format conversion and character code conversion are both disabled,•and multibyte characters are disabled in the resulting buffer.•The major mode used is Fundamental mode regardless of the file name,•and local variable specifications in the file are ignored.•Automatic uncompression and adding a newline at the end of the•file due to `require-final-newline' is also disabled.••You cannot absolutely rely on this function to result in•visiting the file literally.  If Emacs already has a buffer•which is visiting the file, you get the existing buffer,•regardless of whether it was created literally or not.••In a Lisp program, if you want to be sure of accessing a file's•contents literally, you should create a temporary buffer and then read•the file contents into it using `insert-file-contents-literally'.",
"find-grep":"find-grep is an alias for `grep-find' in `grep.el'.••(find-grep COMMAND-ARGS)••Run grep via find, with user-specified args COMMAND-ARGS.•Collect output in a buffer.•While find runs asynchronously, you can use the C-x ` command•to find the text that grep hits refer to.••This command uses a special history list for its arguments, so you can•easily repeat a find command.",
"find-if":"find-if is an alias for `cl-find-if' in `cl.el'.••(find-if PREDICATE SEQ [KEYWORD VALUE]...)••Find the first item satisfying PREDICATE in SEQ.•Return the matching item, or nil if not found.••Keywords supported:  :key :start :end :from-end",
"find-lisp-find-files":"find-lisp-find-files is a compiled Lisp function in `find-lisp.el'.••(find-lisp-find-files DIRECTORY REGEXP)••Find files in DIRECTORY which match REGEXP.",
"find-tag":"find-tag is an interactive autoloaded compiled Lisp function in•`etags.el'.••(find-tag TAGNAME &amp;optional NEXT-P REGEXP-P)••Find tag (in current tags table) whose name contains TAGNAME.•Select the buffer containing the tag's definition, and move point there.•The default for TAGNAME is the expression in the buffer around or before point.••If second arg NEXT-P is t (interactively, with prefix arg), search for•another tag that matches the last tagname or regexp used.  When there are•multiple matches for a tag, more exact matches are found first.  If NEXT-P•is the atom `-' (interactively, with prefix arg that is a negative number•or just C-M--), pop back to the previous tag gone to.••If third arg REGEXP-P is non-nil, treat TAGNAME as a regexp.••A marker representing the point when this command is invoked is pushed•onto a ring and may be popped back to with M-x pop-tag-mark.•Contrast this with the ring of marks gone to by the command.••See documentation of variable `tags-file-name'.",
"float":"float is a built-in function in `C source code'.••(float ARG)••Return the floating point number equal to ARG.",
"floatp":"floatp is a built-in function in `C source code'.••(floatp OBJECT)••Return t if OBJECT is a floating point number.",
"flush-lines":"flush-lines is an interactive compiled Lisp function in `replace.el'.••(flush-lines REGEXP &amp;optional RSTART REND INTERACTIVE)••Delete lines containing matches for REGEXP.•When called from Lisp (and usually when called interactively as•well, see below), applies to the part of the buffer after point.•The line point is in is deleted if and only if it contains a•match for regexp starting after point.••If REGEXP contains upper case characters (excluding those preceded by `⧷')•and `search-upper-case' is non-nil, the matching is case-sensitive.••Second and third arg RSTART and REND specify the region to operate on.•Lines partially contained in this region are deleted if and only if•they contain a match entirely contained in it.••Interactively, in Transient Mark mode when the mark is active, operate•on the contents of the region.  Otherwise, operate from point to the•end of (the accessible portion of) the buffer.  When calling this function•from Lisp, you can pretend that it was called interactively by passing•a non-nil INTERACTIVE argument.••If a match is split across lines, all the lines it lies in are deleted.•They are deleted _before_ looking for the next match.  Hence, a match•starting on the same line at which another match ended is ignored.",
"flyspell-buffer":"flyspell-buffer is an interactive autoloaded compiled Lisp function in•`flyspell.el'.••(flyspell-buffer)••Flyspell whole buffer.",
"flyspell-mode":"flyspell-mode is an interactive autoloaded compiled Lisp function in•`flyspell.el'.••(flyspell-mode &amp;optional ARG)••Toggle on-the-fly spell checking (Flyspell mode).•With a prefix argument ARG, enable Flyspell mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••Flyspell mode is a buffer-local minor mode.  When enabled, it•spawns a single Ispell process and checks each word.  The default•flyspell behavior is to highlight incorrect words.••Bindings:•&lt;menu&gt; 9: correct words (using Ispell).•M-x flyspell-auto-correct-word: automatically correct word.•M-x flyspell-auto-correct-previous-word: automatically correct the last misspelled word.•M-x flyspell-correct-word (or down-mouse-2): popup correct words.••Hooks:•This runs `flyspell-mode-hook' after flyspell mode is entered or exit.••Remark:•`flyspell-mode' uses `ispell-mode'.  Thus all Ispell options are•valid.  For instance, a different dictionary can be used by•invoking `ispell-change-dictionary'.••Consider using the `ispell-parser' to check your text.  For instance•consider adding:•(add-hook 'tex-mode-hook (function (lambda () (setq ispell-parser 'tex))))•in your init file.••M-x flyspell-region checks all words inside a region.•&lt;menu&gt; t b checks the whole buffer.",
"focus-frame":"focus-frame is an alias for `ignore' in `subr.el'.••(focus-frame &amp;rest IGNORE)••This function is obsolete since 22.1;•it does nothing.••",
"follow-mode":"follow-mode is an interactive autoloaded compiled Lisp function in•`follow.el'.••(follow-mode &amp;optional ARG)••Toggle Follow mode.•With a prefix argument ARG, enable Follow mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••Follow mode is a minor mode that combines windows into one tall•virtual window.  This is accomplished by two main techniques:••* The windows always displays adjacent sections of the buffer.•  This means that whenever one window is moved, all the•  others will follow.  (Hence the name Follow mode.)••* Should the point (cursor) end up outside a window, another•  window displaying that point is selected, if possible.  This•  makes it possible to walk between windows using normal cursor•  movement commands.••Follow mode comes to its prime when used on a large screen and two•side-by-side windows are used.  The user can, with the help of Follow•mode, use two full-height windows as though they would have been•one.  Imagine yourself editing a large function, or section of text,•and being able to use 144 lines instead of the normal 72... (your•mileage may vary).••To split one large window into two side-by-side windows, the commands•`M-x split-window-right' or `M-x follow-delete-other-windows-and-split' can be used.••Only windows displayed in the same frame follow each other.••This command runs the normal hook `follow-mode-hook'.••Keys specific to Follow mode:•key             binding•---             -------••C-c             Prefix Command•&lt;remap&gt;         Prefix Command••&lt;remap&gt; &lt;end-of-buffer&gt;         follow-end-of-buffer•&lt;remap&gt; &lt;mwheel-scroll&gt;         follow-mwheel-scroll•&lt;remap&gt; &lt;scroll-bar-drag&gt;       follow-scroll-bar-drag•&lt;remap&gt; &lt;scroll-bar-scroll-down&gt;•                                follow-scroll-bar-scroll-down•&lt;remap&gt; &lt;scroll-bar-scroll-up&gt;  follow-scroll-bar-scroll-up•&lt;remap&gt; &lt;scroll-bar-toolkit-scroll&gt;•                                follow-scroll-bar-toolkit-scroll••C-c .           Prefix Command••C-c . C-b       follow-switch-to-buffer-all•C-c . C-l       follow-recenter•C-c . C-v       follow-scroll-up•C-c . ESC       Prefix Command•C-c . 1         follow-delete-other-windows-and-split•C-c . &lt;         follow-first-window•C-c . &gt;         follow-last-window•C-c . b         follow-switch-to-buffer•C-c . n         follow-next-window•C-c . p         follow-previous-window•C-c . v         follow-scroll-down••C-c . M-v       follow-scroll-down••",
"font-lock-mode":"font-lock-mode is an interactive compiled Lisp function in•`font-core.el'.••(font-lock-mode &amp;optional ARG)••Toggle syntax highlighting in this buffer (Font Lock mode).•With a prefix argument ARG, enable Font Lock mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••When Font Lock mode is enabled, text is fontified as you type it:•• - Comments are displayed in `font-lock-comment-face';• - Strings are displayed in `font-lock-string-face';• - Certain other expressions are displayed in other faces according to the•   value of the variable `font-lock-keywords'.••To customize the faces (colors, fonts, etc.) used by Font Lock for•fontifying different parts of buffer text, use M-x customize-face.••You can enable Font Lock mode in any major mode automatically by turning on in•the major mode's hook.  For example, put in your ~/.emacs:•• (add-hook 'c-mode-hook 'turn-on-font-lock)••Alternatively, you can use Global Font Lock mode to automagically turn on Font•Lock mode in buffers whose major mode supports it and whose major mode is one•of `font-lock-global-modes'.  For example, put in your ~/.emacs:•• (global-font-lock-mode t)••Where major modes support different levels of fontification, you can use•the variable `font-lock-maximum-decoration' to specify which level you•generally prefer.  When you turn Font Lock mode on/off the buffer is•fontified/defontified, though fontification occurs only if the buffer is•less than `font-lock-maximum-size'.••To add your own highlighting for some major mode, and modify the highlighting•selected automatically via the variable `font-lock-maximum-decoration', you can•use `font-lock-add-keywords'.••To fontify a buffer, without turning on Font Lock mode and regardless of buffer•size, you can use M-x font-lock-fontify-buffer.••To fontify a block (the function or paragraph containing point, or a number of•lines around point), perhaps because modification on the current line caused•syntactic change on other lines, you can use M-x font-lock-fontify-block.••You can set your own default settings for some mode, by setting a•buffer local value for `font-lock-defaults', via its mode hook.••The above is the default behavior of `font-lock-mode'; you may specify•your own function which is called when `font-lock-mode' is toggled via•`font-lock-function'. ",
"format":"format is a built-in function in `C source code'.••(format STRING &amp;rest OBJECTS)••Format a string out of a format-string and arguments.•The first argument is a format control string.•The other arguments are substituted into it to make the result, a string.••The format control string may contain %-sequences meaning to substitute•the next available argument:••%s means print a string argument.  Actually, prints any object, with `princ'.•%d means print as number in decimal (%o octal, %x hex).•%X is like %x, but uses upper case.•%e means print a number in exponential notation.•%f means print a number in decimal-point notation.•%g means print a number in exponential notation•  or decimal-point notation, whichever uses fewer characters.•%c means print a number as a single character.•%S means print any object as an s-expression (using `prin1').••The argument used for %d, %o, %x, %e, %f, %g or %c must be a number.•Use %% to put a single % into the output.••A %-sequence may contain optional flag, width, and precision•specifiers, as follows:••  %&lt;flags&gt;&lt;width&gt;&lt;precision&gt;character••where flags is [+ #-0]+, width is [0-9]+, and precision is .[0-9]+••The + flag character inserts a + before any positive number, while a•space inserts a space before any positive number; these flags only•affect %d, %e, %f, and %g sequences, and the + flag takes precedence.•The - and 0 flags affect the width specifier, as described below.••The # flag means to use an alternate display form for %o, %x, %X, %e,•%f, and %g sequences: for %o, it ensures that the result begins with•⧷&quote0⧷&quote; for %x and %X, it prefixes the result with ⧷&quote0x⧷&quote or ⧷&quote0X⧷&quote;•for %e, %f, and %g, it causes a decimal point to be included even if•the precision is zero.••The width specifier supplies a lower limit for the length of the•printed representation.  The padding, if any, normally goes on the•left, but it goes on the right if the - flag is present.  The padding•character is normally a space, but it is 0 if the 0 flag is present.•The 0 flag is ignored if the - flag is present, or the format sequence•is something other than %d, %e, %f, and %g.••For %e, %f, and %g sequences, the number after the ⧷&quote.⧷&quote in the•precision specifier says how many decimal places to show; if zero, the•decimal point itself is omitted.  For %s and %S, the precision•specifier truncates the string to the given width.",
"format-time-string":"format-time-string is a built-in function in `C source code'.••(format-time-string FORMAT-STRING &amp;optional TIME UNIVERSAL)••Use FORMAT-STRING to format the time TIME, or now if omitted.•TIME is specified as (HIGH LOW USEC PSEC), as returned by•`current-time' or `file-attributes'.  The obsolete form (HIGH . LOW)•is also still accepted.•The third, optional, argument UNIVERSAL, if non-nil, means describe TIME•as Universal Time; nil means describe TIME in the local time zone.•The value is a copy of FORMAT-STRING, but with certain constructs replaced•by text that describes the specified date and time in TIME:••%Y is the year, %y within the century, %C the century.•%G is the year corresponding to the ISO week, %g within the century.•%m is the numeric month.•%b and %h are the locale's abbreviated month name, %B the full name.•%d is the day of the month, zero-padded, %e is blank-padded.•%u is the numeric day of week from 1 (Monday) to 7, %w from 0 (Sunday) to 6.•%a is the locale's abbreviated name of the day of week, %A the full name.•%U is the week number starting on Sunday, %W starting on Monday,• %V according to ISO 8601.•%j is the day of the year.••%H is the hour on a 24-hour clock, %I is on a 12-hour clock, %k is like %H• only blank-padded, %l is like %I blank-padded.•%p is the locale's equivalent of either AM or PM.•%M is the minute.•%S is the second.•%N is the nanosecond, %6N the microsecond, %3N the millisecond, etc.•%Z is the time zone name, %z is the numeric form.•%s is the number of seconds since 1970-01-01 00:00:00 +0000.••%c is the locale's date and time format.•%x is the locale's ⧷&quotepreferred⧷&quote date format.•%D is like ⧷&quote%m/%d/%y⧷&quote.••%R is like ⧷&quote%H:%M⧷&quote, %T is like ⧷&quote%H:%M:%S⧷&quote, %r is like ⧷&quote%I:%M:%S %p⧷&quote.•%X is the locale's ⧷&quotepreferred⧷&quote time format.••Finally, %n is a newline, %t is a tab, %% is a literal %.••Certain flags and modifiers are available with some format controls.•The flags are `_', `-', `^' and `#'.  For certain characters X,•%_X is like %X, but padded with blanks; %-X is like %X,•but without padding.  %^X is like %X, but with all textual•characters up-cased; %#X is like %X, but with letter-case of•all textual characters reversed.•%NX (where N stands for an integer) is like %X,•but takes up at least N (a number) positions.•The modifiers are `E' and `O'.  For certain characters X,•%EX is a locale's alternative version of %X;•%OX is like %X, but uses the locale's number symbols.••For example, to produce full ISO 8601 format, use ⧷&quote%Y-%m-%dT%T%z⧷&quote.",
"forward-char":"forward-char is an interactive built-in function in `C source code'.••(forward-char &amp;optional N)••Move point N characters forward (backward if N is negative).•On reaching end or beginning of buffer, stop and signal error.•Interactively, N is the numeric prefix argument.••Depending on the bidirectional context, the movement may be to the•right or to the left on the screen.  This is in contrast with•&lt;right&gt;, which see.••This subr is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `forward-char'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-forward-char-keymap'.",
"forward-line":"forward-line is an interactive built-in function in `C source code'.••(forward-line &amp;optional N)••Move N lines forward (backward if N is negative).•Precisely, if point is on line I, move to the start of line I + N•(⧷&quotestart of line⧷&quote in the logical order).•If there isn't room, go as far as possible (no error).•Returns the count of lines left to move.  If moving forward,•that is N - number of lines moved; if backward, N + number moved.•With positive N, a non-empty line at the end counts as one line•successfully moved (for the return value).",
"forward-list":"forward-list is an interactive compiled Lisp function in `lisp.el'.••(forward-list &amp;optional ARG)••Move forward across one balanced group of parentheses.•With ARG, do it that many times.•Negative arg -N means move backward across N groups of parentheses.•This command assumes point is not in a string or comment.",
"forward-page":"forward-page is an interactive compiled Lisp function in `page.el'.••(forward-page &amp;optional COUNT)••Move forward to page boundary.  With arg, repeat, or go back if negative.•A page boundary is any line whose beginning matches the regexp•`page-delimiter'.",
"forward-paragraph":"forward-paragraph is an interactive compiled Lisp function in•`paragraphs.el'.••(forward-paragraph &amp;optional ARG)••Move forward to end of paragraph.•With argument ARG, do it ARG times;•a negative argument ARG = -N means move backward N paragraphs.••A line which `paragraph-start' matches either separates paragraphs•(if `paragraph-separate' matches it also) or is the first line of a paragraph.•A paragraph end is the beginning of a line which is not part of the paragraph•to which the end of the previous line belongs, or the end of the buffer.•Returns the count of paragraphs left to move.",
"forward-sentence":"forward-sentence is an interactive compiled Lisp function in•`paragraphs.el'.••(forward-sentence &amp;optional ARG)••Move forward to next end of sentence.  With argument, repeat.•With negative argument, move backward repeatedly to start of sentence.••The variable `sentence-end' is a regular expression that matches ends of•sentences.  Also, every paragraph boundary terminates sentences as well.",
"forward-sexp":"forward-sexp is an interactive compiled Lisp function in `lisp.el'.••(forward-sexp &amp;optional ARG)••Move forward across one balanced expression (sexp).•With ARG, do it that many times.  Negative arg -N means•move backward across N balanced expressions.•This command assumes point is not in a string or comment.",
"forward-word":"forward-word is an interactive built-in function in `C source code'.••(forward-word &amp;optional ARG)••Move point forward ARG words (backward if ARG is negative).•Normally returns t.•If an edge of the buffer or a field boundary is reached, point is left there•and the function returns nil.  Field boundaries are not noticed if•`inhibit-field-text-motion' is non-nil.••This subr is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `forward-word'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-forward-word-keymap'.",
"funcall":"funcall is a built-in function in `C source code'.••(funcall FUNCTION &amp;rest ARGUMENTS)••Call first argument as a function, passing remaining arguments to it.•Return the value that function returns.•Thus, (funcall 'cons 'x 'y) returns (x . y).",
"fundamental-mode":"fundamental-mode is an interactive compiled Lisp function in•`simple.el'.••(fundamental-mode)••Major mode not specialized for anything in particular.•Other major modes are defined by comparison with this one.",
"get":"get is a built-in function in `C source code'.••(get SYMBOL PROPNAME)••Return the value of SYMBOL's PROPNAME property.•This is the last value stored with `(put SYMBOL PROPNAME VALUE)'.",
"get-file-buffer":"get-file-buffer is a built-in function in `C source code'.••(get-file-buffer FILENAME)••Return the buffer visiting file FILENAME (a string).•The buffer's `buffer-file-name' must match exactly the expansion of FILENAME.•If there is no such live buffer, return nil.•See also `find-buffer-visiting'.",
"gethash":"gethash is a built-in function in `C source code'.••(gethash KEY TABLE &amp;optional DFLT)••Look up KEY in TABLE and return its associated value.•If KEY is not found, return DFLT which defaults to nil.",
"get-selection-or-unit":"get-selection-or-unit is an interactive Lisp function in•`xeu_elisp_util.el'.••(get-selection-or-unit UNIT)••Return the string and boundary of text selection or UNIT under cursor.••If `region-active-p' is true, then the region is the unit.  Else,•it depends on the UNIT. See `unit-at-cursor' for detail about•UNIT.••Returns a vector [text a b], where text is the string and a and b•are its boundary.••Example usage:• (setq bds (get-selection-or-unit 'line))• (setq inputstr (elt bds 0) p1 (elt bds 1) p2 (elt bds 2)  )",
"global-hl-line-mode":"global-hl-line-mode is an interactive autoloaded Lisp function in•`hl-line.el'.••(global-hl-line-mode &amp;optional ARG)••Toggle line highlighting in all buffers (Global Hl-Line mode).•With a prefix argument ARG, enable Global Hl-Line mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••If `global-hl-line-sticky-flag' is non-nil, Global Hl-Line mode•highlights the line about the current buffer's point in all•windows.••Global-Hl-Line mode uses the functions `global-hl-line-unhighlight' and•`global-hl-line-highlight' on `pre-command-hook' and `post-command-hook'.",
"global-linum-mode":"global-linum-mode is an interactive autoloaded compiled Lisp function•in `linum.el'.••(global-linum-mode &amp;optional ARG)••Toggle Linum mode in all buffers.•With prefix ARG, enable Global-Linum mode if ARG is positive;•otherwise, disable it.  If called from Lisp, enable the mode if•ARG is omitted or nil.••Linum mode is enabled in all buffers where•`linum-on' would do it.•See `linum-mode' for more information on Linum mode.",
"global-set-key":"global-set-key is an interactive compiled Lisp function in `subr.el'.••(global-set-key KEY COMMAND)••Give KEY a global binding as COMMAND.•COMMAND is the command definition to use; usually it is•a symbol naming an interactively-callable function.•KEY is a key sequence; noninteractively, it is a string or vector•of characters or event types, and non-ASCII characters with codes•above 127 (such as ISO Latin-1) can be included if you use a vector.••Note that if KEY has a local binding in the current buffer,•that local binding will continue to shadow any global binding•that you make with this function.••This function is advised.••Around-advice `ergoemacs-global-set-key-advice':•This let you use global-set-key as usual when ergoemacs-mode is enabled.",
"global-subword-mode":"global-subword-mode is an interactive autoloaded compiled Lisp•function in `subword.el'.••(global-subword-mode &amp;optional ARG)••Toggle Subword mode in all buffers.•With prefix ARG, enable Global-Subword mode if ARG is positive;•otherwise, disable it.  If called from Lisp, enable the mode if•ARG is omitted or nil.••Subword mode is enabled in all buffers where•`(lambda nil (subword-mode 1))' would do it.•See `subword-mode' for more information on Subword mode.",
"global-unset-key":"global-unset-key is an interactive compiled Lisp function in•`subr.el'.••(global-unset-key KEY)••Remove global binding of KEY.•KEY is a string or vector representing a sequence of keystrokes.••This function is advised.••Around-advice `ergoemacs-global-unset-key-advice':•This let you use global-unset-key as usual when ergoemacs-mode is enabled.",
"global-visual-line-mode":"global-visual-line-mode is an interactive compiled Lisp function in•`simple.el'.••(global-visual-line-mode &amp;optional ARG)••Toggle Visual-Line mode in all buffers.•With prefix ARG, enable Global-Visual-Line mode if ARG is positive;•otherwise, disable it.  If called from Lisp, enable the mode if•ARG is omitted or nil.••Visual-Line mode is enabled in all buffers where•`turn-on-visual-line-mode' would do it.•See `visual-line-mode' for more information on Visual-Line mode.",
"global-whitespace-mode":"global-whitespace-mode is an interactive autoloaded compiled Lisp•function in `whitespace.el'.••(global-whitespace-mode &amp;optional ARG)••Toggle whitespace visualization globally (Global Whitespace mode).•With a prefix argument ARG, enable Global Whitespace mode if ARG•is positive, and disable it otherwise.  If called from Lisp,•enable it if ARG is omitted or nil.••See also `whitespace-style', `whitespace-newline' and•`whitespace-display-mappings'.",
"global-whitespace-newline-mode":"global-whitespace-newline-mode is an interactive autoloaded compiled•Lisp function in `whitespace.el'.••(global-whitespace-newline-mode &amp;optional ARG)••Toggle global newline visualization (Global Whitespace Newline mode).•With a prefix argument ARG, enable Global Whitespace Newline mode•if ARG is positive, and disable it otherwise.  If called from•Lisp, enable it if ARG is omitted or nil.••Use `global-whitespace-newline-mode' only for NEWLINE•visualization exclusively.  For other visualizations, including•NEWLINE visualization together with (HARD) SPACEs and/or TABs,•please use `global-whitespace-mode'.••See also `whitespace-newline' and `whitespace-display-mappings'.",
"gnus-url-unhex-string":"gnus-url-unhex-string is a compiled Lisp function in `gnus-util.el'.••(gnus-url-unhex-string STR &amp;optional ALLOW-NEWLINES)••Remove %XX, embedded spaces, etc in a url.•If optional second argument ALLOW-NEWLINES is non-nil, then allow the•decoding of carriage returns and line feeds in the string, which is normally•forbidden in URL encoding.",
"goto-char":"goto-char is an interactive built-in function in `C source code'.••(goto-char POSITION)••Set point to POSITION, a number or marker.•Beginning of buffer is position (point-min), end is (point-max).••The return value is POSITION.",
"goto-line":"goto-line is an interactive compiled Lisp function in `simple.el'.••(goto-line LINE &amp;optional BUFFER)••Go to LINE, counting from line 1 at beginning of buffer.•If called interactively, a numeric prefix argument specifies•LINE; without a numeric prefix argument, read LINE from the•minibuffer.••If optional argument BUFFER is non-nil, switch to that buffer and•move to line LINE there.  If called interactively with C-u•as argument, BUFFER is the most recently selected other buffer.••Prior to moving point, this function sets the mark (without•activating it), unless Transient Mark mode is enabled and the•mark is already active.••This function is usually the wrong thing to use in a Lisp program.•What you probably want instead is something like:•  (goto-char (point-min))•  (forward-line (1- N))•If at all possible, an even better solution is to use char counts•rather than line counts.",
"grep":"grep is an interactive autoloaded compiled Lisp function in `grep.el'.••(grep COMMAND-ARGS)••Run grep, with user-specified args, and collect output in a buffer.•While grep runs asynchronously, you can use C-x ` (M-x next-error),•or RET in the *grep* buffer, to go to the lines where grep found•matches.  To kill the grep job before it finishes, type C-c C-k.••For doing a recursive `grep', see the `rgrep' command.  For running•`grep' in a specific directory, see `lgrep'.••This command uses a special history list for its COMMAND-ARGS, so you•can easily repeat a grep command.••A prefix argument says to default the argument based upon the current•tag the cursor is over, substituting it into the last grep command•in the grep command history (or into `grep-command' if that history•list is empty).",
"grep-find":"grep-find is an interactive autoloaded compiled Lisp function in•`grep.el'.••(grep-find COMMAND-ARGS)••Run grep via find, with user-specified args COMMAND-ARGS.•Collect output in a buffer.•While find runs asynchronously, you can use the C-x ` command•to find the text that grep hits refer to.••This command uses a special history list for its arguments, so you can•easily repeat a find command.",
"hash-table-count":"hash-table-count is a built-in function in `C source code'.••(hash-table-count TABLE)••Return the number of elements in TABLE.",
"hexl-find-file":"hexl-find-file is an interactive autoloaded compiled Lisp function in•`hexl.el'.••(hexl-find-file FILENAME)••Edit file FILENAME as a binary file in hex dump format.•Switch to a buffer visiting file FILENAME, creating one if none exists,•and edit the file in `hexl-mode'.",
"hexl-mode":"hexl-mode is an interactive autoloaded compiled Lisp function in•`hexl.el'.••(hexl-mode &amp;optional ARG)••A mode for editing binary files in hex dump format.•This is not an ordinary major mode; it alters some aspects•of the current mode's behavior, but not all; also, you can exit•Hexl mode and return to the previous mode using `hexl-mode-exit'.••This function automatically converts a buffer into the hexl format•using the function `hexlify-buffer'.••Each line in the buffer has an ⧷&quoteaddress⧷&quote (displayed in hexadecimal)•representing the offset into the file that the characters on this line•are at and 16 characters from the file (displayed as hexadecimal•values grouped every `hexl-bits' bits) and as their ASCII values.••If any of the characters (displayed as ASCII characters) are•unprintable (control or meta characters) they will be replaced as•periods.••If `hexl-mode' is invoked with an argument the buffer is assumed to be•in hexl format.••A sample format:••  HEX ADDR: 0001 0203 0405 0607 0809 0a0b 0c0d 0e0f     ASCII-TEXT•  --------  ---- ---- ---- ---- ---- ---- ---- ----  ----------------•  00000000: 5468 6973 2069 7320 6865 786c 2d6d 6f64  This is hexl-mod•  00000010: 652e 2020 4561 6368 206c 696e 6520 7265  e.  Each line re•  00000020: 7072 6573 656e 7473 2031 3620 6279 7465  presents 16 byte•  00000030: 7320 6173 2068 6578 6164 6563 696d 616c  s as hexadecimal•  00000040: 2041 5343 4949 0a61 6e64 2070 7269 6e74   ASCII.and print•  00000050: 6162 6c65 2041 5343 4949 2063 6861 7261  able ASCII chara•  00000060: 6374 6572 732e 2020 416e 7920 636f 6e74  cters.  Any cont•  00000070: 726f 6c20 6f72 206e 6f6e 2d41 5343 4949  rol or non-ASCII•  00000080: 2063 6861 7261 6374 6572 730a 6172 6520   characters.are•  00000090: 6469 7370 6c61 7965 6420 6173 2070 6572  displayed as per•  000000a0: 696f 6473 2069 6e20 7468 6520 7072 696e  iods in the prin•  000000b0: 7461 626c 6520 6368 6172 6163 7465 7220  table character•  000000c0: 7265 6769 6f6e 2e0a                      region..••Movement is as simple as movement in a normal Emacs text buffer.  Most•cursor movement bindings are the same: use C-b, C-f, C-n, and C-p•to move the cursor left, right, down, and up.••Advanced cursor movement commands (ala C-a, C-e, M-&lt;, and M-&gt;) are•also supported.••There are several ways to change text in hexl mode:••ASCII characters (character between space (0x20) and tilde (0x7E)) are•bound to self-insert so you can simply type the character and it will•insert itself (actually overstrike) into the buffer.••C-q followed by another keystroke allows you to insert the key even if•it isn't bound to self-insert.  An octal number can be supplied in place•of another key to insert the octal number's ASCII representation.••C-M-x will insert a given hexadecimal value (if it is between 0 and 0xFF)•into the buffer at the current point.••C-M-o will insert a given octal value (if it is between 0 and 0377)•into the buffer at the current point.••C-M-d will insert a given decimal value (if it is between 0 and 255)•into the buffer at the current point.••C-c C-c will exit hexl-mode.••Note: saving the file with any of the usual Emacs commands•will actually convert it back to binary format while saving.••You can use M-x hexl-find-file to visit a file in Hexl mode.••&lt;f1&gt; b for advanced commands.",
"hide-body":"hide-body is an interactive compiled Lisp function in `outline.el'.••(hide-body)••Hide all body lines in buffer, leaving all headings visible.",
"highlight-lines-matching-regexp":"highlight-lines-matching-regexp is an alias for•`hi-lock-line-face-buffer' in `hi-lock.el'.••(highlight-lines-matching-regexp REGEXP &amp;optional FACE)••Set face of all lines containing a match of REGEXP to FACE.•Interactively, prompt for REGEXP then FACE, using a buffer-local•history list for REGEXP and a global history list for FACE.••If Font Lock mode is enabled in the buffer, it is used to•highlight REGEXP.  If Font Lock mode is disabled, overlays are•used for highlighting; in this case, the highlighting will not be•updated as you type.",
"highlight-phrase":"highlight-phrase is an alias for `hi-lock-face-phrase-buffer' in•`hi-lock.el'.••(highlight-phrase REGEXP &amp;optional FACE)••Set face of each match of phrase REGEXP to FACE.•If called interactively, replaces whitespace in REGEXP with•arbitrary whitespace and makes initial lower-case letters case-insensitive.••If Font Lock mode is enabled in the buffer, it is used to•highlight REGEXP.  If Font Lock mode is disabled, overlays are•used for highlighting; in this case, the highlighting will not be•updated as you type.",
"highlight-regexp":"highlight-regexp is an alias for `hi-lock-face-buffer' in•`hi-lock.el'.••(highlight-regexp REGEXP &amp;optional FACE)••Set face of each match of REGEXP to FACE.•Interactively, prompt for REGEXP then FACE, using a buffer-local•history list for REGEXP and a global history list for FACE.••If Font Lock mode is enabled in the buffer, it is used to•highlight REGEXP.  If Font Lock mode is disabled, overlays are•used for highlighting; in this case, the highlighting will not be•updated as you type.",
"hippie-expand":"hippie-expand is an interactive autoloaded compiled Lisp function in•`hippie-exp.el'.••(hippie-expand ARG)••Try to expand text before point, using multiple methods.•The expansion functions in `hippie-expand-try-functions-list' are•tried in order, until a possible expansion is found.  Repeated•application of `hippie-expand' inserts successively possible•expansions.•With a positive numeric argument, jumps directly to the ARG next•function in this list.  With a negative argument or just C-u,•undoes the expansion.",
"hl-line-mode":"hl-line-mode is an interactive autoloaded Lisp function in•`hl-line.el'.••(hl-line-mode &amp;optional ARG)••Toggle highlighting of the current line (Hl-Line mode).•With a prefix argument ARG, enable Hl-Line mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••Hl-Line mode is a buffer-local minor mode.  If•`hl-line-sticky-flag' is non-nil, Hl-Line mode highlights the•line about the buffer's point in all windows.  Caveat: the•buffer's point might be different from the point of a•non-selected window.  Hl-Line mode uses the function•`hl-line-highlight' on `post-command-hook' in this case.••When `hl-line-sticky-flag' is nil, Hl-Line mode highlights the•line about point in the selected window only.  In this case, it•uses the function `hl-line-unhighlight' on `pre-command-hook' in•addition to `hl-line-highlight' on `post-command-hook'.",
"holidays":"holidays is an interactive autoloaded Lisp function in `holidays.el'.••(holidays &amp;optional ARG)••Display the holidays for last month, this month, and next month.•If called with an optional prefix argument ARG, prompts for month and year.•This function is suitable for execution in a init file.",
"htmlfontify-buffer":"htmlfontify-buffer is an interactive autoloaded Lisp function in•`htmlfontify.el'.••(htmlfontify-buffer &amp;optional SRCDIR FILE)••Create a new buffer, named for the current buffer + a .html extension,•containing an inline CSS-stylesheet and formatted CSS-markup HTML•that reproduces the look of the current Emacs buffer as closely•as possible.••Dangerous characters in the existing buffer are turned into HTML•entities, so you should even be able to do HTML-within-HTML•fontified display.••You should, however, note that random control or eight-bit•characters such as ^L () or ¤ (244) won't get mapped yet.••If the SRCDIR and FILE arguments are set, lookup etags derived•entries in the `hfy-tags-cache' and add HTML anchors and•hyperlinks as appropriate.",
"html-headline-1":"html-headline-1 is an interactive compiled Lisp function in•`sgml-mode.el'.••(html-headline-1 &amp;optional STR ARG)••HTML level 1 headline tags.••This is a skeleton command (see `skeleton-insert').•Normally the skeleton text is inserted at point, with nothing ⧷&quoteinside⧷&quote.•If there is a highlighted region, the skeleton text is wrapped•around the region text.••A prefix argument ARG says to wrap the skeleton around the next ARG words.•A prefix argument of -1 says to wrap around region, even if not highlighted.•A prefix argument of zero says to wrap around zero words---that is, nothing.•This is a way of overriding the use of a highlighted region.",
"html-headline-2":"html-headline-2 is an interactive compiled Lisp function in•`sgml-mode.el'.••(html-headline-2 &amp;optional STR ARG)••HTML level 2 headline tags.••This is a skeleton command (see `skeleton-insert').•Normally the skeleton text is inserted at point, with nothing ⧷&quoteinside⧷&quote.•If there is a highlighted region, the skeleton text is wrapped•around the region text.••A prefix argument ARG says to wrap the skeleton around the next ARG words.•A prefix argument of -1 says to wrap around region, even if not highlighted.•A prefix argument of zero says to wrap around zero words---that is, nothing.•This is a way of overriding the use of a highlighted region.",
"html-horizontal-rule":"html-horizontal-rule is an interactive compiled Lisp function in•`sgml-mode.el'.••(html-horizontal-rule &amp;optional STR ARG)••HTML horizontal rule tag.••This is a skeleton command (see `skeleton-insert').•Normally the skeleton text is inserted at point, with nothing ⧷&quoteinside⧷&quote.•If there is a highlighted region, the skeleton text is wrapped•around the region text.••A prefix argument ARG says to wrap the skeleton around the next ARG words.•A prefix argument of -1 says to wrap around region, even if not highlighted.•A prefix argument of zero says to wrap around zero words---that is, nothing.•This is a way of overriding the use of a highlighted region.",
"html-image":"html-image is an interactive compiled Lisp function in `sgml-mode.el'.••(html-image &amp;optional STR ARG)••HTML image tag.••This is a skeleton command (see `skeleton-insert').•Normally the skeleton text is inserted at point, with nothing ⧷&quoteinside⧷&quote.•If there is a highlighted region, the skeleton text is wrapped•around the region text.••A prefix argument ARG says to wrap the skeleton around the next ARG words.•A prefix argument of -1 says to wrap around region, even if not highlighted.•A prefix argument of zero says to wrap around zero words---that is, nothing.•This is a way of overriding the use of a highlighted region.",
"htmlize-buffer":"htmlize-buffer is an interactive Lisp function in `htmlize.el'.••(htmlize-buffer &amp;optional BUFFER)••Convert BUFFER to HTML, preserving colors and decorations.••The generated HTML is available in a new buffer, which is returned.•When invoked interactively, the new buffer is selected in the current•window.  The title of the generated document will be set to the buffer's•file name or, if that's not available, to the buffer's name.••Note that htmlize doesn't fontify your buffers, it only uses the•decorations that are already present.  If you don't set up font-lock or•something else to fontify your buffers, the resulting HTML will be•plain.  Likewise, if you don't like the choice of colors, fix the mode•that created them, or simply alter the faces it uses.",
"htmlize-file":"htmlize-file is an interactive Lisp function in `htmlize.el'.••(htmlize-file FILE &amp;optional TARGET)••Load FILE, fontify it, convert it to HTML, and save the result.••Contents of FILE are inserted into a temporary buffer, whose major mode•is set with `normal-mode' as appropriate for the file type.  The buffer•is subsequently fontified with `font-lock' and converted to HTML.  Note•that, unlike `htmlize-buffer', this function explicitly turns on•font-lock.  If a form of highlighting other than font-lock is desired,•please use `htmlize-buffer' directly on buffers so highlighted.••Buffers currently visiting FILE are unaffected by this function.  The•function does not change current buffer or move the point.••If TARGET is specified and names a directory, the resulting file will be•saved there instead of to FILE's directory.  If TARGET is specified and•does not name a directory, it will be used as output file name.",
"htmlize-region":"htmlize-region is an interactive Lisp function in `htmlize.el'.••(htmlize-region BEG END)••Convert the region to HTML, preserving colors and decorations.•See `htmlize-buffer' for details.",
"html-list-item":"html-list-item is an interactive compiled Lisp function in•`sgml-mode.el'.••(html-list-item &amp;optional STR ARG)••HTML list item tag.••This is a skeleton command (see `skeleton-insert').•Normally the skeleton text is inserted at point, with nothing ⧷&quoteinside⧷&quote.•If there is a highlighted region, the skeleton text is wrapped•around the region text.••A prefix argument ARG says to wrap the skeleton around the next ARG words.•A prefix argument of -1 says to wrap around region, even if not highlighted.•A prefix argument of zero says to wrap around zero words---that is, nothing.•This is a way of overriding the use of a highlighted region.",
"html-mode":"html-mode is an interactive autoloaded compiled Lisp function in•`sgml-mode.el'.••(html-mode)••Parent mode: `sgml-mode'.••Major mode based on SGML mode for editing HTML documents.•This allows inserting skeleton constructs used in hypertext documents with•completion.  See below for an introduction to HTML.  Use•M-x browse-url-of-buffer to see how this comes out.  See also `sgml-mode' on•which this is based.••Do C-h 2 html- SPC and C-h 2 sgml- SPC to see available variables.••To write fairly well formatted pages you only need to know few things.  Most•browsers have a function to read the source code of the page being seen, so•you can imitate various tricks.  Here's a very short HTML primer which you•can also view with a browser to see what happens:••&lt;title&gt;A Title Describing Contents&lt;/title&gt; should be on every page.  Pages can•have &lt;h1&gt;Very Major Headlines&lt;/h1&gt; through &lt;h6&gt;Very Minor Headlines&lt;/h6&gt;•&lt;hr&gt; Parts can be separated with horizontal rules.••&lt;p&gt;Paragraphs only need an opening tag.  Line breaks and multiple spaces are•ignored unless the text is &lt;pre&gt;preformatted.&lt;/pre&gt;  Text can be marked as•&lt;b&gt;bold&lt;/b&gt;, &lt;i&gt;italic&lt;/i&gt; or &lt;u&gt;underlined&lt;/u&gt; using the normal M-o or•Edit/Text Properties/Face commands.••Pages can have &lt;a name=⧷&quoteSOMENAME⧷&quote&gt;named points&lt;/a&gt; and can link other points•to them with &lt;a href=⧷&quote#SOMENAME⧷&quote&gt;see also somename&lt;/a&gt;.  In the same way &lt;a•href=⧷&quoteURL⧷&quote&gt;see also URL&lt;/a&gt; where URL is a filename relative to current•directory, or absolute as in `http://www.cs.indiana.edu/elisp/w3/docs.html'.••Images in many formats can be inlined with &lt;img src=⧷&quoteURL⧷&quote&gt;.••If you mainly create your own documents, `sgml-specials' might be•interesting.  But note that some HTML 2 browsers can't handle `&amp;apos;'.•To work around that, do:•   (eval-after-load ⧷&quotesgml-mode⧷&quote '(aset sgml-char-names ?' nil))••key             binding•---             -------•• .. ÿ       sgml-maybe-name-self••C-c             Prefix Command•ESC             Prefix Command•/               sgml-slash••C-c C-c         Prefix Command•C-c C-j         html-line•C-c RET         html-paragraph•C-c C-s         html-autoview-mode•C-c C-v         browse-url-of-buffer•C-c 1           html-headline-1•C-c 2           html-headline-2•C-c 3           html-headline-3•C-c 4           html-headline-4•C-c 5           html-headline-5•C-c 6           html-headline-6••C-c C-a         sgml-attributes•C-c C-b         sgml-skip-tag-backward•C-c C-d         sgml-delete-tag•C-c C-e         sgml-close-tag•C-c C-f         sgml-skip-tag-forward•C-c TAB         sgml-tags-invisible•C-c C-n         sgml-name-char•C-c C-o         sgml-tag•C-c C-t         sgml-tag•C-c C-v         sgml-validate•  (that binding is currently shadowed by another mode)•C-c /           sgml-close-tag•C-c 8           sgml-name-8bit-mode•C-c ?           sgml-tag-help•C-c ]           sgml-close-tag•C-c DEL         sgml-delete-tag•C-c &lt;left&gt;      sgml-skip-tag-backward•C-c &lt;right&gt;     sgml-skip-tag-forward••C-M-i           ispell-complete-word••C-c C-c -       html-horizontal-rule•C-c C-c c       html-checkboxes•C-c C-c h       html-href-anchor•C-c C-c i       html-image•C-c C-c l       html-list-item•C-c C-c n       html-name-anchor•C-c C-c o       html-ordered-list•C-c C-c r       html-radio-buttons•C-c C-c u       html-unordered-list••••In addition to any hooks its parent mode might have run,•this mode runs the hook `html-mode-hook', as the final step•during initialization.",
"html-paragraph":"html-paragraph is an interactive compiled Lisp function in•`sgml-mode.el'.••(html-paragraph &amp;optional STR ARG)••HTML paragraph tag.••This is a skeleton command (see `skeleton-insert').•Normally the skeleton text is inserted at point, with nothing ⧷&quoteinside⧷&quote.•If there is a highlighted region, the skeleton text is wrapped•around the region text.••A prefix argument ARG says to wrap the skeleton around the next ARG words.•A prefix argument of -1 says to wrap around region, even if not highlighted.•A prefix argument of zero says to wrap around zero words---that is, nothing.•This is a way of overriding the use of a highlighted region.",
"html-unordered-list":"html-unordered-list is an interactive compiled Lisp function in•`sgml-mode.el'.••(html-unordered-list &amp;optional STR ARG)••HTML unordered list tags.••This is a skeleton command (see `skeleton-insert').•Normally the skeleton text is inserted at point, with nothing ⧷&quoteinside⧷&quote.•If there is a highlighted region, the skeleton text is wrapped•around the region text.••A prefix argument ARG says to wrap the skeleton around the next ARG words.•A prefix argument of -1 says to wrap around region, even if not highlighted.•A prefix argument of zero says to wrap around zero words---that is, nothing.•This is a way of overriding the use of a highlighted region.",
"ibuffer":"ibuffer is an interactive autoloaded compiled Lisp function in•`ibuffer.el'.••(ibuffer &amp;optional OTHER-WINDOW-P NAME QUALIFIERS NOSELECT SHRINK•FILTER-GROUPS FORMATS)••Begin using Ibuffer to edit a list of buffers.•Type 'h' after entering ibuffer for more information.••All arguments are optional.•OTHER-WINDOW-P says to use another window.•NAME specifies the name of the buffer (defaults to ⧷&quote*Ibuffer*⧷&quote).•QUALIFIERS is an initial set of filtering qualifiers to use;•  see `ibuffer-filtering-qualifiers'.•NOSELECT means don't select the Ibuffer buffer.•SHRINK means shrink the buffer to minimal size.  The special•  value `onewindow' means always use another window.•FILTER-GROUPS is an initial set of filtering groups to use;•  see `ibuffer-filter-groups'.•FORMATS is the value to use for `ibuffer-formats'.•  If specified, then the variable `ibuffer-formats' will have•  that value locally in this buffer.",
"icomplete-mode":"icomplete-mode is an interactive autoloaded compiled Lisp function in•`icomplete.el'.••(icomplete-mode &amp;optional ARG)••Toggle incremental minibuffer completion (Icomplete mode).•With a prefix argument ARG, enable Icomplete mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.",
"iconify-or-deiconify-frame":"iconify-or-deiconify-frame is an interactive compiled Lisp function in•`frame.el'.••(iconify-or-deiconify-frame)••Iconify the selected frame, or deiconify if it's currently an icon.",
"ido-find-file":"ido-find-file is an interactive autoloaded compiled Lisp function in•`ido.el'.••(ido-find-file)••Edit file with name obtained via minibuffer.•The file is displayed according to `ido-default-file-method' -- the•default is to show it in the same window, unless it is already•visible in another frame.••The file name is selected interactively by typing a substring.  As you•type in a string, all of the filenames matching the string are displayed•if substring-matching is used (default).  Look at `ido-enable-prefix' and•`ido-toggle-prefix'.  When you have found the filename you want, it can•then be selected.  As you type, most keys have their normal keybindings,•except for the following: ••RET Select the file at the front of the list of matches.  If the•list is empty, possibly prompt to create new file.••C-j Use the current input string verbatim.••C-s Put the first element at the end of the list.•C-r Put the last element at the start of the list.•TAB Complete a common suffix to the current string that•matches all files.  If there is only one match, select that file.•If there is no common suffix, show a list of all matching files•in a separate window.•C-d Open the specified directory in Dired mode.•C-e Edit input string (including directory).•M-p or M-n go to previous/next directory in work directory history.•M-s search for file in the work directory history.•M-k removes current directory from the work directory history.•M-o or C-M-o cycle through the work file history.•M-f and M-d prompts and uses find to locate files or directories.•M-m prompts for a directory to create in current directory.•C-x C-f Fallback to non-ido version of current command.•C-t Toggle regexp searching.•C-p Toggle between substring and prefix matching.•C-c Toggle case-sensitive searching of file names.•M-l Toggle literal reading of this file.•? Show list of matching files in separate window.•C-a Toggle ignoring files listed in `ido-ignore-files'.",
"ido-mode":"ido-mode is an interactive autoloaded compiled Lisp function in•`ido.el'.••(ido-mode &amp;optional ARG)••Toggle ido mode on or off.•With ARG, turn ido-mode on if arg is positive, off otherwise.•Turning on ido-mode will remap (via a minor-mode keymap) the default•keybindings for the `find-file' and `switch-to-buffer' families of•commands to the ido versions of these functions.•However, if ARG arg equals 'files, remap only commands for files, or•if it equals 'buffers, remap only commands for buffer switching.•This function also adds a hook to the minibuffer.",
"ido-switch-buffer":"ido-switch-buffer is an interactive autoloaded compiled Lisp function•in `ido.el'.••(ido-switch-buffer)••Switch to another buffer.•The buffer is displayed according to `ido-default-buffer-method' -- the•default is to show it in the same window, unless it is already visible•in another frame.••As you type in a string, all of the buffers matching the string are•displayed if substring-matching is used (default).  Look at•`ido-enable-prefix' and `ido-toggle-prefix'.  When you have found the•buffer you want, it can then be selected.  As you type, most keys have•their normal keybindings, except for the following: ••RET Select the buffer at the front of the list of matches.  If the•list is empty, possibly prompt to create new buffer.••C-j Use the current input string verbatim.••C-s Put the first element at the end of the list.•C-r Put the last element at the start of the list.•TAB Complete a common suffix to the current string that•matches all buffers.  If there is only one match, select that buffer.•If there is no common suffix, show a list of all matching buffers•in a separate window.•C-e Edit input string.•C-x C-b Fallback to non-ido version of current command.•C-t Toggle regexp searching.•C-p Toggle between substring and prefix matching.•C-c Toggle case-sensitive searching of buffer names.•? Show list of matching buffers in separate window.•C-x C-f Drop into `ido-find-file'.•C-k Kill buffer at head of buffer list.•C-a Toggle ignoring buffers listed in `ido-ignore-buffers'.",
"ielm":"ielm is an interactive autoloaded Lisp function in `ielm.el'.••(ielm)••Interactively evaluate Emacs Lisp expressions.•Switches to the buffer `*ielm*', or creates it if it does not exist.",
"if":"if is a special form in `C source code'.••(if COND THEN ELSE...)••If COND yields non-nil, do THEN, else do ELSE...•Returns the value of THEN or the value of the last of the ELSE's.•THEN must be one expression, but ELSE... can be zero or more expressions.•If COND yields nil, and there are no ELSE's, the value is nil.",
"image-dired-delete-tag":"image-dired-delete-tag is an interactive autoloaded Lisp function in•`image-dired.el'.••(image-dired-delete-tag ARG)••Remove tag for selected file(s).•With prefix argument ARG, remove tag from file at point.",
"indent-for-tab-command":"indent-for-tab-command is an interactive compiled Lisp function in•`indent.el'.••(indent-for-tab-command &amp;optional ARG)••Indent the current line or region, or insert a tab, as appropriate.•This function either inserts a tab, or indents the current line,•or performs symbol completion, depending on `tab-always-indent'.•The function called to actually indent the line or insert a tab•is given by the variable `indent-line-function'.••If a prefix argument is given, after this function indents the•current line or inserts a tab, it also rigidly indents the entire•balanced expression which starts at the beginning of the current•line, to reflect the current line's indentation.••In most major modes, if point was in the current line's•indentation, it is moved to the first non-whitespace character•after indenting; otherwise it stays at the same position relative•to the text.••If `transient-mark-mode' is turned on and the region is active,•this function instead calls `indent-region'.  In this case, any•prefix argument is ignored.",
"indent-new-comment-line":"indent-new-comment-line is an alias for `comment-indent-new-line' in•`newcomment.el'.••(indent-new-comment-line &amp;optional SOFT)••Break line at point and indent, continuing comment if within one.•This indents the body of the continued comment•under the previous comment line.••This command is intended for styles where you write a comment per line,•starting a new comment (and terminating it if necessary) on each line.•If you want to continue one comment across several lines, use M-x newline-and-indent.••If a fill column is specified, it overrides the use of the comment column•or comment indentation.••The inserted newline is marked hard if variable `use-hard-newlines' is true,•unless optional argument SOFT is non-nil.",
"indent-region":"indent-region is an interactive compiled Lisp function in `indent.el'.••(indent-region START END &amp;optional COLUMN)••Indent each nonblank line in the region.•A numeric prefix argument specifies a column: indent each line to that column.••With no prefix argument, the command chooses one of these methods and•indents all the lines with it:••  1) If `fill-prefix' is non-nil, insert `fill-prefix' at the•     beginning of each line in the region that does not already begin•     with it.•  2) If `indent-region-function' is non-nil, call that function•     to indent the region.•  3) Indent each line via `indent-according-to-mode'.••Called from a program, START and END specify the region to indent.•If the third argument COLUMN is an integer, it specifies the•column to indent to; if it is nil, use one of the three methods above.",
"info":"info is an interactive autoloaded compiled Lisp function in `info.el'.••(info &amp;optional FILE-OR-NODE BUFFER)••Enter Info, the documentation browser.•Optional argument FILE-OR-NODE specifies the file to examine;•the default is the top-level directory of Info.•Called from a program, FILE-OR-NODE may specify an Info node of the form•⧷&quote(FILENAME)NODENAME⧷&quote.•Optional argument BUFFER specifies the Info buffer name;•the default buffer name is *info*.  If BUFFER exists,•just switch to BUFFER.  Otherwise, create a new buffer•with the top-level Info directory.••In interactive use, a non-numeric prefix argument directs•this command to read a file name from the minibuffer.•A numeric prefix argument selects an Info buffer with the prefix number•appended to the Info buffer name.••The search path for Info files is in the variable `Info-directory-list'.•The top-level Info directory is made by combining all the files named `dir'•in all the directories in that path.••See a list of available Info commands in `Info-mode'.",
"info-apropos":"info-apropos is an interactive autoloaded compiled Lisp function in•`info.el'.••(info-apropos STRING)••Grovel indices of all known Info files on your system for STRING.•Build a menu of the possible matches.",
"Info-copy-current-node-name":"Info-copy-current-node-name is an interactive compiled Lisp function•in `info.el'.••(Info-copy-current-node-name &amp;optional ARG)••Put the name of the current Info node into the kill ring.•The name of the Info file is prepended to the node name in parentheses.•With a zero prefix arg, put the name inside a function call to `info'.",
"insert":"insert is a built-in function in `C source code'.••(insert &amp;rest ARGS)••Insert the arguments, either strings or characters, at point.•Point and before-insertion markers move forward to end up• after the inserted text.•Any other markers at the point of insertion remain before the text.••If the current buffer is multibyte, unibyte strings are converted•to multibyte for insertion (see `string-make-multibyte').•If the current buffer is unibyte, multibyte strings are converted•to unibyte for insertion (see `string-make-unibyte').••When operating on binary data, it may be necessary to preserve the•original bytes of a unibyte string when inserting it into a multibyte•buffer; to accomplish this, apply `string-as-multibyte' to the string•and insert the result.",
"insert-buffer-substring-no-properties":"insert-buffer-substring-no-properties is a compiled Lisp function in•`subr.el'.••(insert-buffer-substring-no-properties BUFFER &amp;optional START END)••Insert before point a substring of BUFFER, without text properties.•BUFFER may be a buffer or a buffer name.•Arguments START and END are character positions specifying the substring.•They default to the values of (point-min) and (point-max) in BUFFER.",
"insert-file-contents":"insert-file-contents is a built-in function in `C source code'.••(insert-file-contents FILENAME &amp;optional VISIT BEG END REPLACE)••Insert contents of file FILENAME after point.•Returns list of absolute file name and number of characters inserted.•If second argument VISIT is non-nil, the buffer's visited filename and•last save file modtime are set, and it is marked unmodified.  If•visiting and the file does not exist, visiting is completed before the•error is signaled.••The optional third and fourth arguments BEG and END specify what portion•of the file to insert.  These arguments count bytes in the file, not•characters in the buffer.  If VISIT is non-nil, BEG and END must be nil.••If optional fifth argument REPLACE is non-nil, replace the current•buffer contents (in the accessible portion) with the file contents.•This is better than simply deleting and inserting the whole thing•because (1) it preserves some marker positions and (2) it puts less data•in the undo list.  When REPLACE is non-nil, the second return value is•the number of characters that replace previous buffer contents.••This function does code conversion according to the value of•`coding-system-for-read' or `file-coding-system-alist', and sets the•variable `last-coding-system-used' to the coding system actually used.••In addition, this function decodes the inserted text from known formats•by calling `format-decode', which see.",
"insert-google-map-link":"insert-google-map-link is an interactive compiled Lisp function in•`xah_emacs_google_earth.el'.••(insert-google-map-link &amp;optional TITLE LONGITUDE-LATITUDE)••Insert HTML link to Google Map.••title is the title for the HTML link.•longitude-latitude is a vector [longitude latitude]. Each must be a decimal number. Positive signifies east, negative signifies west.••Example of inserted text:• &lt;a href=⧷&quotehttp://maps.google.com/maps?q=25.269536%2C82.990723⧷&quote title=⧷&quotePetrified Forest National Park⧷&quote&gt;🌐&lt;/a&gt;",
"insert-kbd-macro":"insert-kbd-macro is an interactive autoloaded compiled Lisp function•in `macros.el'.••(insert-kbd-macro MACRONAME &amp;optional KEYS)••Insert in buffer the definition of kbd macro NAME, as Lisp code.•Optional second arg KEYS means also record the keys it is on•(this is the prefix argument, when calling interactively).••This Lisp code will, when executed, define the kbd macro with the same•definition it has now.  If you say to record the keys, the Lisp code•will also rebind those keys to the macro.  Only global key bindings•are recorded since executing this Lisp code always makes global•bindings.••To save a kbd macro, visit a file of Lisp code such as your `~/.emacs',•use this command, and then save the file.",
"insert-kml":"insert-kml is an interactive compiled Lisp function in•`xah_emacs_google_earth.el'.••(insert-kml &amp;optional ΞKMLTITLE ΞLONLAT SOURCEFILEPATH)••Insert a simple Google Earth KML markup template.• ΞKMLTITLE is the name to use for the &lt;name&gt; tag.•ξlonlat is a vector [longitude latitude]. They must be real numbers.• SOURCEFILEPATH is the file that links to this kml file,•used in the &lt;description&gt; tag.",
"insert-rectangle":"insert-rectangle is an autoloaded compiled Lisp function in `rect.el'.••(insert-rectangle RECTANGLE)••Insert text of RECTANGLE with upper left corner at point.•RECTANGLE's first line is inserted at point, its second•line is inserted at a point vertically under point, etc.•RECTANGLE should be a list of strings.•After this command, the mark is at the upper left corner•and point is at the lower right corner.",
"insert-register":"insert-register is an interactive compiled Lisp function in•`register.el'.••(insert-register REGISTER &amp;optional ARG)••Insert contents of register REGISTER.  (REGISTER is a character.)•Normally puts point before and mark after the inserted text.•If optional second arg is non-nil, puts mark before and point after.•Interactively, second arg is non-nil if prefix arg is supplied.",
"integerp":"integerp is a built-in function in `C source code'.••(integerp OBJECT)••Return t if OBJECT is an integer.",
"interactive":"interactive is a special form in `C source code'.••(interactive &amp;optional ARGS)••Specify a way of parsing arguments for interactive use of a function.•For example, write• (defun foo (arg buf) ⧷&quoteDoc string⧷&quote (interactive ⧷&quoteP⧷nbbuffer: ⧷&quote) .... )• to make ARG be the raw prefix argument, and set BUF to an existing buffer,• when `foo' is called as a command.•The ⧷&quotecall⧷&quote to `interactive' is actually a declaration rather than a function;• it tells `call-interactively' how to read arguments• to pass to the function.•When actually called, `interactive' just returns nil.••Usually the argument of `interactive' is a string containing a code letter• followed optionally by a prompt.  (Some code letters do not use I/O to get• the argument and do not use prompts.)  To get several arguments, concatenate• the individual strings, separating them by newline characters.•Prompts are passed to format, and may use % escapes to print the• arguments that have already been read.•If the argument is not a string, it is evaluated to get a list of• arguments to pass to the function.•Just `(interactive)' means pass no args when calling interactively.••Code letters available are:•a -- Function name: symbol with a function definition.•b -- Name of existing buffer.•B -- Name of buffer, possibly nonexistent.•c -- Character (no input method is used).•C -- Command name: symbol with interactive function definition.•d -- Value of point as number.  Does not do I/O.•D -- Directory name.•e -- Parameterized event (i.e., one that's a list) that invoked this command.•     If used more than once, the Nth `e' returns the Nth parameterized event.•     This skips events that are integers or symbols.•f -- Existing file name.•F -- Possibly nonexistent file name.•G -- Possibly nonexistent file name, defaulting to just directory name.•i -- Ignored, i.e. always nil.  Does not do I/O.•k -- Key sequence (downcase the last event if needed to get a definition).•K -- Key sequence to be redefined (do not downcase the last event).•m -- Value of mark as number.  Does not do I/O.•M -- Any string.  Inherits the current input method.•n -- Number read using minibuffer.•N -- Numeric prefix arg, or if none, do like code `n'.•p -- Prefix arg converted to number.  Does not do I/O.•P -- Prefix arg in raw form.  Does not do I/O.•r -- Region: point and mark as 2 numeric args, smallest first.  Does no I/O.•s -- Any string.  Does not inherit the current input method.•S -- Any symbol.•U -- Mouse up event discarded by a previous k or K argument.•v -- Variable name: symbol that is `custom-variable-p'.•x -- Lisp expression read but not evaluated.•X -- Lisp expression read and evaluated.•z -- Coding system.•Z -- Coding system, nil if no prefix arg.••In addition, if the string begins with `*', an error is signaled if•  the buffer is read-only.•If `@' appears at the beginning of the string, and if the key sequence• used to invoke the command includes any mouse events, then the window• associated with the first of those events is selected before the• command is run.•If the string begins with `^' and `shift-select-mode' is non-nil,• Emacs first calls the function `handle-shift-selection'.•You may use `@', `*', and `^' together.  They are processed in the• order that they appear, before reading any arguments.",
"isearch-backward":"isearch-backward is an interactive compiled Lisp function in•`isearch.el'.••(isearch-backward &amp;optional REGEXP-P NO-RECURSIVE-EDIT)••Do incremental search backward.•With a prefix argument, do a regular expression search instead.•See the command `isearch-forward' for more information.",
"isearch-forward":"isearch-forward is an interactive compiled Lisp function in•`isearch.el'.••(isearch-forward &amp;optional REGEXP-P NO-RECURSIVE-EDIT)••Do incremental search forward.•With a prefix argument, do an incremental regular expression search instead.••As you type characters, they add to the search string and are found.•The following non-printing keys are bound in `isearch-mode-map'.••Type DEL to cancel last input item from end of search string.•Type RET to exit, leaving point at location found.•Type LFD (C-j) to match end of line.•Type C-f to search again forward, C-r to search again backward.•Type C-w to yank next word or character in buffer•  onto the end of the search string, and search for it.•Type M-u to delete character from end of search string.•Type C-M-y to yank char from buffer onto end of search string and search for it.•Type M-s C-e to yank rest of line onto end of search string and search for it.•Type C-v to yank the last string of killed text.•Type M-x isearch-yank-pop to replace string just yanked into search prompt• with string killed before it.•Type C-q to quote control character to search for it.•C-g while searching or when search has failed cancels input back to what has• been found successfully.•C-g when search is successful aborts and moves point to starting point.••If you try to exit with the search string still empty, it invokes• nonincremental search.••Type M-s c to toggle search case-sensitivity.•Type M-7 to toggle regular-expression mode.•Type M-s w to toggle word mode.•Type M-s _ to toggle symbol mode.••Type M-s SPC to toggle whitespace matching.•In incremental searches, a space or spaces normally matches any whitespace•defined by the variable `search-whitespace-regexp'; see also the variables•`isearch-lax-whitespace' and `isearch-regexp-lax-whitespace'.••Type M-x isearch-edit-string to edit the search string in the minibuffer.••Also supported is a search ring of the previous 16 search strings.•Type &lt;f12&gt; to search for the next item in the search ring.•Type &lt;f11&gt; to search for the previous item in the search ring.•Type C-M-i to complete the search string using the search ring.••Type M-5 to run `query-replace' with string to replace from last search string.•Type M-% to run `query-replace-regexp' with the last search string.•Type M-s o to run `occur' that shows the last search string.•Type M-s h r to run `highlight-regexp' that highlights the last search string.••Type C-h b to display all Isearch key bindings.•Type C-h k to display documentation of Isearch key.•Type C-h m to display documentation of Isearch mode.••If an input method is turned on in the current buffer, that input•method is also active while you are typing characters to search.•To toggle the input method, type C-⧷.  It also toggles the input•method in the current buffer.••To use a different input method for searching, type C-^,•and specify an input method you want to use.••The above keys, bound in `isearch-mode-map', are often controlled by• options; do M-x apropos on search-.* to find them.•Other control and meta characters terminate the search• and are then executed normally (depending on `search-exit-option').•Likewise for function keys and mouse button events.••If this function is called non-interactively, it does not return to•the calling function until the search is done.",
"isearch-forward-at-point":"isearch-forward-at-point is an interactive compiled Lisp function in•`xah_emacs_load_misc.el'.••(isearch-forward-at-point &amp;optional REGEXP-P NO-RECURSIVE-EDIT)••Interactive search forward for the symbol at point.",
"isearch-mode":"isearch-mode is a compiled Lisp function in `isearch.el'.••(isearch-mode FORWARD &amp;optional REGEXP OP-FUN RECURSIVE-EDIT WORD)••Start Isearch minor mode.•It is called by the function `isearch-forward' and other related functions.",
"isearch-printing-char":"isearch-printing-char is an interactive compiled Lisp function in•`isearch.el'.••(isearch-printing-char)••Add this ordinary printing character to the search string and search.",
"isearch-repeat-forward":"isearch-repeat-forward is an interactive compiled Lisp function in•`isearch.el'.••(isearch-repeat-forward)••Repeat incremental search forwards.",
"ispell-word":"ispell-word is an interactive autoloaded compiled Lisp function in•`ispell.el'.••(ispell-word &amp;optional FOLLOWING QUIETLY CONTINUE REGION)••Check spelling of word under or before the cursor.•If the word is not found in dictionary, display possible corrections•in a window allowing you to choose one.••If optional argument FOLLOWING is non-nil or if `ispell-following-word'•is non-nil when called interactively, then the following word•(rather than preceding) is checked when the cursor is not over a word.•When the optional argument QUIETLY is non-nil or `ispell-quietly' is non-nil•when called interactively, non-corrective messages are suppressed.••With a prefix argument (or if CONTINUE is non-nil),•resume interrupted spell-checking of a buffer or region.••Interactively, in Transient Mark mode when the mark is active, call•`ispell-region' to check the active region for spelling errors.••Word syntax is controlled by the definition of the chosen dictionary,•which is in `ispell-local-dictionary-alist' or `ispell-dictionary-alist'.••This will check or reload the dictionary.  Use M-x ispell-change-dictionary•or M-x ispell-region to update the Ispell process.••Return values:•nil           word is correct or spelling is accepted.•0             word is inserted into buffer-local definitions.•⧷&quoteword⧷&quote        word corrected from word list.•(⧷&quoteword⧷&quote arg)  word is hand entered.•quit          spell session exited.",
"iswitchb-mode":"iswitchb-mode is an interactive autoloaded Lisp function in•`iswitchb.el'.••(iswitchb-mode &amp;optional ARG)••Toggle Iswitchb mode.•With a prefix argument ARG, enable Iswitchb mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••Iswitchb mode is a global minor mode that enables switching•between buffers using substrings.  See `iswitchb' for details.",
"js-mode":"js-mode is an interactive autoloaded compiled Lisp function in•`js.el'.••(js-mode)••Parent mode: `prog-mode'.••Major mode for editing JavaScript.••In addition to any hooks its parent mode `prog-mode' might have run,•this mode runs the hook `js-mode-hook', as the final step•during initialization.••key             binding•---             -------••C-c             Prefix Command•ESC             Prefix Command••C-M-x           js-eval-defun•M-.             js-find-symbol••C-c C-j         js-set-js-context•C-c ESC         Prefix Command••C-M-q           prog-indent-sexp••C-c M-:         js-eval••",
"jump-to-register":"jump-to-register is an interactive compiled Lisp function in•`register.el'.••(jump-to-register REGISTER &amp;optional DELETE)••Move point to location stored in a register.•If the register contains a file name, find that file.•(To put a file name in a register, you must use `set-register'.)•If the register contains a window configuration (one frame) or a frame•configuration (all frames), restore that frame or all frames accordingly.•First argument is a character, naming the register.•Optional second arg non-nil (interactively, prefix argument) says to•delete any existing frames that the frame configuration doesn't mention.•(Otherwise, these frames are iconified.)",
"just-one-space":"just-one-space is an interactive compiled Lisp function in•`simple.el'.••(just-one-space &amp;optional N)••Delete all spaces and tabs around point, leaving one space (or N spaces).•If N is negative, delete newlines as well, leaving -N spaces.",
"kbd":"kbd is a compiled Lisp function in `subr.el'.••(kbd KEYS)••Convert KEYS to the internal Emacs key representation.•KEYS should be a string constant in the format used for•saving keyboard macros (see `edmacro-mode').",
"keep-lines":"keep-lines is an interactive compiled Lisp function in `replace.el'.••(keep-lines REGEXP &amp;optional RSTART REND INTERACTIVE)••Delete all lines except those containing matches for REGEXP.•A match split across lines preserves all the lines it lies in.•When called from Lisp (and usually interactively as well, see below)•applies to all lines starting after point.••If REGEXP contains upper case characters (excluding those preceded by `⧷')•and `search-upper-case' is non-nil, the matching is case-sensitive.••Second and third arg RSTART and REND specify the region to operate on.•This command operates on (the accessible part of) all lines whose•accessible part is entirely contained in the region determined by RSTART•and REND.  (A newline ending a line counts as part of that line.)••Interactively, in Transient Mark mode when the mark is active, operate•on all lines whose accessible part is entirely contained in the region.•Otherwise, the command applies to all lines starting after point.•When calling this function from Lisp, you can pretend that it was•called interactively by passing a non-nil INTERACTIVE argument.••This function starts looking for the next match from the end of•the previous match.  Hence, it ignores matches that overlap•a previously found match.",
"keyboard-quit":"keyboard-quit is an interactive compiled Lisp function in `simple.el'.••(keyboard-quit)••Signal a `quit' condition.•During execution of Lisp code, this character causes a quit directly.•At top-level, as an editor command, this simply beeps.",
"keyboard-translate":"keyboard-translate is a compiled Lisp function in `subr.el'.••(keyboard-translate FROM TO)••Translate character FROM to TO on the current terminal.•This function creates a `keyboard-translate-table' if necessary•and then modifies one entry in it.",
"kill-all-local-variables":"kill-all-local-variables is a built-in function in `C source code'.••(kill-all-local-variables)••Switch to Fundamental mode by killing current buffer's local variables.•Most local variable bindings are eliminated so that the default values•become effective once more.  Also, the syntax table is set from•`standard-syntax-table', the local keymap is set to nil,•and the abbrev table from `fundamental-mode-abbrev-table'.•This function also forces redisplay of the mode line.••Every function to select a new major mode starts by•calling this function.••As a special exception, local variables whose names have•a non-nil `permanent-local' property are not eliminated by this function.••The first thing this function does is run•the normal hook `change-major-mode-hook'.",
"kill-append":"kill-append is a compiled Lisp function in `simple.el'.••(kill-append STRING BEFORE-P)••Append STRING to the end of the latest kill in the kill ring.•If BEFORE-P is non-nil, prepend STRING to the kill.•If `interprogram-cut-function' is set, pass the resulting kill to it.",
"kill-buffer":"kill-buffer is an interactive built-in function in `C source code'.••(kill-buffer &amp;optional BUFFER-OR-NAME)••Kill the buffer specified by BUFFER-OR-NAME.•The argument may be a buffer or the name of an existing buffer.•Argument nil or omitted means kill the current buffer.  Return t if the•buffer is actually killed, nil otherwise.••The functions in `kill-buffer-query-functions' are called with the•buffer to be killed as the current buffer.  If any of them returns nil,•the buffer is not killed.  The hook `kill-buffer-hook' is run before the•buffer is actually killed.  The buffer being killed will be current•while the hook is running.  Functions called by any of these hooks are•supposed to not change the current buffer.••Any processes that have this buffer as the `process-buffer' are killed•with SIGHUP.  This function calls `replace-buffer-in-windows' for•cleaning up all windows currently displaying the buffer to be killed.",
"kill-line":"kill-line is an interactive compiled Lisp function in `simple.el'.••(kill-line &amp;optional ARG)••Kill the rest of the current line; if no nonblanks there, kill thru newline.•With prefix argument ARG, kill that many lines from point.•Negative arguments kill lines backward.•With zero argument, kills the text before point on the current line.••When calling from a program, nil means ⧷&quoteno arg⧷&quote,•a number counts as a prefix arg.••To kill a whole line, when point is not at the beginning, type M-d M-i M-i.••If `show-trailing-whitespace' is non-nil, this command will just•kill the rest of the current line, even if there are only•nonblanks there.••If `kill-whole-line' is non-nil, then this command kills the whole line•including its terminating newline, when used at the beginning of a line•with no argument.  As a consequence, you can always kill a whole line•by typing M-d M-i.••If you want to append the killed line to the last killed text,•use C-M-w before M-i.••If the buffer is read-only, Emacs will beep and refrain from deleting•the line, but put the line in the kill ring anyway.  This means that•you can use this command to copy text from a read-only buffer.•(If the variable `kill-read-only-ok' is non-nil, then this won't•even beep.)",
"kill-rectangle":"kill-rectangle is an interactive autoloaded compiled Lisp function in•`rect.el'.••(kill-rectangle START END &amp;optional FILL)••Delete the region-rectangle and save it as the last killed one.••When called from a program the rectangle's corners are START and END.•You might prefer to use `delete-extract-rectangle' from a program.••With a prefix (or a FILL) argument, also fill lines where nothing has to be•deleted.••If the buffer is read-only, Emacs will beep and refrain from deleting•the rectangle, but put it in the kill ring anyway.  This means that•you can use this command to copy text from a read-only buffer.•(If the variable `kill-read-only-ok' is non-nil, then this won't•even beep.)",
"kill-region":"kill-region is an interactive compiled Lisp function in `simple.el'.••(kill-region BEG END)••Kill (⧷&quotecut⧷&quote) text between point and mark.•This deletes the text from the buffer and saves it in the kill ring.•The command C-v can retrieve it from there.•(If you want to save the region without killing it, use &lt;C-insertchar&gt;.)••If you want to append the killed region to the last killed text,•use C-M-w before C-x &lt;timeout&gt;.••If the buffer is read-only, Emacs will beep and refrain from deleting•the text, but put the text in the kill ring anyway.  This means that•you can use the killing commands to copy text from a read-only buffer.••Lisp programs should use this function for killing text.• (To delete text, use `delete-region'.)•Supply two arguments, character positions indicating the stretch of text• to be killed.•Any command that calls this function is a ⧷&quotekill command⧷&quote.•If the previous command was also a kill command,•the text killed this time appends to the text killed last time•to make one entry in the kill ring.",
"kill-ring-save":"kill-ring-save is an interactive compiled Lisp function in•`simple.el'.••(kill-ring-save BEG END)••Save the region as if killed, but don't kill it.•In Transient Mark mode, deactivate the mark.•If `interprogram-cut-function' is non-nil, also save the text for a window•system cut and paste.••If you want to append the killed line to the last killed text,•use C-M-w before &lt;C-insertchar&gt;.••This command is similar to `copy-region-as-kill', except that it gives•visual feedback indicating the extent of the region being copied.",
"kill-sentence":"kill-sentence is an interactive compiled Lisp function in•`paragraphs.el'.••(kill-sentence &amp;optional ARG)••Kill from point to end of sentence.•With arg, repeat; negative arg -N means kill back to Nth start of sentence.",
"kill-some-buffers":"kill-some-buffers is an interactive compiled Lisp function in•`files.el'.••(kill-some-buffers &amp;optional LIST)••Kill some buffers.  Asks the user whether to kill each one of them.•Non-interactively, if optional argument LIST is non-nil, it•specifies the list of buffers to kill, asking for approval for each one.",
"kill-whole-line":"kill-whole-line is an interactive compiled Lisp function in•`simple.el'.••(kill-whole-line &amp;optional ARG)••Kill current line.•With prefix ARG, kill that many lines starting from the current line.•If ARG is negative, kill backward.  Also kill the preceding newline.•(This is meant to make C-x z work well with negative arguments.)•If ARG is zero, kill current line but exclude the trailing newline.",
"kill-word":"kill-word is an interactive compiled Lisp function in `simple.el'.••(kill-word ARG)••Kill characters forward until encountering the end of a word.•With argument ARG, do this that many times.",
"kmacro-end-and-call-macro":"kmacro-end-and-call-macro is an interactive autoloaded compiled Lisp•function in `kmacro.el'.••(kmacro-end-and-call-macro ARG &amp;optional NO-REPEAT)••Call last keyboard macro, ending it first if currently being defined.•With numeric prefix ARG, repeat macro that many times.•Zero argument means repeat until there is an error.••To give a macro a permanent name, so you can call it•even after defining other macros, use C-x C-k C-n.",
"kmacro-end-macro":"kmacro-end-macro is an interactive autoloaded compiled Lisp function•in `kmacro.el'.••(kmacro-end-macro ARG)••Finish defining a keyboard macro.•The definition was started by C-x (.•The macro is now available for use via M-x kmacro-call-macro,•or it can be given a name with C-x C-k C-n and then invoked•under that name.••With numeric arg, repeat macro now that many times,•counting the definition just completed as the first repetition.•An argument of zero means repeat until error.",
"kmacro-start-macro":"kmacro-start-macro is an interactive autoloaded compiled Lisp function•in `kmacro.el'.••(kmacro-start-macro ARG)••Record subsequent keyboard input, defining a keyboard macro.•The commands are recorded even as they are executed.•Use C-x ) to finish recording and make the macro available.•Use C-x e to execute the macro.••Non-nil arg (prefix arg) means append to last macro defined.••With C-u prefix, append to last keyboard macro•defined.  Depending on `kmacro-execute-before-append', this may begin•by re-executing the last macro as if you typed it again.••Otherwise, it sets `kmacro-counter' to ARG or 0 if missing before•defining the macro.••Use C-x C-k i to insert (and increment) the macro counter.•The counter value can be set or modified via C-x C-k c and C-x C-k a.•The format of the counter can be modified via C-x C-k f.••Use C-x C-k C-n to give it a permanent name.•Use C-x C-k C-b to bind it to a key sequence.",
"lambda":"lambda is a Lisp macro in `subr.el'.••(lambda ARGS [DOCSTRING] [INTERACTIVE] BODY)••Return a lambda expression.•A call of the form (lambda ARGS DOCSTRING INTERACTIVE BODY) is•self-quoting; the result of evaluating the lambda expression is the•expression itself.  The lambda expression may then be treated as a•function, i.e., stored as the function value of a symbol, passed to•`funcall' or `mapcar', etc.••ARGS should take the same form as an argument list for a `defun'.•DOCSTRING is an optional documentation string.• If present, it should describe how to call the function.• But documentation strings are usually not useful in nameless functions.•INTERACTIVE should be a call to the function `interactive', which see.•It may also be omitted.•BODY should be a list of Lisp expressions.",
"last":"last is a compiled Lisp function in `subr.el'.••(last LIST &amp;optional N)••Return the last link of LIST.  Its car is the last element.•If LIST is nil, return nil.•If N is non-nil, return the Nth-to-last link of LIST.•If N is bigger than the length of LIST, return LIST.",
"length":"length is a built-in function in `C source code'.••(length SEQUENCE)••Return the length of vector, list or string SEQUENCE.•A byte-code function object is also allowed.•If the string contains multibyte characters, this is not necessarily•the number of bytes in the string; it is the number of characters.•To get the number of bytes, use `string-bytes'.",
"let":"let is a special form in `C source code'.••(let VARLIST BODY...)••Bind variables according to VARLIST then eval BODY.•The value of the last form in BODY is returned.•Each element of VARLIST is a symbol (which is bound to nil)•or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).•All the VALUEFORMs are evalled before any symbols are bound.",
"let*":"let* is a special form in `C source code'.••(let* VARLIST BODY...)••Bind variables according to VARLIST then eval BODY.•The value of the last form in BODY is returned.•Each element of VARLIST is a symbol (which is bound to nil)•or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).•Each VALUEFORM can refer to the symbols already bound by this VARLIST.",
"lgrep":"lgrep is an interactive autoloaded compiled Lisp function in•`grep.el'.••(lgrep REGEXP &amp;optional FILES DIR CONFIRM)••Run grep, searching for REGEXP in FILES in directory DIR.•The search is limited to file names matching shell pattern FILES.•FILES may use abbreviations defined in `grep-files-aliases', e.g.•entering `ch' is equivalent to `*.[ch]'.••With C-u prefix, you can edit the constructed shell command line•before it is executed.•With two C-u prefixes, directly edit and run `grep-command'.••Collect output in a buffer.  While grep runs asynchronously, you•can use C-x ` (M-x next-error), or RET in the grep output buffer,•to go to the lines where grep found matches.••This command shares argument histories with M-x rgrep and M-x grep.",
"line-beginning-position":"line-beginning-position is a built-in function in `C source code'.••(line-beginning-position &amp;optional N)••Return the character position of the first character on the current line.•With optional argument N, scan forward N - 1 lines first.•If the scan reaches the end of the buffer, return that position.••This function ignores text display directionality; it returns the•position of the first character in logical order, i.e. the smallest•character position on the line.••This function constrains the returned position to the current field•unless that position would be on a different line than the original,•unconstrained result.  If N is nil or 1, and a front-sticky field•starts at point, the scan stops as soon as it starts.  To ignore field•boundaries, bind `inhibit-field-text-motion' to t.••This function does not move point.",
"line-end-position":"line-end-position is a built-in function in `C source code'.••(line-end-position &amp;optional N)••Return the character position of the last character on the current line.•With argument N not nil or 1, move forward N - 1 lines first.•If scan reaches end of buffer, return that position.••This function ignores text display directionality; it returns the•position of the last character in logical order, i.e. the largest•character position on the line.••This function constrains the returned position to the current field•unless that would be on a different line than the original,•unconstrained result.  If N is nil or 1, and a rear-sticky field ends•at point, the scan stops as soon as it starts.  To ignore field•boundaries bind `inhibit-field-text-motion' to t.••This function does not move point.",
"line-move-visual":"line-move-visual is a compiled Lisp function in `simple.el'.••(line-move-visual ARG &amp;optional NOERROR)••Not documented.",
"linum-mode":"linum-mode is an interactive autoloaded compiled Lisp function in•`linum.el'.••(linum-mode &amp;optional ARG)••Toggle display of line numbers in the left margin (Linum mode).•With a prefix argument ARG, enable Linum mode if ARG is positive,•and disable it otherwise.  If called from Lisp, enable the mode•if ARG is omitted or nil.••Linum mode is a buffer-local minor mode.",
"lisp-interaction-mode":"lisp-interaction-mode is an interactive compiled Lisp function in•`lisp-mode.el'.••(lisp-interaction-mode)••Parent mode: `emacs-lisp-mode'.••Major mode for typing and evaluating Lisp forms.•Like Lisp mode except that M-x eval-print-last-sexp evals the Lisp expression•before point, and prints its value into the buffer, advancing point.•Note that printing is controlled by `eval-expression-print-length'•and `eval-expression-print-level'.••Commands:•Delete converts tabs to spaces as it moves back.•Paragraphs are separated only by blank lines.•Semicolons start comments.••key             binding•---             -------••C-j             eval-print-last-sexp•ESC             Prefix Command•DEL             backward-delete-char-untabify••C-M-i           completion-at-point•C-M-q           indent-pp-sexp•C-M-x           eval-defun••C-M-q           indent-sexp•  (that binding is currently shadowed by another mode)•••Entry to this mode calls the value of `lisp-interaction-mode-hook'•if that value is non-nil.",
"list":"list is a built-in function in `C source code'.••(list &amp;rest OBJECTS)••Return a newly created list with specified arguments as elements.•Any number of arguments, even zero arguments, are allowed.",
"list-buffers":"list-buffers is an interactive compiled Lisp function in•`buff-menu.el'.••(list-buffers &amp;optional ARG)••Display a list of existing buffers.•The list is displayed in a buffer named ⧷&quote*Buffer List*⧷&quote.•See `buffer-menu' for a description of the Buffer Menu.••By default, all buffers are listed except those whose names start•with a space (which are for internal use).  With prefix argument•ARG, show only buffers that are visiting files.",
"list-character-sets":"list-character-sets is an interactive autoloaded Lisp function in•`mule-diag.el'.••(list-character-sets ARG)••Display a list of all character sets.••The D column contains the dimension of this character set.  The CH•column contains the number of characters in a block of this character•set.  The FINAL-BYTE column contains an ISO-2022 &lt;final-byte&gt; to use•in the designation escape sequence for this character set in•ISO-2022-based coding systems.••With prefix ARG, the output format gets more cryptic,•but still shows the full information.",
"list-charset-chars":"list-charset-chars is an interactive autoloaded Lisp function in•`mule-diag.el'.••(list-charset-chars CHARSET)••Display a list of characters in character set CHARSET.",
"list-coding-systems":"list-coding-systems is an interactive autoloaded Lisp function in•`mule-diag.el'.••(list-coding-systems &amp;optional ARG)••Display a list of all coding systems.•This shows the mnemonic letter, name, and description of each coding system.••With prefix ARG, the output format gets more cryptic,•but still contains full information about each coding system.",
"list-colors-display":"list-colors-display is an interactive compiled Lisp function in•`facemenu.el'.••(list-colors-display &amp;optional LIST BUFFER-NAME CALLBACK)••Display names of defined colors, and show what they look like.•If the optional argument LIST is non-nil, it should be a list of•colors to display.  Otherwise, this command computes a list of•colors that the current display can handle.  Customize•`list-colors-sort' to change the order in which colors are shown.••If the optional argument BUFFER-NAME is nil, it defaults to *Colors*.••If the optional argument CALLBACK is non-nil, it should be a•function to call each time the user types RET or clicks on a•color.  The function should accept a single argument, the color name.",
"list-input-methods":"list-input-methods is an interactive autoloaded Lisp function in•`mule-diag.el'.••(list-input-methods)••Display information about all input methods.",
"list-matching-lines":"list-matching-lines is an alias for `occur' in `replace.el'.••(list-matching-lines REGEXP &amp;optional NLINES)••Show all lines in the current buffer containing a match for REGEXP.•If a match spreads across multiple lines, all those lines are shown.••Each line is displayed with NLINES lines before and after, or -NLINES•before if NLINES is negative.•NLINES defaults to `list-matching-lines-default-context-lines'.•Interactively it is the prefix arg.••The lines are shown in a buffer named `*Occur*'.•It serves as a menu to find any of the occurrences in this buffer.•h in that buffer will explain how.••If REGEXP contains upper case characters (excluding those preceded by `⧷')•and `search-upper-case' is non-nil, the matching is case-sensitive.••When NLINES is a string or when the function is called•interactively with prefix argument without a number (`C-u' alone•as prefix) the matching strings are collected into the `*Occur*'•buffer by using NLINES as a replacement regexp.  NLINES may•contain ⧷&amp; and ⧷N which convention follows `replace-match'.•For example, providing ⧷&quotedefun⧷s +⧷(⧷S +⧷)⧷&quote for REGEXP and•⧷&quote⧷1⧷&quote for NLINES collects all the function names in a lisp•program.  When there is no parenthesized subexpressions in REGEXP•the entire match is collected.  In any case the searched buffer•is not modified.",
"list-packages":"list-packages is an interactive autoloaded compiled Lisp function in•`package.el'.••(list-packages &amp;optional NO-FETCH)••Display a list of packages.•This first fetches the updated list of packages before•displaying, unless a prefix argument NO-FETCH is specified.•The list is displayed in a buffer named `*Packages*'.",
"load":"load is a built-in function in `C source code'.••(load FILE &amp;optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)••Execute a file of Lisp code named FILE.•First try FILE with `.elc' appended, then try with `.el',•then try FILE unmodified (the exact suffixes in the exact order are•determined by `load-suffixes').  Environment variable references in•FILE are replaced with their values by calling `substitute-in-file-name'.•This function searches the directories in `load-path'.••If optional second arg NOERROR is non-nil,•report no error if FILE doesn't exist.•Print messages at start and end of loading unless•optional third arg NOMESSAGE is non-nil (but `force-load-messages'•overrides that).•If optional fourth arg NOSUFFIX is non-nil, don't try adding•suffixes `.elc' or `.el' to the specified name FILE.•If optional fifth arg MUST-SUFFIX is non-nil, insist on•the suffix `.elc' or `.el'; don't accept just FILE unless•it ends in one of those suffixes or includes a directory name.••If NOSUFFIX is nil, then if a file could not be found, try looking for•a different representation of the file by adding non-empty suffixes to•its name, before trying another file.  Emacs uses this feature to find•compressed versions of files when Auto Compression mode is enabled.•If NOSUFFIX is non-nil, disable this feature.••The suffixes that this function tries out, when NOSUFFIX is nil, are•given by the return value of `get-load-suffixes' and the values listed•in `load-file-rep-suffixes'.  If MUST-SUFFIX is non-nil, only the•return value of `get-load-suffixes' is used, i.e. the file name is•required to have a non-empty suffix.••Loading a file records its definitions, and its `provide' and•`require' calls, in an element of `load-history' whose•car is the file name loaded.  See `load-history'.••While the file is in the process of being loaded, the variable•`load-in-progress' is non-nil and the variable `load-file-name'•is bound to the file's name.••Return t if the file exists and loads successfully.",
"load-file":"load-file is an interactive compiled Lisp function in `files.el'.••(load-file FILE)••Load the Lisp file named FILE.",
"load-theme":"load-theme is an interactive compiled Lisp function in `custom.el'.••(load-theme THEME &amp;optional NO-CONFIRM NO-ENABLE)••Load Custom theme named THEME from its file.•The theme file is named THEME-theme.el, in one of the directories•specified by `custom-theme-load-path'.••If the theme is not considered safe by `custom-safe-themes',•prompt the user for confirmation before loading it.  But if•optional arg NO-CONFIRM is non-nil, load the theme without•prompting.••Normally, this function also enables THEME.  If optional arg•NO-ENABLE is non-nil, load the theme but don't enable it, unless•the theme was already enabled.••This function is normally called through Customize when setting•`custom-enabled-themes'.  If used directly in your init file, it•should be called with a non-nil NO-CONFIRM argument, or after•`custom-safe-themes' has been loaded.••Return t if THEME was successfully loaded, nil otherwise.",
"local-set-key":"local-set-key is an interactive compiled Lisp function in `subr.el'.••(local-set-key KEY COMMAND)••Give KEY a local binding as COMMAND.•COMMAND is the command definition to use; usually it is•a symbol naming an interactively-callable function.•KEY is a key sequence; noninteractively, it is a string or vector•of characters or event types, and non-ASCII characters with codes•above 127 (such as ISO Latin-1) can be included if you use a vector.••The binding goes in the current buffer's local map,•which in most cases is shared with all other buffers in the same major mode.••This function is advised.••Around-advice `ergoemacs-local-set-key-advice':•This let you use local-set-key as usual when ergoemacs-mode is enabled.",
"local-url-to-file-path":"local-url-to-file-path is a compiled Lisp function in•`xah_emacs_xahsite_path_lisp_util.el'.••(local-url-to-file-path LOCALFILEURL)••Turn a localhost file URL LOCALFILEURL into a file full path.••localFileURL must be a full path.••For example, the following string shown in browser URL field:•; On Windows Vista 2009-06• 〔C:⧷Users⧷xah⧷web⧷emacs⧷emacs.html〕  IE• 〔file:///C:/Users/xah/web/emacs/emacs.html〕  Firefox, Google Chrome, Safari• 〔file://localhost/C:/Users/xah/web/emacs/emacs.html〕  Opera• becomes• 〔C:/Users/xah/web/emacs/emacs.html〕•• On Mac 2009-06• 〔file:///Users/xah/web/emacs/emacs.html〕  Safari, Firefox• 〔file://localhost/Users/xah/web/emacs/emacs.html〕  Opera• becomes• 〔/Users/xah/web/emacs/emacs.html〕•• On Ubuntu Linux, 2011-05• 〔file:///media/HP/Users/xah/web/xahlee_org/index.html〕 firefox• becomes• 〔/media/HP/Users/xah/web/xahlee_org/index.html〕•",
"looking-at":"looking-at is a built-in function in `C source code'.••(looking-at REGEXP)••Return t if text after point matches regular expression REGEXP.•This function modifies the match data that `match-beginning',•`match-end' and `match-data' access; save and restore the match•data if you want to preserve them.",
"lookup-google":"lookup-google is an interactive Lisp function in•`lookup-word-on-internet.el'.••(lookup-google &amp;optional INPUT-WORD)••Lookup current word or text selection in Google Search.•See also `lookup-word-on-internet'.",
"make-directory":"make-directory is an interactive compiled Lisp function in `files.el'.••(make-directory DIR &amp;optional PARENTS)••Create the directory DIR and optionally any nonexistent parent dirs.•If DIR already exists as a directory, signal an error, unless•PARENTS is non-nil.••Interactively, the default choice of directory to create is the•current buffer's default directory.  That is useful when you have•visited a file in a nonexistent directory.••Noninteractively, the second (optional) argument PARENTS, if•non-nil, says whether to create parent directories that don't•exist.  Interactively, this happens by default.••If creating the directory or directories fail, an error will be•raised.",
"make-google-earth":"make-google-earth is an interactive compiled Lisp function in•`xah_emacs_google_earth.el'.••(make-google-earth)••Create a KML file and replace the current line as a link to it.••The current line must have data of this format:•‹title›/‹latitude›/‹longitude›••Example:•Las Vegas/36.1027/-115.1730••The line will be replaced to like this:•&lt;a href=⧷&quote…/las_vegas.kml⧷&quote title=⧷&quoteLas Vegas⧷&quote&gt;🌎&lt;/a&gt;•• (Note: latitude is y-axis, longitude is x-axis)••The KML file will be created at:• 〔~/web/xahlee_org/kml/‹title›.kml〕.",
"make-hash-table":"make-hash-table is a built-in function in `C source code'.••(make-hash-table &amp;rest KEYWORD-ARGS)••Create and return a new hash table.••Arguments are specified as keyword/argument pairs.  The following•arguments are defined:••:test TEST -- TEST must be a symbol that specifies how to compare•keys.  Default is `eql'.  Predefined are the tests `eq', `eql', and•`equal'.  User-supplied test and hash functions can be specified via•`define-hash-table-test'.••:size SIZE -- A hint as to how many elements will be put in the table.•Default is 65.••:rehash-size REHASH-SIZE - Indicates how to expand the table when it•fills up.  If REHASH-SIZE is an integer, increase the size by that•amount.  If it is a float, it must be &gt; 1.0, and the new size is the•old size multiplied by that factor.  Default is 1.5.••:rehash-threshold THRESHOLD -- THRESHOLD must a float &gt; 0, and &lt;= 1.0.•Resize the hash table when the ratio (number of entries / table size)•is greater than or equal to THRESHOLD.  Default is 0.8.••:weakness WEAK -- WEAK must be one of nil, t, `key', `value',•`key-or-value', or `key-and-value'.  If WEAK is not nil, the table•returned is a weak table.  Key/value pairs are removed from a weak•hash table when there are no non-weak references pointing to their•key, value, one of key or value, or both key and value, depending on•WEAK.  WEAK t is equivalent to `key-and-value'.  Default value of WEAK•is nil.",
"make-sparse-keymap":"make-sparse-keymap is a built-in function in `C source code'.••(make-sparse-keymap &amp;optional STRING)••Construct and return a new sparse keymap.•Its car is `keymap' and its cdr is an alist of (CHAR . DEFINITION),•which binds the character CHAR to DEFINITION, or (SYMBOL . DEFINITION),•which binds the function key or mouse event SYMBOL to DEFINITION.•Initially the alist is nil.••The optional arg STRING supplies a menu name for the keymap•in case you use it as a menu with `x-popup-menu'.",
"make-vector":"make-vector is a built-in function in `C source code'.••(make-vector LENGTH INIT)••Return a newly created vector of length LENGTH, with each element being INIT.•See also the function `vector'.",
"man":"man is an interactive autoloaded compiled Lisp function in `man.el'.••(man MAN-ARGS)••Get a Un*x manual page and put it in a buffer.•This command is the top-level command in the man package.  It•runs a Un*x command to retrieve and clean a manpage in the•background and places the results in a `Man-mode' browsing•buffer.  See variable `Man-notify-method' for what happens when•the buffer is ready.  If a buffer already exists for this man•page, it will display immediately.••For a manpage from a particular section, use either of the•following.  ⧷&quotecat(1)⧷&quote is how cross-references appear and is•passed to man as ⧷&quote1 cat⧷&quote.••    cat(1)•    1 cat••To see manpages from all sections related to a subject, use an•⧷&quoteall pages⧷&quote option (which might be ⧷&quote-a⧷&quote if it's not the•default), then step through with `Man-next-manpage' (M-n) etc.•Add to `Man-switches' to make this option permanent.••    -a chmod••An explicit filename can be given too.  Use -l if it might•otherwise look like a page name.••    /my/file/name.1.gz•    -l somefile.1••An ⧷&quoteapropos⧷&quote query with -k gives a buffer of matching page•names or descriptions.  The pattern argument is usually an•⧷&quoteegrep⧷&quote style regexp.••    -k pattern",
"manual-entry":"manual-entry is an alias for `man' in `man.el'.••(manual-entry MAN-ARGS)••Get a Un*x manual page and put it in a buffer.•This command is the top-level command in the man package.  It•runs a Un*x command to retrieve and clean a manpage in the•background and places the results in a `Man-mode' browsing•buffer.  See variable `Man-notify-method' for what happens when•the buffer is ready.  If a buffer already exists for this man•page, it will display immediately.••For a manpage from a particular section, use either of the•following.  ⧷&quotecat(1)⧷&quote is how cross-references appear and is•passed to man as ⧷&quote1 cat⧷&quote.••    cat(1)•    1 cat••To see manpages from all sections related to a subject, use an•⧷&quoteall pages⧷&quote option (which might be ⧷&quote-a⧷&quote if it's not the•default), then step through with `Man-next-manpage' (M-n) etc.•Add to `Man-switches' to make this option permanent.••    -a chmod••An explicit filename can be given too.  Use -l if it might•otherwise look like a page name.••    /my/file/name.1.gz•    -l somefile.1••An ⧷&quoteapropos⧷&quote query with -k gives a buffer of matching page•names or descriptions.  The pattern argument is usually an•⧷&quoteegrep⧷&quote style regexp.••    -k pattern",
"mapc":"mapc is a built-in function in `C source code'.••(mapc FUNCTION SEQUENCE)••Apply FUNCTION to each element of SEQUENCE for side effects only.•Unlike `mapcar', don't accumulate the results.  Return SEQUENCE.•SEQUENCE may be a list, a vector, a bool-vector, or a string.",
"mapcar":"mapcar is a built-in function in `C source code'.••(mapcar FUNCTION SEQUENCE)••Apply FUNCTION to each element of SEQUENCE, and make a list of the results.•The result is a list just as long as SEQUENCE.•SEQUENCE may be a list, a vector, a bool-vector, or a string.",
"mapconcat":"mapconcat is a built-in function in `C source code'.••(mapconcat FUNCTION SEQUENCE SEPARATOR)••Apply FUNCTION to each element of SEQUENCE, and concat the results as strings.•In between each pair of results, stick in SEPARATOR.  Thus, ⧷&quote ⧷&quote as•SEPARATOR results in spaces between the values returned by FUNCTION.•SEQUENCE may be a list, a vector, a bool-vector, or a string.",
"maphash":"maphash is a built-in function in `C source code'.••(maphash FUNCTION TABLE)••Call FUNCTION for all entries in hash table TABLE.•FUNCTION is called with two arguments, KEY and VALUE.",
"mark-defun":"mark-defun is an interactive compiled Lisp function in `lisp.el'.••(mark-defun &amp;optional ALLOW-EXTEND)••Put mark at end of this defun, point at beginning.•The defun marked is the one that contains point or follows point.••Interactively, if this command is repeated•or (in Transient Mark mode) if the mark is active,•it marks the next defun after the ones already marked.",
"mark-page":"mark-page is an interactive compiled Lisp function in `page.el'.••(mark-page &amp;optional ARG)••Put mark at end of page, point at beginning.•A numeric arg specifies to move forward or backward by that many pages,•thus marking a page other than the one point was originally in.",
"mark-paragraph":"mark-paragraph is an interactive compiled Lisp function in•`paragraphs.el'.••(mark-paragraph &amp;optional ARG ALLOW-EXTEND)••Put point at beginning of this paragraph, mark at end.•The paragraph marked is the one that contains point or follows point.••With argument ARG, puts mark at end of a following paragraph, so that•the number of paragraphs marked equals ARG.••If ARG is negative, point is put at end of this paragraph, mark is put•at beginning of this or a previous paragraph.••Interactively (or if ALLOW-EXTEND is non-nil), if this command is•repeated or (in Transient Mark mode) if the mark is active,•it marks the next ARG paragraphs after the ones already marked.",
"mark-sexp":"mark-sexp is an interactive compiled Lisp function in `lisp.el'.••(mark-sexp &amp;optional ARG ALLOW-EXTEND)••Set mark ARG sexps from point.•The place mark goes is the same place C-M-f would•move to with the same argument.•Interactively, if this command is repeated•or (in Transient Mark mode) if the mark is active,•it marks the next ARG sexps after the ones already marked.•This command assumes point is not in a string or comment.",
"mark-whole-buffer":"mark-whole-buffer is an interactive compiled Lisp function in•`simple.el'.••(mark-whole-buffer)••Put point at beginning and mark at end of buffer.•If narrowing is in effect, only uses the accessible part of the buffer.•You probably should not use this function in Lisp programs;•it is usually a mistake for a Lisp function to use any subroutine•that uses or sets the mark.",
"mark-word":"mark-word is an interactive compiled Lisp function in `simple.el'.••(mark-word &amp;optional ARG ALLOW-EXTEND)••Set mark ARG words away from point.•The place mark goes is the same place M-r would•move to with the same argument.•Interactively, if this command is repeated•or (in Transient Mark mode) if the mark is active,•it marks the next ARG words after the ones already marked.",
"match-beginning":"match-beginning is a built-in function in `C source code'.••(match-beginning SUBEXP)••Return position of start of text matched by last search.•SUBEXP, a number, specifies which parenthesized expression in the last•  regexp.•Value is nil if SUBEXPth pair didn't match, or there were less than•  SUBEXP pairs.•Zero means the entire text matched by the whole regexp or whole string.",
"match-end":"match-end is a built-in function in `C source code'.••(match-end SUBEXP)••Return position of end of text matched by last search.•SUBEXP, a number, specifies which parenthesized expression in the last•  regexp.•Value is nil if SUBEXPth pair didn't match, or there were less than•  SUBEXP pairs.•Zero means the entire text matched by the whole regexp or whole string.",
"match-string":"match-string is a compiled Lisp function in `subr.el'.••(match-string NUM &amp;optional STRING)••Return string of text matched by last search.•NUM specifies which parenthesized expression in the last regexp.• Value is nil if NUMth pair didn't match, or there were less than NUM pairs.•Zero means the entire text matched by the whole regexp or whole string.•STRING should be given if the last search was by `string-match' on STRING.•If STRING is nil, the current buffer should be the same buffer•the search/match was performed in.",
"math-symbol-input-mode":"math-symbol-input-mode is an alias for `xmsi-mode' in•`init_aliases.el'.••(math-symbol-input-mode &amp;optional ARG)••Toggle math symbol input (minor) mode.••A mode for inputting a few math and other Unicode symbols.••Type “inf”, then press 【Shift+Space】, then it becomes “∞”.•Other examples:• a ⇒ α• p ⇒ π• != ⇒ ≠• &gt;= ⇒ ≥• =&gt; ⇒ ⇒• -&gt; ⇒ →• and ⇒ ∧•etc.••If you have a text selection, then selected word will be taken as•input. For example, type 「sin(a)」, select the “a”, then press• 【Shift+Space】, then it becomse 「sin(α)」.••For the complete list of abbrevs, call `xmsi-list-math-symbols'.•All XML char entity abbrevs are supported. For example, 「copy」 ⇒ 「©」.••Decimal and hexadecimal can also be used. Example:•• 945     ← decimal• #945    ← decimal with prefix #• &amp;#945;  ← XML entity syntax•• x3b1    ← hexadimal with prefix x• #x3b1   ← hexadimal with prefix #x• &amp;#x3b1; ← XML entity syntax••Full Unicode name can also be used, e.g. 「greek small letter alpha」.••If you wish to enter a symbor by full unicode name but do not•know the full name, call `ucs-insert'. Asterisk “*” can be used•as a wildcard to find the char. For example, call•“ucs-insert”, then type 「*arrow」 then Tab, then emacs will list•all unicode char names that has “arrow” in it. (this feature is•part of Emacs 23)••Without argument, toggles the minor mode.•If optional argument is 1, turn it on.•If optional argument is 0, turn it off.••Home page at: URL `http://ergoemacs.org/emacs/xmsi-math-symbols-input.html'",
"md5":"md5 is a built-in function in `C source code'.••(md5 OBJECT &amp;optional START END CODING-SYSTEM NOERROR)••Return MD5 message digest of OBJECT, a buffer or string.••A message digest is a cryptographic checksum of a document, and the•algorithm to calculate it is defined in RFC 1321.••The two optional arguments START and END are character positions•specifying for which part of OBJECT the message digest should be•computed.  If nil or omitted, the digest is computed for the whole•OBJECT.••The MD5 message digest is computed from the result of encoding the•text in a coding system, not directly from the internal Emacs form of•the text.  The optional fourth argument CODING-SYSTEM specifies which•coding system to encode the text with.  It should be the same coding•system that you used or will use when actually writing the text into a•file.••If CODING-SYSTEM is nil or omitted, the default depends on OBJECT.  If•OBJECT is a buffer, the default for CODING-SYSTEM is whatever coding•system would be chosen by default for writing this text into a file.••If OBJECT is a string, the most preferred coding system (see the•command `prefer-coding-system') is used.••If NOERROR is non-nil, silently assume the `raw-text' coding if the•guesswork fails.  Normally, an error is signaled in such case.",
"member":"member is a built-in function in `C source code'.••(member ELT LIST)••Return non-nil if ELT is an element of LIST.  Comparison done with `equal'.•The value is actually the tail of LIST whose car is ELT.",
"memq":"memq is a built-in function in `C source code'.••(memq ELT LIST)••Return non-nil if ELT is an element of LIST.  Comparison done with `eq'.•The value is actually the tail of LIST whose car is ELT.",
"message":"message is a built-in function in `C source code'.••(message FORMAT-STRING &amp;rest ARGS)••Display a message at the bottom of the screen.•The message also goes into the `*Messages*' buffer, if `message-log-max'•is non-nil.  (In keyboard macros, that's all it does.)•Return the message.••The first argument is a format control string, and the rest are data•to be formatted under control of the string.  See `format' for details.••Note: Use (message ⧷&quote%s⧷&quote VALUE) to print the value of expressions and•variables to avoid accidentally interpreting `%' as format specifiers.••If the first argument is nil or the empty string, the function clears•any existing message; this lets the minibuffer contents show.  See•also `current-message'.",
"modify-syntax-entry":"modify-syntax-entry is an interactive built-in function in `C source•code'.••(modify-syntax-entry CHAR NEWENTRY &amp;optional SYNTAX-TABLE)••Set syntax for character CHAR according to string NEWENTRY.•The syntax is changed only for table SYNTAX-TABLE, which defaults to• the current buffer's syntax table.•CHAR may be a cons (MIN . MAX), in which case, syntaxes of all characters•in the range MIN to MAX are changed.•The first character of NEWENTRY should be one of the following:•  Space or -  whitespace syntax.    w   word constituent.•  _           symbol constituent.   .   punctuation.•  (           open-parenthesis.     )   close-parenthesis.•  ⧷&quote           string quote.         ⧷   escape.•  $           paired delimiter.     '   expression quote or prefix operator.•  &lt;           comment starter.      &gt;   comment ender.•  /           character-quote.      @   inherit from parent table.•  |           generic string fence. !   generic comment fence.••Only single-character comment start and end sequences are represented thus.•Two-character sequences are represented as described below.•The second character of NEWENTRY is the matching parenthesis,• used only if the first character is `(' or `)'.•Any additional characters are flags.•Defined flags are the characters 1, 2, 3, 4, b, p, and n.• 1 means CHAR is the start of a two-char comment start sequence.• 2 means CHAR is the second character of such a sequence.• 3 means CHAR is the start of a two-char comment end sequence.• 4 means CHAR is the second character of such a sequence.••There can be several orthogonal comment sequences.  This is to support•language modes such as C++.  By default, all comment sequences are of style•a, but you can set the comment sequence style to b (on the second character•of a comment-start, and the first character of a comment-end sequence) and/or•c (on any of its chars) using this flag:• b means CHAR is part of comment sequence b.• c means CHAR is part of comment sequence c.• n means CHAR is part of a nestable comment sequence.•• p means CHAR is a prefix character for `backward-prefix-chars';•   such characters are treated as whitespace when they occur•   between expressions.",
"move-beginning-of-line":"move-beginning-of-line is an interactive compiled Lisp function in•`simple.el'.••(move-beginning-of-line ARG)••Move point to beginning of current line as displayed.•(If there's an image in the line, this disregards newlines•which are part of the text that the image rests on.)••With argument ARG not nil or 1, move forward ARG - 1 lines first.•If point reaches the beginning or end of buffer, it stops there.•To ignore intangibility, bind `inhibit-point-motion-hooks' to t.••This function is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `move-beginning-of-line'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-move-beginning-of-line-keymap'.•",
"move-end-of-line":"move-end-of-line is an interactive compiled Lisp function in•`simple.el'.••(move-end-of-line ARG)••Move point to end of current line as displayed.•With argument ARG not nil or 1, move forward ARG - 1 lines first.•If point reaches the beginning or end of buffer, it stops there.••To ignore the effects of the `intangible' text or overlay•property, bind `inhibit-point-motion-hooks' to t.•If there is an image in the current line, this function•disregards newlines that are part of the text on which the image•rests.••This function is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `move-end-of-line'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-move-end-of-line-keymap'.•",
"move-to-window-line":"move-to-window-line is an interactive built-in function in `C source•code'.••(move-to-window-line ARG)••Position point relative to window.•ARG nil means position point at center of window.•Else, ARG specifies vertical position within the window;•zero means top of window, negative means relative to bottom of window.",
"move-to-window-line-top-bottom":"move-to-window-line-top-bottom is an interactive compiled Lisp•function in `window.el'.••(move-to-window-line-top-bottom &amp;optional ARG)••Position point relative to window.••With a prefix argument ARG, acts like `move-to-window-line'.••With no argument, positions point at center of window.•Successive calls position point at positions defined•by `recenter-positions'.",
"msys-shell":"msys-shell is an interactive Lisp function in `init_functions.el'.••(msys-shell &amp;optional ARG)••Run MSYS shell (sh.exe).  It's like a Unix Shell in Windows.•A numeric prefix arg switches to the specified session, creating•it if necessary.",
"multi-occur":"multi-occur is an interactive compiled Lisp function in `replace.el'.••(multi-occur BUFS REGEXP &amp;optional NLINES)••Show all lines in buffers BUFS containing a match for REGEXP.•This function acts on multiple buffers; otherwise, it is exactly like•`occur'.  When you invoke this command interactively, you must specify•the buffer names that you want, one by one.•See also `multi-occur-in-matching-buffers'.",
"multi-occur-in-matching-buffers":"multi-occur-in-matching-buffers is an interactive compiled Lisp•function in `replace.el'.••(multi-occur-in-matching-buffers BUFREGEXP REGEXP &amp;optional ALLBUFS)••Show all lines matching REGEXP in buffers specified by BUFREGEXP.•Normally BUFREGEXP matches against each buffer's visited file name,•but if you specify a prefix argument, it matches against the buffer name.•See also `multi-occur'.",
"mwheel-scroll":"mwheel-scroll is an interactive compiled Lisp function in `mwheel.el'.••(mwheel-scroll EVENT)••Scroll up or down according to the EVENT.•This should only be bound to mouse buttons 4 and 5.",
"name-last-kbd-macro":"name-last-kbd-macro is an interactive autoloaded compiled Lisp•function in `macros.el'.••(name-last-kbd-macro SYMBOL)••Assign a name to the last keyboard macro defined.•Argument SYMBOL is the name to define.•The symbol's function definition becomes the keyboard macro string.•Such a ⧷&quotefunction⧷&quote cannot be called from Lisp, but it is a valid editor command.",
"narrow-to-region":"narrow-to-region is an interactive built-in function in `C source•code'.••(narrow-to-region START END)••Restrict editing in this buffer to the current region.•The rest of the text becomes temporarily invisible and untouchable•but is not deleted; if you save the buffer in a file, the invisible•text is included in the file.  C-x n w makes all visible again.•See also `save-restriction'.••When calling from a program, pass two arguments; positions (integers•or markers) bounding the text that should remain visible.",
"negative-argument":"negative-argument is an interactive compiled Lisp function in•`simple.el'.••(negative-argument ARG)••Begin a negative numeric argument for the next command.•C-u following digits or minus sign ends the argument.",
"newline":"newline is an interactive compiled Lisp function in `simple.el'.••(newline &amp;optional ARG)••Insert a newline, and move to left margin of the new line if it's blank.•If `use-hard-newlines' is non-nil, the newline is marked with the•text-property `hard'.•With ARG, insert that many newlines.•Call `auto-fill-function' if the current column number is greater•than the value of `fill-column' and ARG is nil.",
"next-buffer":"next-buffer is an interactive compiled Lisp function in `window.el'.••(next-buffer)••In selected window switch to next buffer.",
"next-history-element":"next-history-element is an interactive compiled Lisp function in•`simple.el'.••(next-history-element N)••Puts next element of the minibuffer history in the minibuffer.•With argument N, it uses the Nth following element.",
"next-line":"next-line is an interactive compiled Lisp function in `simple.el'.••(next-line &amp;optional ARG TRY-VSCROLL)••Move cursor vertically down ARG lines.•Interactively, vscroll tall lines if `auto-window-vscroll' is enabled.•If there is no character in the target line exactly under the current column,•the cursor is positioned after the character in that line which spans this•column, or at the end of the line if it is not long enough.•If there is no line in the buffer after this one, behavior depends on the•value of `next-line-add-newlines'.  If non-nil, it inserts a newline character•to create a line, and moves the cursor to that line.  Otherwise it moves the•cursor to the end of the buffer.••If the variable `line-move-visual' is non-nil, this command moves•by display lines.  Otherwise, it moves by buffer lines, without•taking variable-width characters or continued lines into account.••The command C-x C-n can be used to create•a semipermanent goal column for this command.•Then instead of trying to move exactly vertically (or as close as possible),•this command moves to the specified goal column (or as close as possible).•The goal column is stored in the variable `goal-column', which is nil•when there is no goal column.  Note that setting `goal-column'•overrides `line-move-visual' and causes this command to move by buffer•lines rather than by display lines.••If you are thinking of using this in a Lisp program, consider•using `forward-line' instead.  It is usually easier to use•and more reliable (no dependence on goal column, etc.).••This function is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `next-line'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-next-line-keymap'.•",
"next-matching-history-element":"next-matching-history-element is an interactive compiled Lisp function•in `simple.el'.••(next-matching-history-element REGEXP N)••Find the next history element that matches REGEXP.•(The next history element refers to a more recent action.)•With prefix argument N, search for Nth next match.•If N is negative, find the previous or Nth previous match.•Normally, history elements are matched case-insensitively if•`case-fold-search' is non-nil, but an uppercase letter in REGEXP•makes the search case-sensitive.",
"not":"not is an alias for `null' in `subr.el'.••(not OBJECT)••Return t if OBJECT is nil.",
"nth":"nth is a built-in function in `C source code'.••(nth N LIST)••Return the Nth element of LIST.•N counts from zero.  If LIST is not that long, nil is returned.",
"null":"null is a built-in function in `C source code'.••(null OBJECT)••Return t if OBJECT is nil.",
"number-to-string":"number-to-string is a built-in function in `C source code'.••(number-to-string NUMBER)••Return the decimal representation of NUMBER as a string.•Uses a minus sign if negative.•NUMBER may be an integer or a floating point number.",
"nxml-mode":"nxml-mode is an interactive autoloaded compiled Lisp function in•`nxml-mode.el'.••(nxml-mode)••Parent mode: `text-mode'.••Major mode for editing XML.••M-x nxml-finish-element finishes the current element by inserting an end-tag.•C-c C-i closes a start-tag with `&gt;' and then inserts a balancing end-tag•leaving point between the start-tag and end-tag.•M-x nxml-balanced-close-start-tag-block is similar but for block rather than inline elements:•the start-tag, point, and end-tag are all left on separate lines.•If `nxml-slash-auto-complete-flag' is non-nil, then inserting a `&lt;/'•automatically inserts the rest of the end-tag.••M-x completion-at-point performs completion on the symbol preceding point.••M-x nxml-dynamic-markup-word uses the contents of the current buffer•to choose a tag to put around the word preceding point.••Sections of the document can be displayed in outline form.  The•variable `nxml-section-element-name-regexp' controls when an element•is recognized as a section.  The same key sequences that change•visibility in outline mode are used except that they start with C-c C-o•instead of C-c.••Validation is provided by the related minor-mode `rng-validate-mode'.•This also makes completion schema- and context- sensitive.  Element•names, attribute names, attribute values and namespace URIs can all be•completed. By default, `rng-validate-mode' is automatically enabled.•You can toggle it using M-x rng-validate-mode or change the default by•customizing `rng-nxml-auto-validate-flag'.••TAB indents the current line appropriately.•This can be customized using the variable `nxml-child-indent'•and the variable `nxml-attribute-indent'.••M-x nxml-insert-named-char inserts a character reference using•the character's name (by default, the Unicode name).•C-u M-x nxml-insert-named-char inserts the character directly.••The Emacs commands that normally operate on balanced expressions will•operate on XML markup items.  Thus C-M-f will move forward•across one markup item; C-M-b will move backward across•one markup item; C-M-k will kill the following markup item;•C-M-@ will mark the following markup item.  By default, each•tag each treated as a single markup item; to make the complete element•be treated as a single markup item, set the variable•`nxml-sexp-element-flag' to t.  For more details, see the function•`nxml-forward-balanced-item'.••M-x nxml-backward-up-element and M-x nxml-down-element move up and down the element structure.••Many aspects this mode can be customized using•M-x customize-group nxml RET.••In addition to any hooks its parent mode `text-mode' might have run,•this mode runs the hook `nxml-mode-hook', as the final step•during initialization.",
"occur":"occur is an interactive compiled Lisp function in `replace.el'.••(occur REGEXP &amp;optional NLINES)••Show all lines in the current buffer containing a match for REGEXP.•If a match spreads across multiple lines, all those lines are shown.••Each line is displayed with NLINES lines before and after, or -NLINES•before if NLINES is negative.•NLINES defaults to `list-matching-lines-default-context-lines'.•Interactively it is the prefix arg.••The lines are shown in a buffer named `*Occur*'.•It serves as a menu to find any of the occurrences in this buffer.•h in that buffer will explain how.••If REGEXP contains upper case characters (excluding those preceded by `⧷')•and `search-upper-case' is non-nil, the matching is case-sensitive.••When NLINES is a string or when the function is called•interactively with prefix argument without a number (`C-u' alone•as prefix) the matching strings are collected into the `*Occur*'•buffer by using NLINES as a replacement regexp.  NLINES may•contain ⧷&amp; and ⧷N which convention follows `replace-match'.•For example, providing ⧷&quotedefun⧷s +⧷(⧷S +⧷)⧷&quote for REGEXP and•⧷&quote⧷1⧷&quote for NLINES collects all the function names in a lisp•program.  When there is no parenthesized subexpressions in REGEXP•the entire match is collected.  In any case the searched buffer•is not modified.",
"occur-cease-edit":"occur-cease-edit is an interactive compiled Lisp function in•`replace.el'.••(occur-cease-edit)••Switch from Occur Edit mode to Occur mode.",
"occur-edit-mode":"occur-edit-mode is an interactive compiled Lisp function in•`replace.el'.••(occur-edit-mode)••Parent mode: `occur-mode'.••Major mode for editing *Occur* buffers.•In this mode, changes to the *Occur* buffer are also applied to•the originating buffer.••To return to ordinary Occur mode, use M-x occur-cease-edit.••In addition to any hooks its parent mode `occur-mode' might have run,•this mode runs the hook `occur-edit-mode-hook', as the final step•during initialization.",
"open-line":"open-line is an interactive compiled Lisp function in `simple.el'.••(open-line N)••Insert a newline and leave point before it.•If there is a fill prefix and/or a `left-margin', insert them•on the new line if the line would have been blank.•With arg N, insert N newlines.",
"open-rectangle":"open-rectangle is an interactive autoloaded compiled Lisp function in•`rect.el'.••(open-rectangle START END &amp;optional FILL)••Blank out the region-rectangle, shifting text right.••The text previously in the region is not overwritten by the blanks,•but instead winds up to the right of the rectangle.••When called from a program the rectangle's corners are START and END.•With a prefix (or a FILL) argument, fill with blanks even if there is•no text on the right side of the rectangle.",
"or":"or is a special form in `C source code'.••(or CONDITIONS...)••Eval args until one of them yields non-nil, then return that value.•The remaining args are not evalled at all.•If all args return nil, return nil.",
"org-mode":"org-mode is an interactive autoloaded compiled Lisp function in•`org.el'.••(org-mode)••Parent mode: `outline-mode'.••Outline-based notes management and organizer, alias•⧷&quoteCarsten's outline-mode for keeping track of everything.⧷&quote••Org-mode develops organizational tasks around a NOTES file which•contains information about projects as plain text.  Org-mode is•implemented on top of outline-mode, which is ideal to keep the content•of large files well structured.  It supports ToDo items, deadlines and•time stamps, which magically appear in the diary listing of the Emacs•calendar.  Tables are easily created with a built-in table editor.•Plain text URL-like links connect to websites, emails (VM), Usenet•messages (Gnus), BBDB entries, and any files related to the project.•For printing and sharing of notes, an Org-mode file (or a part of it)•can be exported as a structured ASCII or HTML file.••The following commands are available:••key             binding•---             -------••C-a             org-beginning-of-line•C-c             Prefix Command•C-e             org-end-of-line•TAB             org-cycle•C-j             org-return-indent•C-k             org-kill-line•RET             org-return•C-y             org-yank•ESC             Prefix Command•|               org-force-self-insert•C-#             org-table-rotate-recalc-marks•C-'             org-cycle-agenda-files•C-,             org-cycle-agenda-files•&lt;C-S-down&gt;      org-shiftcontroldown•&lt;C-S-left&gt;      org-shiftcontrolleft•&lt;C-S-return&gt;    org-insert-todo-heading-respect-content•&lt;C-S-right&gt;     org-shiftcontrolright•&lt;C-S-up&gt;        org-shiftcontrolup•&lt;C-return&gt;      org-insert-heading-respect-content•&lt;C-tab&gt;         org-force-cycle-archived•&lt;M-S-down&gt;      org-shiftmetadown•&lt;M-S-left&gt;      org-shiftmetaleft•&lt;M-S-return&gt;    org-insert-todo-heading•&lt;M-S-right&gt;     org-shiftmetaright•&lt;M-S-up&gt;        org-shiftmetaup•&lt;M-down&gt;        org-metadown•&lt;M-left&gt;        org-metaleft•&lt;M-return&gt;      org-meta-return•&lt;M-right&gt;       org-metaright•&lt;M-up&gt;          org-metaup•&lt;S-down&gt;        org-shiftdown•&lt;S-iso-lefttab&gt;                 org-shifttab•&lt;S-left&gt;        org-shiftleft•&lt;S-return&gt;      org-table-copy-down•&lt;S-right&gt;       org-shiftright•&lt;S-tab&gt;         org-shifttab•&lt;S-up&gt;          org-shiftup•&lt;backtab&gt;       org-shifttab•&lt;remap&gt;         Prefix Command•&lt;tab&gt;           org-cycle••C-M-i           pcomplete•M-RET           org-insert-heading•C-M-t           org-transpose-element•M-a             org-backward-sentence•M-e             org-forward-sentence•M-h             org-mark-element•M-{             org-backward-element•M-}             org-forward-element••C-c C-a         org-attach•C-c C-b         org-backward-heading-same-level•C-c C-c         org-ctrl-c-ctrl-c•C-c C-d         org-deadline•C-c C-e         org-export•C-c C-f         org-forward-heading-same-level•C-c C-j         org-goto•C-c C-k         org-kill-note-or-show-branches•C-c C-l         org-insert-link•C-c RET         org-ctrl-c-ret•C-c C-o         org-open-at-point•C-c C-q         org-set-tags-command•C-c C-r         org-reveal•C-c C-s         org-schedule•C-c C-t         org-todo•C-c C-v         Prefix Command•C-c C-w         org-refile•C-c C-x         Prefix Command•C-c C-y         org-evaluate-time-range•C-c C-z         org-add-note•C-c ESC         Prefix Command•C-c C-^         org-up-element•C-c C-_         org-down-element•C-c SPC         org-table-blank-field•C-c !           org-time-stamp-inactive•C-c #           org-update-statistics-cookies•C-c $           org-archive-subtree•C-c %           org-mark-ring-push•C-c &amp;           org-mark-ring-goto•C-c '           org-edit-special•C-c *           org-ctrl-c-star•C-c +           org-table-sum•C-c ,           org-priority•C-c -           org-ctrl-c-minus•C-c .           org-time-stamp•C-c /           org-sparse-tree•C-c :           org-toggle-fixed-width-section•C-c ;           org-toggle-comment•C-c &lt;           org-date-from-calendar•C-c =           org-table-eval-formula•C-c &gt;           org-goto-calendar•C-c ?           org-table-field-info•C-c @           org-mark-subtree•C-c [           org-agenda-file-to-front•C-c ⧷           org-match-sparse-tree•C-c ]           org-remove-file•C-c ^           org-sort•C-c `           org-table-edit-field•C-c {           org-table-toggle-formula-debugger•C-c |           org-table-create-or-convert-from-region•C-c }           org-table-toggle-coordinate-overlays•C-c ~           org-table-create-with-table.el•C-c C-*         org-list-make-subtree••&lt;remap&gt; &lt;delete-backward-char&gt;  org-delete-backward-char•&lt;remap&gt; &lt;delete-char&gt;           org-delete-char•&lt;remap&gt; &lt;outline-backward-same-level&gt;•                                org-backward-heading-same-level•&lt;remap&gt; &lt;outline-demote&gt;        org-demote-subtree•&lt;remap&gt; &lt;outline-forward-same-level&gt;•                                org-forward-heading-same-level•&lt;remap&gt; &lt;outline-insert-heading&gt;•                                org-ctrl-c-ret•&lt;remap&gt; &lt;outline-mark-subtree&gt;  org-mark-subtree•&lt;remap&gt; &lt;outline-promote&gt;       org-promote-subtree•&lt;remap&gt; &lt;self-insert-command&gt;   org-self-insert-command•&lt;remap&gt; &lt;show-branches&gt;         org-kill-note-or-show-branches•&lt;remap&gt; &lt;show-subtree&gt;          org-show-subtree••C-c C-a         show-all•  (that binding is currently shadowed by another mode)•C-c C-b         outline-backward-same-level•  (that binding is currently shadowed by another mode)•C-c C-c         hide-entry•  (that binding is currently shadowed by another mode)•C-c C-d         hide-subtree•  (that binding is currently shadowed by another mode)•C-c C-e         show-entry•  (that binding is currently shadowed by another mode)•C-c C-f         outline-forward-same-level•  (that binding is currently shadowed by another mode)•C-c TAB         show-children•C-c C-k         show-branches•  (that binding is currently shadowed by another mode)•C-c C-l         hide-leaves•  (that binding is currently shadowed by another mode)•C-c RET         outline-insert-heading•  (that binding is currently shadowed by another mode)•C-c C-n         outline-next-visible-heading•C-c C-o         hide-other•  (that binding is currently shadowed by another mode)•C-c C-p         outline-previous-visible-heading•C-c C-q         hide-sublevels•  (that binding is currently shadowed by another mode)•C-c C-s         show-subtree•  (that binding is currently shadowed by another mode)•C-c C-t         hide-body•  (that binding is currently shadowed by another mode)•C-c C-u         outline-up-heading•C-c C-v         outline-move-subtree-down•  (that binding is currently shadowed by another mode)•C-c C-^         outline-move-subtree-up•  (that binding is currently shadowed by another mode)•C-c @           outline-mark-subtree•  (that binding is currently shadowed by another mode)•C-c C-&lt;         outline-promote•C-c C-&gt;         outline-demote••C-M-i           ispell-complete-word•  (that binding is currently shadowed by another mode)••C-c C-M-l       org-insert-all-links••C-c C-v C-a     org-babel-sha1-hash•C-c C-v C-b     org-babel-execute-buffer•C-c C-v C-c     org-babel-check-src-block•C-c C-v C-d     org-babel-demarcate-block•C-c C-v C-e     org-babel-execute-maybe•C-c C-v C-f     org-babel-tangle-file•C-c C-v TAB     org-babel-view-src-block-info•C-c C-v C-j     org-babel-insert-header-arg•C-c C-v C-l     org-babel-load-in-session•C-c C-v C-n     org-babel-next-src-block•C-c C-v C-o     org-babel-open-src-block-result•C-c C-v C-p     org-babel-previous-src-block•C-c C-v C-r     org-babel-goto-named-result•C-c C-v C-s     org-babel-execute-subtree•C-c C-v C-t     org-babel-tangle•C-c C-v C-u     org-babel-goto-src-block-head•C-c C-v C-v     org-babel-expand-src-block•C-c C-v C-x     org-babel-do-key-sequence-in-edit-buffer•C-c C-v C-z     org-babel-switch-to-session•C-c C-v ESC     Prefix Command•C-c C-v I       org-babel-view-src-block-info•C-c C-v a       org-babel-sha1-hash•C-c C-v b       org-babel-execute-buffer•C-c C-v c       org-babel-check-src-block•C-c C-v d       org-babel-demarcate-block•C-c C-v e       org-babel-execute-maybe•C-c C-v f       org-babel-tangle-file•C-c C-v g       org-babel-goto-named-src-block•C-c C-v h       org-babel-describe-bindings•C-c C-v i       org-babel-lob-ingest•C-c C-v j       org-babel-insert-header-arg•C-c C-v l       org-babel-load-in-session•C-c C-v n       org-babel-next-src-block•C-c C-v o       org-babel-open-src-block-result•C-c C-v p       org-babel-previous-src-block•C-c C-v r       org-babel-goto-named-result•C-c C-v s       org-babel-execute-subtree•C-c C-v t       org-babel-tangle•C-c C-v u       org-babel-goto-src-block-head•C-c C-v v       org-babel-expand-src-block•C-c C-v x       org-babel-do-key-sequence-in-edit-buffer•C-c C-v z       org-babel-switch-to-session-with-code••C-c C-x C-a     org-archive-subtree-default•C-c C-x C-b     org-toggle-checkbox•C-c C-x C-c     org-columns•C-c C-x C-d     org-clock-display•C-c C-x C-f     org-emphasize•C-c C-x TAB     org-clock-in•C-c C-x C-j     org-clock-goto•C-c C-x C-l     org-preview-latex-fragment•C-c C-x RET     Prefix Command•C-c C-x C-n     org-next-link•C-c C-x C-o     org-clock-out•C-c C-x C-p     org-previous-link•C-c C-x C-q     org-clock-cancel•C-c C-x C-r     org-clock-report•C-c C-x C-s     org-advertized-archive-subtree•C-c C-x C-t     org-toggle-time-stamp-overlays•C-c C-x C-u     org-dblock-update•C-c C-x C-v     org-toggle-inline-images•C-c C-x C-w     org-cut-special•C-c C-x C-x     org-clock-in-last•C-c C-x C-y     org-paste-special•C-c C-x C-z     org-resolve-clocks•C-c C-x ESC     Prefix Command•C-c C-x !       org-reload•C-c C-x ,       org-timer-pause-or-continue•C-c C-x -       org-timer-item•C-c C-x .       org-timer•C-c C-x 0       org-timer-start•C-c C-x :       org-timer-cancel-timer•C-c C-x ;       org-timer-set-timer•C-c C-x &lt;       org-agenda-set-restriction-lock•C-c C-x &gt;       org-agenda-remove-restriction-lock•C-c C-x A       org-archive-to-archive-sibling•C-c C-x E       org-inc-effort•C-c C-x G       org-feed-goto-inbox•C-c C-x [       org-reftex-citation•C-c C-x ⧷       org-toggle-pretty-entities•C-c C-x _       org-timer-stop•C-c C-x a       org-toggle-archive-tag•C-c C-x b       org-tree-to-indirect-buffer•C-c C-x c       org-clone-subtree-with-time-shift•C-c C-x d       org-insert-drawer•C-c C-x e       org-set-effort•C-c C-x f       org-footnote-action•C-c C-x g       org-feed-update-all•C-c C-x i       org-insert-columns-dblock•C-c C-x o       org-toggle-ordered-property•C-c C-x p       org-set-property•C-c C-x v       org-copy-visible••C-c C-v C-M-h   org-babel-mark-block••C-c C-x C-M-v   org-redisplay-inline-images•C-c C-x M-w     org-copy-special••C-c C-x RET g   org-mobile-pull•C-c C-x RET p   org-mobile-push••••In addition to any hooks its parent mode `outline-mode' might have run,•this mode runs the hook `org-mode-hook', as the final step•during initialization.",
"org-return":"org-return is an interactive compiled Lisp function in `org.el'.••(org-return &amp;optional INDENT)••Goto next table row or insert a newline.•Calls `org-table-next-row' or `newline', depending on context.•See the individual commands for more information.",
"org-self-insert-command":"org-self-insert-command is an interactive compiled Lisp function in•`org.el'.••(org-self-insert-command N)••Like `self-insert-command', use overwrite-mode for whitespace in tables.•If the cursor is in a table looking at whitespace, the whitespace is•overwritten, and the table is not marked as requiring realignment.",
"org-time-stamp":"org-time-stamp is an interactive compiled Lisp function in `org.el'.••(org-time-stamp ARG &amp;optional INACTIVE)••Prompt for a date/time and insert a time stamp.•If the user specifies a time like HH:MM or if this command is•called with at least one prefix argument, the time stamp contains•the date and the time.  Otherwise, only the date is be included.••All parts of a date not specified by the user is filled in from•the current date/time.  So if you just press return without•typing anything, the time stamp will represent the current•date/time.••If there is already a timestamp at the cursor, it will be•modified.••With two universal prefix arguments, insert an active timestamp•with the current time without prompting the user.",
"other-window":"other-window is an interactive compiled Lisp function in `window.el'.••(other-window COUNT &amp;optional ALL-FRAMES)••Select another window in cyclic ordering of windows.•COUNT specifies the number of windows to skip, starting with the•selected window, before making the selection.  If COUNT is•positive, skip COUNT windows forwards.  If COUNT is negative,•skip -COUNT windows backwards.  COUNT zero means do not skip any•window, so select the selected window.  In an interactive call,•COUNT is the numeric prefix argument.  Return nil.••If the `other-window' parameter of the selected window is a•function and `ignore-window-parameters' is nil, call that•function with the arguments COUNT and ALL-FRAMES.••This function does not select a window whose `no-other-window'•window parameter is non-nil.••This function uses `next-window' for finding the window to•select.  The argument ALL-FRAMES has the same meaning as in•`next-window', but the MINIBUF argument of `next-window' is•always effectively nil.",
"outline-mode":"outline-mode is an interactive autoloaded compiled Lisp function in•`outline.el'.••(outline-mode)••Parent mode: `text-mode'.••Set major mode for editing outlines with selective display.•Headings are lines which start with asterisks: one for major headings,•two for subheadings, etc.  Lines not starting with asterisks are body lines.••Body text or subheadings under a heading can be made temporarily•invisible, or visible again.  Invisible lines are attached to the end•of the heading, so they move with it, if the line is killed and yanked•back.  A heading with text hidden under it is marked with an ellipsis (...).••Commands:•C-c C-n   outline-next-visible-heading      move by visible headings•C-c C-p   outline-previous-visible-heading•C-c C-f   outline-forward-same-level        similar but skip subheadings•C-c C-b   outline-backward-same-level•C-c C-u   outline-up-heading		    move from subheading to heading••C-c C-t	make all text invisible (not headings).•C-c C-a	make everything in buffer visible.•C-c C-q  make only the first N levels of headers visible.••The remaining commands are used when point is on a heading line.•They apply to some of the body or subheadings of that heading.•C-c C-d   hide-subtree	make body and subheadings invisible.•C-c C-s   show-subtree	make body and subheadings visible.•C-c TAB   show-children	make direct subheadings visible.•		 No effect on body, or subheadings 2 or more levels down.•		 With arg N, affects subheadings N levels down.•C-c C-c	   make immediately following body invisible.•C-c C-e	   make it visible.•C-c C-l	   make body under heading and under its subheadings invisible.•		     The subheadings remain visible.•C-c C-k  make all subheadings at all levels visible.••The variable `outline-regexp' can be changed to control what is a heading.•A line is a heading if `outline-regexp' matches something at the•beginning of the line.  The longer the match, the deeper the level.••Turning on outline mode calls the value of `text-mode-hook' and then of•`outline-mode-hook', if they are non-nil.",
"package-menu-execute":"package-menu-execute is an interactive compiled Lisp function in•`package.el'.••(package-menu-execute)••Perform marked Package Menu actions.•Packages marked for installation are downloaded and installed;•packages marked for deletion are removed.",
"package-menu-mark-delete":"package-menu-mark-delete is an interactive compiled Lisp function in•`package.el'.••(package-menu-mark-delete &amp;optional NUM)••Mark a package for deletion and move to the next line.",
"package-menu-mark-install":"package-menu-mark-install is an interactive compiled Lisp function in•`package.el'.••(package-menu-mark-install &amp;optional NUM)••Mark a package for installation and move to the next line.",
"package-menu-mark-unmark":"package-menu-mark-unmark is an interactive compiled Lisp function in•`package.el'.••(package-menu-mark-unmark &amp;optional NUM)••Clear any marks on a package and move to the next line.",
"package-menu-mode":"package-menu-mode is an interactive compiled Lisp function in•`package.el'.••(package-menu-mode)••Parent mode: `tabulated-list-mode'.••Major mode for browsing a list of packages.•Letters do not insert themselves; instead, they are commands.••key             binding•---             -------••TAB             forward-button•RET             package-menu-describe-package•ESC             Prefix Command•SPC             scroll-up-command•-               negative-argument•0 .. 9          digit-argument•&lt;               beginning-of-buffer•&gt;               end-of-buffer•?               package-menu-describe-package•S               tabulated-list-sort•U               package-menu-mark-upgrades•d               package-menu-mark-delete•g               revert-buffer•h               package-menu-quick-help•i               package-menu-mark-install•n               next-line•p               previous-line•q               quit-window•r               package-menu-refresh•u               package-menu-mark-unmark•x               package-menu-execute•~               package-menu-mark-obsolete-for-deletion•DEL             package-menu-backup-unmark•&lt;backtab&gt;       backward-button•&lt;follow-link&gt;   mouse-face•&lt;mouse-2&gt;       mouse-select-window•&lt;remap&gt;         Prefix Command••C-M-i           backward-button••••In addition to any hooks its parent mode `tabulated-list-mode' might have run,•this mode runs the hook `package-menu-mode-hook', as the final step•during initialization.",
"package-menu-refresh":"package-menu-refresh is an interactive compiled Lisp function in•`package.el'.••(package-menu-refresh)••Download the Emacs Lisp package archive.•This fetches the contents of each archive specified in•`package-archives', and then refreshes the package menu.",
"page-break-lines-mode":"page-break-lines-mode is an interactive Lisp function in•`page-break-lines.el'.••(page-break-lines-mode &amp;optional ARG)••Toggle Page Break Lines mode.••In Page Break mode, page breaks (^L characters) are displayed as a•horizontal line of `page-break-string-char' characters.",
"parse-time-string":"parse-time-string is an autoloaded Lisp function in `parse-time.el'.••[Arg list not available until function definition is loaded.]••Not documented.",
"perl-mode":"perl-mode is an interactive autoloaded compiled Lisp function in•`perl-mode.el'.••(perl-mode)••Parent mode: `prog-mode'.••Major mode for editing Perl code.•Expression and list commands understand all Perl brackets.•Tab indents for Perl code.•Comments are delimited with # ... ⧷n.•Paragraphs are separated by blank lines only.•Delete converts tabs to spaces as it moves back.•key             binding•---             -------••TAB             perl-indent-command•ESC             Prefix Command•: .. ;          perl-electric-terminator•{               perl-electric-terminator•}               perl-electric-terminator•DEL             backward-delete-char-untabify••C-M-a           perl-beginning-of-function•C-M-e           perl-end-of-function•C-M-h           perl-mark-function•C-M-q           perl-indent-exp•••Variables controlling indentation style:• `perl-tab-always-indent'•    Non-nil means TAB in Perl mode should always indent the current line,•    regardless of where in the line point is when the TAB command is used.• `perl-tab-to-comment'•    Non-nil means that for lines which don't need indenting, TAB will•    either delete an empty comment, indent an existing comment, move•    to end-of-line, or if at end-of-line already, create a new comment.• `perl-nochange'•    Lines starting with this regular expression are not auto-indented.• `perl-indent-level'•    Indentation of Perl statements within surrounding block.•    The surrounding block's indentation is the indentation•    of the line on which the open-brace appears.• `perl-continued-statement-offset'•    Extra indentation given to a substatement, such as the•    then-clause of an if or body of a while.• `perl-continued-brace-offset'•    Extra indentation given to a brace that starts a substatement.•    This is in addition to `perl-continued-statement-offset'.• `perl-brace-offset'•    Extra indentation for line if it starts with an open brace.• `perl-brace-imaginary-offset'•    An open brace following other text is treated as if it were•    this far to the right of the start of its line.• `perl-label-offset'•    Extra indentation for line that is a label.• `perl-indent-continued-arguments'•    Offset of argument lines relative to usual indentation.••Various indentation styles:       K&amp;R  BSD  BLK  GNU  LW•  perl-indent-level                5    8    0    2    4•  perl-continued-statement-offset  5    8    4    2    4•  perl-continued-brace-offset      0    0    0    0   -4•  perl-brace-offset               -5   -8    0    0    0•  perl-brace-imaginary-offset      0    0    4    0    0•  perl-label-offset               -5   -8   -2   -2   -2••Turning on Perl mode runs the normal hook `perl-mode-hook'.",
"picture-mode":"picture-mode is an interactive autoloaded compiled Lisp function in•`picture.el'.••(picture-mode)••Switch to Picture mode, in which a quarter-plane screen model is used.••Printing characters replace instead of inserting themselves with motion•afterwards settable by these commands:•• Move left after insertion:            C-c &lt;• Move right after insertion:           C-c &gt;• Move up after insertion:              C-c ^• Move down after insertion:            C-c .•• Move northwest (nw) after insertion:  C-c `• Move northeast (ne) after insertion:  C-c '• Move southwest (sw) after insertion:  C-c /• Move southeast (se) after insertion:  C-c ⧷•• Move westnorthwest (wnw) after insertion:  C-u C-c `• Move eastnortheast (ene) after insertion:  C-u C-c '• Move westsouthwest (wsw) after insertion:  C-u C-c /• Move eastsoutheast (ese) after insertion:  C-u C-c ⧷••The current direction is displayed in the mode line.  The initial•direction is right.  Whitespace is inserted and tabs are changed to•spaces when required by movement.  You can move around in the buffer•with these commands:•• Move vertically to SAME column in previous line: &lt;down&gt;• Move vertically to SAME column in next line:     &lt;up&gt;• Move to column following last•  non-whitespace character:                       M-x picture-end-of-line• Move right, inserting spaces if required:        &lt;right&gt;• Move left changing tabs to spaces if required:   &lt;left&gt;• Move in direction of current picture motion:     C-c C-f• Move opposite to current picture motion:         C-c C-b• Move to beginning of next line:                  &lt;down&gt;••You can edit tabular text with these commands:•• Move to column beneath (or at) next interesting•  character (see variable `picture-tab-chars'):   C-M-i• Move to next stop in tab stop list:              TAB• Set tab stops according to context of this line: C-c TAB•   (With ARG, resets tab stops to default value.)• Change the tab stop list:                        M-x edit-tab-stops••You can manipulate text with these commands:• Clear ARG columns after point without moving:    M-x picture-clear-column• Delete char at point:                            C-c C-d• Clear ARG columns backward:                      DEL• Clear ARG lines, advancing over them:            &lt;deleteline&gt;•  (the cleared text is saved in the kill ring)• Open blank line(s) beneath current line:         &lt;insertline&gt;••You can manipulate rectangles with these commands:•  Clear a rectangle and save it:                  C-c C-k•  Clear a rectangle, saving in a named register:  C-c C-w•  Insert currently saved rectangle at point:      C-c C-y•  Insert rectangle from named register:           C-c C-x•  Draw a rectangular box around mark and point:   C-c C-r•  Copies a rectangle to a register:               C-x r r•  Undo effects of rectangle overlay commands:     C-x u••You can return to the previous mode with C-c C-c, which•also strips trailing whitespace from every line.  Stripping is suppressed•by supplying an argument.••Entry to this mode calls the value of `picture-mode-hook' if non-nil.••Note that Picture mode commands will work outside of Picture mode, but•they are not by default assigned to keys.",
"point":"point is a built-in function in `C source code'.••(point)••Return value of point, as an integer.•Beginning of buffer is position (point-min).",
"point-max":"point-max is a built-in function in `C source code'.••(point-max)••Return the maximum permissible value of point in the current buffer.•This is (1+ (buffer-size)), unless narrowing (a buffer restriction)•is in effect, in which case it is less.",
"point-min":"point-min is a built-in function in `C source code'.••(point-min)••Return the minimum permissible value of point in the current buffer.•This is 1, unless narrowing (a buffer restriction) is in effect.",
"pop":"pop is a Lisp macro in `subr.el'.••(pop PLACE)••Return the first element of PLACE's value, and remove it from the list.•PLACE must be a generalized variable whose value is a list.•If the value is nil, `pop' returns nil but does not actually•change the list.",
"pop-global-mark":"pop-global-mark is an interactive compiled Lisp function in•`simple.el'.••(pop-global-mark)••Pop off global mark ring and jump to the top location.",
"prefix-numeric-value":"prefix-numeric-value is a built-in function in `C source code'.••(prefix-numeric-value RAW)••Return numeric meaning of raw prefix argument RAW.•A raw prefix argument is what you get from `(interactive ⧷&quoteP⧷&quote)'.•Its numeric meaning is what you would get from `(interactive ⧷&quotep⧷&quote)'.",
"previous-buffer":"previous-buffer is an interactive compiled Lisp function in•`window.el'.••(previous-buffer)••In selected window switch to previous buffer.",
"previous-history-element":"previous-history-element is an interactive compiled Lisp function in•`simple.el'.••(previous-history-element N)••Puts previous element of the minibuffer history in the minibuffer.•With argument N, it uses the Nth previous element.",
"previous-line":"previous-line is an interactive compiled Lisp function in `simple.el'.••(previous-line &amp;optional ARG TRY-VSCROLL)••Move cursor vertically up ARG lines.•Interactively, vscroll tall lines if `auto-window-vscroll' is enabled.•If there is no character in the target line exactly over the current column,•the cursor is positioned after the character in that line which spans this•column, or at the end of the line if it is not long enough.••If the variable `line-move-visual' is non-nil, this command moves•by display lines.  Otherwise, it moves by buffer lines, without•taking variable-width characters or continued lines into account.••The command C-x C-n can be used to create•a semipermanent goal column for this command.•Then instead of trying to move exactly vertically (or as close as possible),•this command moves to the specified goal column (or as close as possible).•The goal column is stored in the variable `goal-column', which is nil•when there is no goal column.  Note that setting `goal-column'•overrides `line-move-visual' and causes this command to move by buffer•lines rather than by display lines.••If you are thinking of using this in a Lisp program, consider using•`forward-line' with a negative argument instead.  It is usually easier•to use and more reliable (no dependence on goal column, etc.).••This function is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `previous-line'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-previous-line-keymap'.•",
"previous-matching-history-element":"previous-matching-history-element is an interactive compiled Lisp•function in `simple.el'.••(previous-matching-history-element REGEXP N)••Find the previous history element that matches REGEXP.•(Previous history elements refer to earlier actions.)•With prefix argument N, search for Nth previous match.•If N is negative, find the next or Nth next match.•Normally, history elements are matched case-insensitively if•`case-fold-search' is non-nil, but an uppercase letter in REGEXP•makes the search case-sensitive.•See also `minibuffer-history-case-insensitive-variables'.",
"prin1":"prin1 is a built-in function in `C source code'.••(prin1 OBJECT &amp;optional PRINTCHARFUN)••Output the printed representation of OBJECT, any Lisp object.•Quoting characters are printed when needed to make output that `read'•can handle, whenever this is possible.  For complex objects, the behavior•is controlled by `print-level' and `print-length', which see.••OBJECT is any of the Lisp data types: a number, a string, a symbol,•a list, a buffer, a window, a frame, etc.••A printed representation of an object is text which describes that object.••Optional argument PRINTCHARFUN is the output stream, which can be one•of these:••   - a buffer, in which case output is inserted into that buffer at point;•   - a marker, in which case output is inserted at marker's position;•   - a function, in which case that function is called once for each•     character of OBJECT's printed representation;•   - a symbol, in which case that symbol's function definition is called; or•   - t, in which case the output is displayed in the echo area.••If PRINTCHARFUN is omitted, the value of `standard-output' (which see)•is used instead.",
"princ":"princ is a built-in function in `C source code'.••(princ OBJECT &amp;optional PRINTCHARFUN)••Output the printed representation of OBJECT, any Lisp object.•No quoting characters are used; no delimiters are printed around•the contents of strings.••OBJECT is any of the Lisp data types: a number, a string, a symbol,•a list, a buffer, a window, a frame, etc.••A printed representation of an object is text which describes that object.••Optional argument PRINTCHARFUN is the output stream, which can be one•of these:••   - a buffer, in which case output is inserted into that buffer at point;•   - a marker, in which case output is inserted at marker's position;•   - a function, in which case that function is called once for each•     character of OBJECT's printed representation;•   - a symbol, in which case that symbol's function definition is called; or•   - t, in which case the output is displayed in the echo area.••If PRINTCHARFUN is omitted, the value of `standard-output' (which see)•is used instead.",
"print":"print is a built-in function in `C source code'.••(print OBJECT &amp;optional PRINTCHARFUN)••Output the printed representation of OBJECT, with newlines around it.•Quoting characters are printed when needed to make output that `read'•can handle, whenever this is possible.  For complex objects, the behavior•is controlled by `print-level' and `print-length', which see.••OBJECT is any of the Lisp data types: a number, a string, a symbol,•a list, a buffer, a window, a frame, etc.••A printed representation of an object is text which describes that object.••Optional argument PRINTCHARFUN is the output stream, which can be one•of these:••   - a buffer, in which case output is inserted into that buffer at point;•   - a marker, in which case output is inserted at marker's position;•   - a function, in which case that function is called once for each•     character of OBJECT's printed representation;•   - a symbol, in which case that symbol's function definition is called; or•   - t, in which case the output is displayed in the echo area.••If PRINTCHARFUN is omitted, the value of `standard-output' (which see)•is used instead.",
"proced":"proced is an interactive autoloaded compiled Lisp function in•`proced.el'.••(proced &amp;optional ARG)••Generate a listing of UNIX system processes.••If invoked with optional ARG, do not select the window displaying•the process information.••This function runs the normal hook `proced-post-display-hook'.••See `proced-mode' for a description of features available in•Proced buffers.",
"progn":"progn is a special form in `C source code'.••(progn BODY...)••Eval BODY forms sequentially and return value of last one.",
"provide":"provide is a built-in function in `C source code'.••(provide FEATURE &amp;optional SUBFEATURES)••Announce that FEATURE is a feature of the current Emacs.•The optional argument SUBFEATURES should be a list of symbols listing•particular subfeatures supported in this version of FEATURE.",
"push":"push is a Lisp macro in `subr.el'.••(push NEWELT PLACE)••Add NEWELT to the list stored in the generalized variable PLACE.•This is morally equivalent to (setf PLACE (cons NEWELT PLACE)),•except that PLACE is only evaluated once (after NEWELT).",
"push-mark":"push-mark is a compiled Lisp function in `simple.el'.••(push-mark &amp;optional LOCATION NOMSG ACTIVATE)••Set mark at LOCATION (point, by default) and push old mark on mark ring.•If the last global mark pushed was not in the current buffer,•also push LOCATION on the global mark ring.•Display `Mark set' unless the optional second arg NOMSG is non-nil.••Novice Emacs Lisp programmers often try to use the mark for the wrong•purposes.  See the documentation of `set-mark' for more information.••In Transient Mark mode, activate mark if optional third arg ACTIVATE non-nil.",
"put":"put is a built-in function in `C source code'.••(put SYMBOL PROPNAME VALUE)••Store SYMBOL's PROPNAME property with value VALUE.•It can be retrieved with `(get SYMBOL PROPNAME)'.",
"puthash":"puthash is a built-in function in `C source code'.••(puthash KEY VALUE TABLE)••Associate KEY with VALUE in hash table TABLE.•If KEY is already present in table, replace its current value with•VALUE.  In any case, return VALUE.",
"python-mode":"python-mode is an interactive autoloaded compiled Lisp function in•`python.el'.••(python-mode)••Parent mode: `prog-mode'.••Major mode for editing Python files.••key             binding•---             -------••C-c             Prefix Command•ESC             Prefix Command•:               python-indent-electric-colon•DEL             python-indent-dedent-line-backspace•&lt;backtab&gt;       python-indent-dedent-line•&lt;remap&gt;         Prefix Command••C-M-i           completion-at-point•C-M-x           python-shell-send-defun••C-c C-c         python-shell-send-buffer•C-c C-f         python-eldoc-at-point•C-c C-j         imenu•C-c C-l         python-shell-send-file•C-c C-p         run-python•C-c C-r         python-shell-send-region•C-c C-s         python-shell-send-string•C-c C-t         Prefix Command•C-c C-v         python-check•C-c C-z         python-shell-switch-to-shell•C-c &lt;           python-indent-shift-left•C-c &gt;           python-indent-shift-right••&lt;remap&gt; &lt;backward-sentence&gt;     python-nav-backward-block•&lt;remap&gt; &lt;backward-up-list&gt;      python-nav-backward-up-list•&lt;remap&gt; &lt;forward-sentence&gt;      python-nav-forward-block••C-M-q           prog-indent-sexp••C-c C-t c       python-skeleton-class•C-c C-t d       python-skeleton-def•C-c C-t f       python-skeleton-for•C-c C-t i       python-skeleton-if•C-c C-t t       python-skeleton-try•C-c C-t w       python-skeleton-while•••Entry to this mode calls the value of `python-mode-hook'•if that value is non-nil.",
"query-replace":"query-replace is an interactive compiled Lisp function in•`replace.el'.••(query-replace FROM-STRING TO-STRING &amp;optional DELIMITED START END)••Replace some occurrences of FROM-STRING with TO-STRING.•As each match is found, the user must type a character saying•what to do with it.  For directions, type &lt;help&gt; at that time.••In Transient Mark mode, if the mark is active, operate on the contents•of the region.  Otherwise, operate from point to the end of the buffer.••Use M-n to pull the last incremental search string to the minibuffer•that reads FROM-STRING, or invoke replacements from•incremental search with a key sequence like `C-s C-s M-%'•to use its current search string as the string to replace.••Matching is independent of case if `case-fold-search' is non-nil and•FROM-STRING has no uppercase letters.  Replacement transfers the case•pattern of the old text to the new text, if `case-replace' and•`case-fold-search' are non-nil and FROM-STRING has no uppercase•letters.  (Transferring the case pattern means that if the old text•matched is all caps, or capitalized, then its replacement is upcased•or capitalized.)••If `replace-lax-whitespace' is non-nil, a space or spaces in the string•to be replaced will match a sequence of whitespace chars defined by the•regexp in `search-whitespace-regexp'.••Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace•only matches surrounded by word boundaries.•Fourth and fifth arg START and END specify the region to operate on.••To customize possible responses, change the ⧷&quotebindings⧷&quote in `query-replace-map'.",
"query-replace-regexp":"query-replace-regexp is an interactive compiled Lisp function in•`replace.el'.••(query-replace-regexp REGEXP TO-STRING &amp;optional DELIMITED START END)••Replace some things after point matching REGEXP with TO-STRING.•As each match is found, the user must type a character saying•what to do with it.  For directions, type &lt;help&gt; at that time.••In Transient Mark mode, if the mark is active, operate on the contents•of the region.  Otherwise, operate from point to the end of the buffer.••Use M-n to pull the last incremental search regexp to the minibuffer•that reads REGEXP, or invoke replacements from•incremental search with a key sequence like `C-M-s C-M-s C-M-%'•to use its current search regexp as the regexp to replace.••Matching is independent of case if `case-fold-search' is non-nil and•REGEXP has no uppercase letters.  Replacement transfers the case•pattern of the old text to the new text, if `case-replace' and•`case-fold-search' are non-nil and REGEXP has no uppercase letters.•(Transferring the case pattern means that if the old text matched is•all caps, or capitalized, then its replacement is upcased or•capitalized.)••If `replace-regexp-lax-whitespace' is non-nil, a space or spaces in the regexp•to be replaced will match a sequence of whitespace chars defined by the•regexp in `search-whitespace-regexp'.••Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace•only matches surrounded by word boundaries.•Fourth and fifth arg START and END specify the region to operate on.••In TO-STRING, `⧷&amp;' stands for whatever matched the whole of REGEXP,•and `⧷N' (where N is a digit) stands for•whatever what matched the Nth `⧷(...⧷)' in REGEXP.•`⧷?' lets you edit the replacement text in the minibuffer•at the given position for each replacement.••In interactive calls, the replacement text can contain `⧷,'•followed by a Lisp expression.  Each•replacement evaluates that expression to compute the replacement•string.  Inside of that expression, `⧷&amp;' is a string denoting the•whole match as a string, `⧷N' for a partial match, `⧷#&amp;' and `⧷#N'•for the whole or a partial match converted to a number with•`string-to-number', and `⧷#' itself for the number of replacements•done so far (starting with zero).••If the replacement expression is a symbol, write a space after it•to terminate it.  One space there, if any, will be discarded.••When using those Lisp features interactively in the replacement•text, TO-STRING is actually made a list instead of a string.•Use C-x M-: after this command for details.",
"quote":"quote is a special form in `C source code'.••(quote ARG)••Return the argument, without evaluating it.  `(quote x)' yields `x'.•Warning: `quote' does not construct its return value, but just returns•the value that was pre-constructed by the Lisp reader (see info node•`(elisp)Printed Representation').•This means that '(a . b) is not identical to (cons 'a 'b): the former•does not cons.  Quoting should be reserved for constants that will•never be modified by side-effects, unless you like self-modifying code.•See the common pitfall in info node `(elisp)Rearrangement' for an example•of unexpected results when a quoted object is modified.",
"quoted-insert":"quoted-insert is an interactive compiled Lisp function in `simple.el'.••(quoted-insert ARG)••Read next input character and insert it.•This is useful for inserting control characters.•With argument, insert ARG copies of the character.••If the first character you type after this command is an octal digit,•you should type a sequence of octal digits which specify a character code.•Any nondigit terminates the sequence.  If the terminator is a RET,•it is discarded; any other terminator is used itself as input.•The variable `read-quoted-char-radix' specifies the radix for this feature;•set it to 10 or 16 to use decimal or hex instead of octal.••In overwrite mode, this function inserts the character anyway, and•does not handle octal digits specially.  This means that if you use•overwrite as your normal editing mode, you can use this function to•insert characters when necessary.••In binary overwrite mode, this function does overwrite, and octal•digits are interpreted as a character code.  This is intended to be•useful for editing binary files.",
"rainbow-mode":"rainbow-mode is an interactive autoloaded Lisp function in•`rainbow-mode.el'.••(rainbow-mode &amp;optional ARG)••Colorize strings that represent colors.•This will fontify with colors the string like ⧷&quote#aabbcc⧷&quote or ⧷&quoteblue⧷&quote.",
"random":"random is a built-in function in `C source code'.••(random &amp;optional LIMIT)••Return a pseudo-random number.•All integers representable in Lisp, i.e. between `most-negative-fixnum'•and `most-positive-fixnum', inclusive, are equally likely.••With positive integer LIMIT, return random number in interval [0,LIMIT).•With argument t, set the random number seed from the current time and pid.•With a string argument, set the seed based on the string's contents.•Other values of LIMIT are ignored.••See Info node `(elisp)Random Numbers' for more details.",
"rassoc":"rassoc is a built-in function in `C source code'.••(rassoc KEY LIST)••Return non-nil if KEY is `equal' to the cdr of an element of LIST.•The value is actually the first element of LIST whose cdr equals KEY.",
"read":"read is a built-in function in `C source code'.••(read &amp;optional STREAM)••Read one Lisp expression as text from STREAM, return as Lisp object.•If STREAM is nil, use the value of `standard-input' (which see).•STREAM or the value of `standard-input' may be:• a buffer (read from point and advance it)• a marker (read from where it points and advance it)• a function (call it with no arguments for each character,•     call it with a char as argument to push a char back)• a string (takes text from string, starting at the beginning)• t (read text line using minibuffer and use it, or read from•    standard input in batch mode).",
"read-directory-name":"read-directory-name is a compiled Lisp function in `files.el'.••(read-directory-name PROMPT &amp;optional DIR DEFAULT-DIRNAME MUSTMATCH•INITIAL)••Read directory name, prompting with PROMPT and completing in directory DIR.•Value is not expanded---you must call `expand-file-name' yourself.•Default name to DEFAULT-DIRNAME if user exits with the same•non-empty string that was inserted by this function.• (If DEFAULT-DIRNAME is omitted, DIR combined with INITIAL is used,•  or just DIR if INITIAL is nil.)•If the user exits with an empty minibuffer, this function returns•an empty string.  (This can only happen if the user erased the•pre-inserted contents or if `insert-default-directory' is nil.)•Fourth arg MUSTMATCH non-nil means require existing directory's name.• Non-nil and non-t means also require confirmation after completion.•Fifth arg INITIAL specifies text to start with.•DIR should be an absolute directory name.  It defaults to•the value of `default-directory'.",
"read-file-name":"read-file-name is a compiled Lisp function in `minibuffer.el'.••(read-file-name PROMPT &amp;optional DIR DEFAULT-FILENAME MUSTMATCH•INITIAL PREDICATE)••Read file name, prompting with PROMPT and completing in directory DIR.•Value is not expanded---you must call `expand-file-name' yourself.••DIR is the directory to use for completing relative file names.•It should be an absolute directory name, or nil (which means the•current buffer's value of `default-directory').••DEFAULT-FILENAME specifies the default file name to return if the•user exits the minibuffer with the same non-empty string inserted•by this function.  If DEFAULT-FILENAME is a string, that serves•as the default.  If DEFAULT-FILENAME is a list of strings, the•first string is the default.  If DEFAULT-FILENAME is omitted or•nil, then if INITIAL is non-nil, the default is DIR combined with•INITIAL; otherwise, if the current buffer is visiting a file,•that file serves as the default; otherwise, the default is simply•the string inserted into the minibuffer.••If the user exits with an empty minibuffer, return an empty•string.  (This happens only if the user erases the pre-inserted•contents, or if `insert-default-directory' is nil.)••Fourth arg MUSTMATCH can take the following values:•- nil means that the user can exit with any input.•- t means that the user is not allowed to exit unless•  the input is (or completes to) an existing file.•- `confirm' means that the user can exit with any input, but she needs•  to confirm her choice if the input is not an existing file.•- `confirm-after-completion' means that the user can exit with any•  input, but she needs to confirm her choice if she called•  `minibuffer-complete' right before `minibuffer-complete-and-exit'•  and the input is not an existing file.•- anything else behaves like t except that typing RET does not exit if it•  does non-null completion.••Fifth arg INITIAL specifies text to start with.••Sixth arg PREDICATE, if non-nil, should be a function of one•argument; then a file name is considered an acceptable completion•alternative only if PREDICATE returns non-nil with the file name•as its argument.••If this command was invoked with the mouse, use a graphical file•dialog if `use-dialog-box' is non-nil, and the window system or X•toolkit in use provides a file dialog box, and DIR is not a•remote file.  For graphical file dialogs, any of the special values•of MUSTMATCH `confirm' and `confirm-after-completion' are•treated as equivalent to nil.  Some graphical file dialogs respect•a MUSTMATCH value of t, and some do not (or it only has a cosmetic•effect, and does not actually prevent the user from entering a•non-existent file).••See also `read-file-name-completion-ignore-case'•and `read-file-name-function'.",
"read-from-minibuffer":"read-from-minibuffer is a built-in function in `C source code'.••(read-from-minibuffer PROMPT &amp;optional INITIAL-CONTENTS KEYMAP READ•HIST DEFAULT-VALUE INHERIT-INPUT-METHOD)••Read a string from the minibuffer, prompting with string PROMPT.•The optional second arg INITIAL-CONTENTS is an obsolete alternative to•  DEFAULT-VALUE.  It normally should be nil in new code, except when•  HIST is a cons.  It is discussed in more detail below.••Third arg KEYMAP is a keymap to use whilst reading;•  if omitted or nil, the default is `minibuffer-local-map'.••If fourth arg READ is non-nil, interpret the result as a Lisp object•  and return that object:•  in other words, do `(car (read-from-string INPUT-STRING))'••Fifth arg HIST, if non-nil, specifies a history list and optionally•  the initial position in the list.  It can be a symbol, which is the•  history list variable to use, or a cons cell (HISTVAR . HISTPOS).•  In that case, HISTVAR is the history list variable to use, and•  HISTPOS is the initial position for use by the minibuffer history•  commands.  For consistency, you should also specify that element of•  the history as the value of INITIAL-CONTENTS.  Positions are counted•  starting from 1 at the beginning of the list.••Sixth arg DEFAULT-VALUE, if non-nil, should be a string, which is used•  as the default to `read' if READ is non-nil and the user enters•  empty input.  But if READ is nil, this function does _not_ return•  DEFAULT-VALUE for empty input!  Instead, it returns the empty string.••  Whatever the value of READ, DEFAULT-VALUE is made available via the•  minibuffer history commands.  DEFAULT-VALUE can also be a list of•  strings, in which case all the strings are available in the history,•  and the first string is the default to `read' if READ is non-nil.••Seventh arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits• the current input method and the setting of `enable-multibyte-characters'.••If the variable `minibuffer-allow-text-properties' is non-nil,• then the string which is returned includes whatever text properties• were present in the minibuffer.  Otherwise the value has no text properties.••The remainder of this documentation string describes the•INITIAL-CONTENTS argument in more detail.  It is only relevant when•studying existing code, or when HIST is a cons.  If non-nil,•INITIAL-CONTENTS is a string to be inserted into the minibuffer before•reading input.  Normally, point is put at the end of that string.•However, if INITIAL-CONTENTS is (STRING . POSITION), the initial•input is STRING, but point is placed at _one-indexed_ position•POSITION in the minibuffer.  Any integer value less than or equal to•one puts point at the beginning of the string.  *Note* that this•behavior differs from the way such arguments are used in `completing-read'•and some related functions, which use zero-indexing for POSITION.",
"read-regexp":"read-regexp is a compiled Lisp function in `replace.el'.••(read-regexp PROMPT &amp;optional DEFAULTS HISTORY)••Read and return a regular expression as a string.•When PROMPT doesn't end with a colon and space, it adds a final ⧷&quote: ⧷&quote.•If DEFAULTS is non-nil, it displays the first default in the prompt.••Non-nil optional arg DEFAULTS is a string or a list of strings that•are prepended to a list of standard default values, which include the•string at point, the last isearch regexp, the last isearch string, and•the last replacement regexp.••Non-nil HISTORY is a symbol to use for the history list.•If HISTORY is nil, `regexp-history' is used.",
"read-string":"read-string is a built-in function in `C source code'.••(read-string PROMPT &amp;optional INITIAL-INPUT HISTORY DEFAULT-VALUE•INHERIT-INPUT-METHOD)••Read a string from the minibuffer, prompting with string PROMPT.•If non-nil, second arg INITIAL-INPUT is a string to insert before reading.•  This argument has been superseded by DEFAULT-VALUE and should normally•  be nil in new code.  It behaves as in `read-from-minibuffer'.  See the•  documentation string of that function for details.•The third arg HISTORY, if non-nil, specifies a history list•  and optionally the initial position in the list.•See `read-from-minibuffer' for details of HISTORY argument.•Fourth arg DEFAULT-VALUE is the default value or the list of default values.• If non-nil, it is used for history commands, and as the value (or the first• element of the list of default values) to return if the user enters the• empty string.•Fifth arg INHERIT-INPUT-METHOD, if non-nil, means the minibuffer inherits• the current input method and the setting of `enable-multibyte-characters'.",
"recenter":"recenter is an interactive built-in function in `C source code'.••(recenter &amp;optional ARG)••Center point in selected window and maybe redisplay frame.•With prefix argument ARG, recenter putting point on screen line ARG•relative to the selected window.  If ARG is negative, it counts up from the•bottom of the window.  (ARG should be less than the height of the window.)••If ARG is omitted or nil, then recenter with point on the middle line of•the selected window; if the variable `recenter-redisplay' is non-nil,•also erase the entire frame and redraw it (when `auto-resize-tool-bars'•is set to `grow-only', this resets the tool-bar's height to the minimum•height needed); if `recenter-redisplay' has the special value `tty',•then only tty frames are redrawn.••Just C-u as prefix means put point in the center of the window•and redisplay normally--don't erase and redraw the frame.",
"recenter-top-bottom":"recenter-top-bottom is an interactive compiled Lisp function in•`window.el'.••(recenter-top-bottom &amp;optional ARG)••Move current buffer line to the specified window line.•With no prefix argument, successive calls place point according•to the cycling order defined by `recenter-positions'.••A prefix argument is handled like `recenter':• With numeric prefix ARG, move current line to window-line ARG.• With plain `C-u', move current line to window center.",
"recentf-mode":"recentf-mode is an interactive autoloaded compiled Lisp function in•`recentf.el'.••(recentf-mode &amp;optional ARG)••Toggle ⧷&quoteOpen Recent⧷&quote menu (Recentf mode).•With a prefix argument ARG, enable Recentf mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•Recentf mode if ARG is omitted or nil.••When Recentf mode is enabled, a ⧷&quoteOpen Recent⧷&quote submenu is•displayed in the ⧷&quoteFile⧷&quote menu, containing a list of files that•were operated on recently.",
"recentf-open-files":"recentf-open-files is an interactive compiled Lisp function in•`recentf.el'.••(recentf-open-files &amp;optional FILES BUFFER-NAME)••Show a dialog to open a recent file.•If optional argument FILES is non-nil, it is a list of recently-opened•files to choose from.  It defaults to the whole recent list.•If optional argument BUFFER-NAME is non-nil, it is a buffer name to•use for the dialog.  It defaults to ⧷&quote*`recentf-menu-title'*⧷&quote.",
"rectangle-number-lines":"rectangle-number-lines is an interactive autoloaded compiled Lisp•function in `rect.el'.••(rectangle-number-lines START END START-AT &amp;optional FORMAT)••Insert numbers in front of the region-rectangle.••START-AT, if non-nil, should be a number from which to begin•counting.  FORMAT, if non-nil, should be a format string to pass•to `format' along with the line count.  When called interactively•with a prefix argument, prompt for START-AT and FORMAT.",
"redo":"redo is an alias for `undo-tree-redo' in `init_load_packages.el'.••(redo &amp;optional ARG PRESERVE-UNDO)••Redo changes. A numeric ARG serves as a repeat count.••In Transient Mark mode when the mark is active, only redo changes•within the current region. Similarly, when not in Transient Mark•mode, just C-u as an argument limits redo to•changes within the current region.••A non-nil PRESERVE-UNDO causes the existing undo record to be•preserved, rather than replacing it with the new one generated by•redoing.",
"reduce":"reduce is an alias for `cl-reduce' in `cl.el'.••(reduce FUNCTION SEQ [KEYWORD VALUE]...)••Reduce two-argument FUNCTION across SEQ.••Keywords supported:  :start :end :from-end :initial-value :key",
"regexp-builder":"regexp-builder is an alias for `re-builder' in `re-builder.el'.••(regexp-builder)••Construct a regexp interactively.•This command makes the current buffer the ⧷&quotetarget⧷&quote buffer of•the regexp builder.  It displays a buffer named ⧷&quote*RE-Builder*⧷&quote•in another window, initially containing an empty regexp.••As you edit the regexp in the ⧷&quote*RE-Builder*⧷&quote buffer, the•matching parts of the target buffer will be highlighted.",
"regexp-opt":"regexp-opt is an autoloaded compiled Lisp function in `regexp-opt.el'.••(regexp-opt STRINGS &amp;optional PAREN)••Return a regexp to match a string in the list STRINGS.•Each string should be unique in STRINGS and should not contain any regexps,•quoted or not.  If optional PAREN is non-nil, ensure that the returned regexp•is enclosed by at least one regexp grouping construct.•The returned regexp is typically more efficient than the equivalent regexp:•• (let ((open (if PAREN ⧷&quote⧷⧷(⧷&quote ⧷&quote⧷&quote)) (close (if PAREN ⧷&quote⧷⧷)⧷&quote ⧷&quote⧷&quote)))•   (concat open (mapconcat 'regexp-quote STRINGS ⧷&quote⧷⧷|⧷&quote) close))••If PAREN is `words', then the resulting regexp is additionally surrounded•by ⧷&lt; and ⧷&gt;.•If PAREN is `symbols', then the resulting regexp is additionally surrounded•by ⧷_&lt; and ⧷_&gt;.",
"regexp-quote":"regexp-quote is a built-in function in `C source code'.••(regexp-quote STRING)••Return a regexp string which matches exactly STRING and nothing else.",
"region-active-p":"region-active-p is a compiled Lisp function in `simple.el'.••(region-active-p)••Return t if Transient Mark mode is enabled and the mark is active.••Some commands act specially on the region when Transient Mark•mode is enabled.  Usually, such commands should use•`use-region-p' instead of this function, because `use-region-p'•also checks the value of `use-empty-active-region'.",
"region-beginning":"region-beginning is a built-in function in `C source code'.••(region-beginning)••Return the integer value of point or mark, whichever is smaller.",
"region-end":"region-end is a built-in function in `C source code'.••(region-end)••Return the integer value of point or mark, whichever is larger.",
"remember":"remember is an interactive autoloaded Lisp function in `remember.el'.••(remember &amp;optional INITIAL)••Remember an arbitrary piece of data.•INITIAL is the text to initially place in the *Remember* buffer,•or nil to bring up a blank *Remember* buffer.••With a prefix or a visible region, use the region as INITIAL.",
"remhash":"remhash is a built-in function in `C source code'.••(remhash KEY TABLE)••Remove KEY from TABLE.",
"remove-hook":"remove-hook is a compiled Lisp function in `subr.el'.••(remove-hook HOOK FUNCTION &amp;optional LOCAL)••Remove from the value of HOOK the function FUNCTION.•HOOK should be a symbol, and FUNCTION may be any valid function.  If•FUNCTION isn't the value of HOOK, or, if FUNCTION doesn't appear in the•list of hooks to run in HOOK, then nothing is done.  See `add-hook'.••The optional third argument, LOCAL, if non-nil, says to modify•the hook's buffer-local value rather than its default value.",
"remove-vowel":"remove-vowel is an interactive compiled Lisp function in•`xah_emacs_str_replacement.el'.••(remove-vowel ΞSTRING &amp;optional ΞFROM-TO-PAIR)••Remove the following letters: {a e i o u}.••When called interactively, work on current text block or text selection. (a “text block” is text between empty lines)••When called in lisp code, if ξfrom-to-pair is non-nil, change the text•in the region between positions [from to]. ξfrom-to-pair should be a•list or vector pair.  Else, returns a changed string.",
"rename-file":"rename-file is an interactive built-in function in `C source code'.••(rename-file FILE NEWNAME &amp;optional OK-IF-ALREADY-EXISTS)••Rename FILE as NEWNAME.  Both args must be strings.•If file has names other than FILE, it continues to have those names.•Signals a `file-already-exists' error if a file NEWNAME already exists•unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.•A number as third arg means request confirmation if NEWNAME already exists.•This is what happens in interactive use with M-x.",
"repeat-complex-command":"repeat-complex-command is an interactive compiled Lisp function in•`simple.el'.••(repeat-complex-command ARG)••Edit and re-evaluate last complex command, or ARGth from last.•A complex command is one which used the minibuffer.•The command is placed in the minibuffer as a Lisp form for editing.•The result is executed, repeating the command as changed.•If the command has been changed or is not the most recent previous•command it is added to the front of the command history.•You can use the minibuffer history commands M-n and M-p•to get different commands to edit and resubmit.",
"replace-match":"replace-match is a built-in function in `C source code'.••(replace-match NEWTEXT &amp;optional FIXEDCASE LITERAL STRING SUBEXP)••Replace text matched by last search with NEWTEXT.•Leave point at the end of the replacement text.••If optional second arg FIXEDCASE is non-nil, do not alter the case of•the replacement text.  Otherwise, maybe capitalize the whole text, or•maybe just word initials, based on the replaced text.  If the replaced•text has only capital letters and has at least one multiletter word,•convert NEWTEXT to all caps.  Otherwise if all words are capitalized•in the replaced text, capitalize each word in NEWTEXT.••If optional third arg LITERAL is non-nil, insert NEWTEXT literally.•Otherwise treat `⧷' as special:•  `⧷&amp;' in NEWTEXT means substitute original matched text.•  `⧷N' means substitute what matched the Nth `⧷(...⧷)'.•       If Nth parens didn't match, substitute nothing.•  `⧷⧷' means insert one `⧷'.•  `⧷?' is treated literally•       (for compatibility with `query-replace-regexp').•  Any other character following `⧷' signals an error.•Case conversion does not apply to these substitutions.••If optional fourth argument STRING is non-nil, it should be a string•to act on; this should be the string on which the previous match was•done via `string-match'.  In this case, `replace-match' creates and•returns a new string, made by copying STRING and replacing the part of•STRING that was matched (the original STRING itself is not altered).••The optional fifth argument SUBEXP specifies a subexpression;•it says to replace just that subexpression with NEWTEXT,•rather than replacing the entire matched text.•This is, in a vague sense, the inverse of using `⧷N' in NEWTEXT;•`⧷N' copies subexp N into NEWTEXT, but using N as SUBEXP puts•NEWTEXT in place of subexp N.•This is useful only after a regular expression search or match,•since only regular expressions have distinguished subexpressions.",
"replace-pairs-in-string":"replace-pairs-in-string is a Lisp function in•`xfrp_find_replace_pairs.el'.••(replace-pairs-in-string ΞSTR ΞPAIRS)••Replace string ξstr by find/replace ξpairs sequence.••Returns the new string.••Example:• (replace-pairs-in-string ⧷&quoteabcdef⧷&quote• '([⧷&quotea⧷&quote ⧷&quote1⧷&quote] [⧷&quoteb⧷&quote ⧷&quote2⧷&quote] [⧷&quotec⧷&quote ⧷&quote3⧷&quote]))  ⇒ “⧷&quote123def⧷&quote”.••This function calls `replace-pairs-region' to do its work.",
"replace-pairs-in-string-recursive":"replace-pairs-in-string-recursive is a Lisp function in•`xfrp_find_replace_pairs.el'.••(replace-pairs-in-string-recursive STR PAIRS)••Replace string STR recursively by find/replace pairs PAIRS sequence.••This function is similar to `replace-pairs-in-string', except that the replacement is done recursively after each find/replace pair.  Earlier replaced value may be replaced again.••For example, if the input string is “abcd”, and the pairs are a → c and c → d, then, the result is “dbdd” (not “cbdd”).••See `replace-pairs-in-string' for full doc.",
"replace-pairs-region":"replace-pairs-region is a Lisp function in•`xfrp_find_replace_pairs.el'.••(replace-pairs-region P1 P2 PAIRS)••Replace multiple PAIRS of find/replace strings in region P1 P2.••PAIRS should be a sequence of pairs, ℯℊ [[findStr1 replaceStr1] [findStr2 replaceStr2] …] It can be list or vector, for the elements or the entire argument.  ••The find strings are not case sensitive. If you want case sensitive, set `case-fold-search' to nil. Like this: (let ((case-fold-search nil)) (replace-pairs-region …))••The replacement are literal and case sensitive.••Once a subsring in the input string is replaced, that part is not changed again.  For example, if the input string is “abcd”, and the pairs are a → c and c → d, then, result is “cbdd”, not “dbdd”. If you simply want repeated replacements, use `replace-pairs-in-string-recursive'.••Same as `replace-pairs-in-string' except does on a region.••Note: the region's text or any string in pairs is assumed to NOT contain any character from Unicode Private Use Area A. That is, U+F0000 to U+FFFFD. And, there are no more than 65534 pairs.",
"replace-rectangle":"replace-rectangle is an alias for `string-rectangle' in `rect.el'.••(replace-rectangle START END STRING)••Replace rectangle contents with STRING on each line.•The length of STRING need not be the same as the rectangle width.••Called from a program, takes three args; START, END and STRING.",
"replace-regexp":"replace-regexp is an interactive compiled Lisp function in•`replace.el'.••(replace-regexp REGEXP TO-STRING &amp;optional DELIMITED START END)••Replace things after point matching REGEXP with TO-STRING.•Preserve case in each match if `case-replace' and `case-fold-search'•are non-nil and REGEXP has no uppercase letters.••If `replace-regexp-lax-whitespace' is non-nil, a space or spaces in the regexp•to be replaced will match a sequence of whitespace chars defined by the•regexp in `search-whitespace-regexp'.••In Transient Mark mode, if the mark is active, operate on the contents•of the region.  Otherwise, operate from point to the end of the buffer.••Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace•only matches surrounded by word boundaries.•Fourth and fifth arg START and END specify the region to operate on.••In TO-STRING, `⧷&amp;' stands for whatever matched the whole of REGEXP,•and `⧷N' (where N is a digit) stands for•whatever what matched the Nth `⧷(...⧷)' in REGEXP.•`⧷?' lets you edit the replacement text in the minibuffer•at the given position for each replacement.••In interactive calls, the replacement text may contain `⧷,'•followed by a Lisp expression used as part of the replacement•text.  Inside of that expression, `⧷&amp;' is a string denoting the•whole match, `⧷N' a partial match, `⧷#&amp;' and `⧷#N' the respective•numeric values from `string-to-number', and `⧷#' itself for•`replace-count', the number of replacements occurred so far.••If your Lisp expression is an identifier and the next letter in•the replacement string would be interpreted as part of it, you•can wrap it with an expression like `⧷,(or ⧷#)'.  Incidentally,•for this particular case you may also enter `⧷#' in the•replacement text directly.••When using those Lisp features interactively in the replacement•text, TO-STRING is actually made a list instead of a string.•Use C-x M-: after this command for details.••Use M-n to pull the last incremental search regexp to the minibuffer•that reads REGEXP.••This function is usually the wrong thing to use in a Lisp program.•What you probably want is a loop like this:•  (while (re-search-forward REGEXP nil t)•    (replace-match TO-STRING nil nil))•which will run faster and will not set the mark or print anything.",
"replace-regexp-in-string":"replace-regexp-in-string is a compiled Lisp function in `subr.el'.••(replace-regexp-in-string REGEXP REP STRING &amp;optional FIXEDCASE•LITERAL SUBEXP START)••Replace all matches for REGEXP with REP in STRING.••Return a new string containing the replacements.••Optional arguments FIXEDCASE, LITERAL and SUBEXP are like the•arguments with the same names of function `replace-match'.  If START•is non-nil, start replacements at that index in STRING.••REP is either a string used as the NEWTEXT arg of `replace-match' or a•function.  If it is a function, it is called with the actual text of each•match, and its value is used as the replacement text.  When REP is called,•the match data are the result of matching REGEXP against a substring•of STRING.••To replace only the first match (if any), make REGEXP match up to ⧷'•and replace a sub-expression, e.g.•  (replace-regexp-in-string ⧷&quote⧷⧷(foo⧷⧷).*⧷⧷'⧷&quote ⧷&quotebar⧷&quote ⧷&quote foo foo⧷&quote nil nil 1)•    =&gt; ⧷&quote bar foo⧷&quote",
"replace-regexp-pairs-in-string":"replace-regexp-pairs-in-string is a Lisp function in•`xfrp_find_replace_pairs.el'.••(replace-regexp-pairs-in-string STR PAIRS &amp;optional FIXEDCASE)••Replace string STR recursively by regex find/replace pairs PAIRS sequence.••The second argument PAIRS should be a sequence of pairs, e.g.• [[regexStr1 replaceStr1] [regexStr2 replaceStr2] …]• It can be list or vector.••If third arg FIXEDCASE is non-nil, do not alter case of replacement text.• (same as in `replace-match')••If you want the regex to be case sensitive, set the global•variable `case-fold-search' to “nil”. Like this: (let ((case-fold-search nil)) (replace-regexp-pairs-in-string …))••See also `replace-pairs-in-string'.",
"replace-regexp-pairs-region":"replace-regexp-pairs-region is a Lisp function in•`xfrp_find_replace_pairs.el'.••(replace-regexp-pairs-region P1 P2 PAIRS &amp;optional FIXEDCASE LITERAL)••Replace regex string find/replace PAIRS in region.••P1 P2 are the region boundaries.••PAIRS is• [[regexStr1 replaceStr1] [regexStr2 replaceStr2] …]• It can be list or vector.••The optional arguments FIXEDCASE and LITERAL is the same as in `replace-match'.••If you want the regex to be case sensitive, set the global•variable `case-fold-search' to “nil”. Like this: (let ((case-fold-search nil)) (replace-regexp-pairs-region …))",
"replace-string":"replace-string is an interactive compiled Lisp function in•`replace.el'.••(replace-string FROM-STRING TO-STRING &amp;optional DELIMITED START END)••Replace occurrences of FROM-STRING with TO-STRING.•Preserve case in each match if `case-replace' and `case-fold-search'•are non-nil and FROM-STRING has no uppercase letters.•(Preserving case means that if the string matched is all caps, or capitalized,•then its replacement is upcased or capitalized.)••If `replace-lax-whitespace' is non-nil, a space or spaces in the string•to be replaced will match a sequence of whitespace chars defined by the•regexp in `search-whitespace-regexp'.••In Transient Mark mode, if the mark is active, operate on the contents•of the region.  Otherwise, operate from point to the end of the buffer.••Third arg DELIMITED (prefix arg if interactive), if non-nil, means replace•only matches surrounded by word boundaries.•Fourth and fifth arg START and END specify the region to operate on.••Use M-n to pull the last incremental search string to the minibuffer•that reads FROM-STRING.••This function is usually the wrong thing to use in a Lisp program.•What you probably want is a loop like this:•  (while (search-forward FROM-STRING nil t)•    (replace-match TO-STRING nil t))•which will run faster and will not set the mark or print anything.•(You may need a more complex loop if FROM-STRING can match the null string•and TO-STRING is also null.)",
"report-emacs-bug":"report-emacs-bug is an interactive autoloaded Lisp function in•`emacsbug.el'.••(report-emacs-bug TOPIC &amp;optional RECENT-KEYS)••Report a bug in GNU Emacs.•Prompts for bug subject.  Leaves you in a mail buffer.",
"require":"require is a built-in function in `C source code'.••(require FEATURE &amp;optional FILENAME NOERROR)••If feature FEATURE is not loaded, load it from FILENAME.•If FEATURE is not a member of the list `features', then the feature•is not loaded; so load the file FILENAME.•If FILENAME is omitted, the printname of FEATURE is used as the file name,•and `load' will try to load this name appended with the suffix `.elc' or•`.el', in that order.  The name without appended suffix will not be used.•See `get-load-suffixes' for the complete list of suffixes.•If the optional third argument NOERROR is non-nil,•then return nil if the file is not found instead of signaling an error.•Normally the return value is FEATURE.•The normal messages at start and end of loading FILENAME are suppressed.",
"re-search-backward":"re-search-backward is an interactive built-in function in `C source•code'.••(re-search-backward REGEXP &amp;optional BOUND NOERROR COUNT)••Search backward from point for match for regular expression REGEXP.•Set point to the beginning of the match, and return point.•The match found is the one starting last in the buffer•and yet ending before the origin of the search.•An optional second argument bounds the search; it is a buffer position.•The match found must start at or after that position.•Optional third argument, if t, means if fail just return nil (no error).•  If not nil and not t, move to limit of search and return nil.•Optional fourth argument is repeat count--search for successive occurrences.••Search case-sensitivity is determined by the value of the variable•`case-fold-search', which see.••See also the functions `match-beginning', `match-end', `match-string',•and `replace-match'.",
"re-search-forward":"re-search-forward is an interactive built-in function in `C source•code'.••(re-search-forward REGEXP &amp;optional BOUND NOERROR COUNT)••Search forward from point for regular expression REGEXP.•Set point to the end of the occurrence found, and return point.•An optional second argument bounds the search; it is a buffer position.•The match found must not extend after that position.•Optional third argument, if t, means if fail just return nil (no error).•  If not nil and not t, move to limit of search and return nil.•Optional fourth argument is repeat count--search for successive occurrences.••Search case-sensitivity is determined by the value of the variable•`case-fold-search', which see.••See also the functions `match-beginning', `match-end', `match-string',•and `replace-match'.",
"return":"return is an alias for `cl-return' in `cl.el'.••(return &amp;optional RESULT)••Return from the block named nil.•This is equivalent to `(cl-return-from nil RESULT)'.",
"reverse":"reverse is a built-in function in `C source code'.••(reverse LIST)••Reverse LIST, copying.  Return the reversed list.•See also the function `nreverse', which is used more often.",
"reverse-region":"reverse-region is an interactive autoloaded compiled Lisp function in•`sort.el'.••(reverse-region BEG END)••Reverse the order of lines in a region.•From a program takes two point or marker arguments, BEG and END.",
"revert-buffer":"revert-buffer is an interactive compiled Lisp function in `files.el'.••(revert-buffer &amp;optional IGNORE-AUTO NOCONFIRM PRESERVE-MODES)••Replace current buffer text with the text of the visited file on disk.•This undoes all changes since the file was visited or saved.•With a prefix argument, offer to revert from latest auto-save file, if•that is more recent than the visited file.••This command also implements an interface for special buffers•that contain text which doesn't come from a file, but reflects•some other data instead (e.g. Dired buffers, `buffer-list'•buffers).  This is done via the variable `revert-buffer-function'.•In these cases, it should reconstruct the buffer contents from the•appropriate data.••When called from Lisp, the first argument is IGNORE-AUTO; only offer•to revert from the auto-save file when this is nil.  Note that the•sense of this argument is the reverse of the prefix argument, for the•sake of backward compatibility.  IGNORE-AUTO is optional, defaulting•to nil.••Optional second argument NOCONFIRM means don't ask for confirmation•at all.  (The variable `revert-without-query' offers another way to•revert buffers without querying for confirmation.)••Optional third argument PRESERVE-MODES non-nil means don't alter•the files modes.  Normally we reinitialize them using `normal-mode'.••This function binds `revert-buffer-in-progress-p' non-nil while it operates.••If the value of `revert-buffer-function' is non-nil, it is called to•do all the work for this command.  Otherwise, the hooks•`before-revert-hook' and `after-revert-hook' are run at the beginning•and the end, and if `revert-buffer-insert-file-contents-function' is•non-nil, it is called instead of rereading visited file contents.",
"rgrep":"rgrep is an interactive autoloaded compiled Lisp function in•`grep.el'.••(rgrep REGEXP &amp;optional FILES DIR CONFIRM)••Recursively grep for REGEXP in FILES in directory tree rooted at DIR.•The search is limited to file names matching shell pattern FILES.•FILES may use abbreviations defined in `grep-files-aliases', e.g.•entering `ch' is equivalent to `*.[ch]'.••With C-u prefix, you can edit the constructed shell command line•before it is executed.•With two C-u prefixes, directly edit and run `grep-find-command'.••Collect output in a buffer.  While the recursive grep is running,•you can use C-x ` (M-x next-error), or RET in the grep output buffer,•to visit the lines where matches were found.  To kill the job•before it finishes, type C-c C-k.••This command shares argument histories with M-x lgrep and M-x grep-find.••When called programmatically and FILES is nil, REGEXP is expected•to specify a command to run.",
"right-char":"right-char is an interactive compiled Lisp function in `bindings.el'.••(right-char &amp;optional N)••Move point N characters to the right (to the left if N is negative).•On reaching beginning or end of buffer, stop and signal error.••Depending on the bidirectional context, this may move either forward•or backward in the buffer.  This is in contrast with M-n•and M-h, which see.",
"rst-mode":"rst-mode is an interactive autoloaded compiled Lisp function in•`rst.el'.••(rst-mode)••Parent mode: `text-mode'.••Major mode for editing reStructuredText documents.•••Turning on `rst-mode' calls the normal hooks `text-mode-hook'•and `rst-mode-hook'.  This mode also supports font-lock•highlighting.••key             binding•---             -------••C-c             Prefix Command•ESC             Prefix Command•C-=             rst-adjust••C-M-a           rst-backward-section•C-M-e           rst-forward-section•C-M-h           rst-mark-section••C-c C-a         Prefix Command•C-c C-b         ??•C-c C-c         Prefix Command•C-c C-d         ??•C-c C-e         ??•C-c C-f         ??•C-c C-h         describe-prefix-bindings•C-c TAB         ??•C-c C-l         Prefix Command•C-c RET         ??•C-c C-n         ??•C-c C-p         ??•C-c C-r         Prefix Command•C-c C-s         ??•C-c C-t         Prefix Command•C-c C-u         ??•C-c C-v         ??•C-c C-w         ??•C-c 1           ??•C-c 2           ??•C-c 3           ??•C-c 4           ??•C-c 5           ??•C-c C-=         rst-adjust••C-c C-c C-a     rst-compile-alt-toolset•C-c C-c C-c     rst-compile•C-c C-c C-h     describe-prefix-bindings•C-c C-c C-p     rst-compile-pdf-preview•C-c C-c C-s     rst-compile-slides-preview•C-c C-c C-x     rst-compile-pseudo-region••C-c C-t C-h     describe-prefix-bindings•C-c C-t TAB     rst-toc-insert•C-c C-t C-j     rst-goto-section•C-c C-t C-t     rst-toc•C-c C-t C-u     rst-toc-update••C-c C-l C-b     rst-bullet-list-region•C-c C-l C-c     rst-convert-bullets-to-enumeration•C-c C-l C-e     rst-enumerate-region•C-c C-l C-h     describe-prefix-bindings•C-c C-l TAB     rst-insert-list•C-c C-l C-s     rst-straighten-bullets-region•C-c C-l &lt;t&gt;     ??••C-c C-r C-h     describe-prefix-bindings•C-c C-r C-l     rst-line-block-region•C-c C-r &lt;t&gt;     ??•C-c C-r &lt;tab&gt;   rst-shift-region••C-c C-a C-a     rst-adjust•C-c C-a C-d     rst-display-adornments-hierarchy•C-c C-a C-h     describe-prefix-bindings•C-c C-a C-s     rst-straighten-adornments•C-c C-a &lt;t&gt;     ??••",
"ruby-mode":"ruby-mode is an interactive autoloaded compiled Lisp function in•`ruby-mode.el'.••(ruby-mode)••Parent mode: `prog-mode'.••Major mode for editing Ruby scripts.•M-x ruby-indent-line properly indents subexpressions of multi-line•class, module, def, if, while, for, do, and case statements, taking•nesting into account.••The variable `ruby-indent-level' controls the amount of indentation.••key             binding•---             -------••C-c             Prefix Command•ESC             Prefix Command••C-c {           ruby-toggle-block••C-M-b           ruby-backward-sexp•C-M-f           ruby-forward-sexp•C-M-n           ruby-end-of-block•C-M-p           ruby-beginning-of-block•C-M-q           ruby-indent-exp••C-M-q           prog-indent-sexp•  (that binding is currently shadowed by another mode)••••In addition to any hooks its parent mode `prog-mode' might have run,•this mode runs the hook `ruby-mode-hook', as the final step•during initialization.",
"run-hooks":"run-hooks is a built-in function in `C source code'.••(run-hooks &amp;rest HOOKS)••Run each hook in HOOKS.•Each argument should be a symbol, a hook variable.•These symbols are processed in the order specified.•If a hook symbol has a non-nil value, that value may be a function•or a list of functions to be called to run the hook.•If the value is a function, it is called with no arguments.•If it is a list, the elements are called, in order, with no arguments.••Major modes should not use this function directly to run their mode•hook; they should use `run-mode-hooks' instead.••Do not use `make-local-variable' to make a hook variable buffer-local.•Instead, use `add-hook' and specify t for the LOCAL argument.",
"run-mode-hooks":"run-mode-hooks is a compiled Lisp function in `subr.el'.••(run-mode-hooks &amp;rest HOOKS)••Run mode hooks `delayed-mode-hooks' and HOOKS, or delay HOOKS.•If the variable `delay-mode-hooks' is non-nil, does not run any hooks,•just adds the HOOKS to the list `delayed-mode-hooks'.•Otherwise, runs hooks in the sequence: `change-major-mode-after-body-hook',•`delayed-mode-hooks' (in reverse order), HOOKS, and finally•`after-change-major-mode-hook'.  Major mode functions should use•this instead of `run-hooks' when running their FOO-mode-hook.",
"save-buffer":"save-buffer is an interactive compiled Lisp function in `files.el'.••(save-buffer &amp;optional ARGS)••Save current buffer in visited file if modified.•Variations are described below.••By default, makes the previous version into a backup file• if previously requested or if this is the first save.•Prefixed with one C-u, marks this version• to become a backup when the next save is done.•Prefixed with two C-u's,• unconditionally makes the previous version into a backup file.•Prefixed with three C-u's, marks this version• to become a backup when the next save is done,• and unconditionally makes the previous version into a backup file.••With a numeric argument of 0, never make the previous version•into a backup file.••If a file's name is FOO, the names of its numbered backup versions are• FOO.~i~ for various integers i.  A non-numbered backup file is called FOO~.•Numeric backups (rather than FOO~) will be made if value of• `version-control' is not the atom `never' and either there are already• numeric versions of the file being backed up, or `version-control' is• non-nil.•We don't want excessive versions piling up, so there are variables• `kept-old-versions', which tells Emacs how many oldest versions to keep,• and `kept-new-versions', which tells how many newest versions to keep.• Defaults are 2 old versions and 2 new.•`dired-kept-versions' controls dired's clean-directory (.) command.•If `delete-old-versions' is nil, system will query user• before trimming versions.  Otherwise it does it silently.••If `vc-make-backup-files' is nil, which is the default,• no backup files are made for files managed by version control.• (This is because the version control system itself records previous versions.)••See the subroutine `basic-save-buffer' for more information.",
"save-buffers-kill-terminal":"save-buffers-kill-terminal is an interactive compiled Lisp function in•`files.el'.••(save-buffers-kill-terminal &amp;optional ARG)••Offer to save each buffer, then kill the current connection.•If the current frame has no client, kill Emacs itself.••With prefix ARG, silently save all file-visiting buffers, then kill.••If emacsclient was started with a list of filenames to edit, then•only these files will be asked to be saved.",
"save-excursion":"save-excursion is a special form in `C source code'.••(save-excursion &amp;rest BODY)••Save point, mark, and current buffer; execute BODY; restore those things.•Executes BODY just like `progn'.•The values of point, mark and the current buffer are restored•even in case of abnormal exit (throw or error).•The state of activation of the mark is also restored.••This construct does not save `deactivate-mark', and therefore•functions that change the buffer will still cause deactivation•of the mark at the end of the command.  To prevent that, bind•`deactivate-mark' with `let'.••If you only want to save the current buffer but not point nor mark,•then just use `save-current-buffer', or even `with-current-buffer'.",
"save-restriction":"save-restriction is a special form in `C source code'.••(save-restriction &amp;rest BODY)••Execute BODY, saving and restoring current buffer's restrictions.•The buffer's restrictions make parts of the beginning and end invisible.•(They are set up with `narrow-to-region' and eliminated with `widen'.)•This special form, `save-restriction', saves the current buffer's restrictions•when it is entered, and restores them when it is exited.•So any `narrow-to-region' within BODY lasts only until the end of the form.•The old restrictions settings are restored•even in case of abnormal exit (throw or error).••The value returned is the value of the last form in BODY.••Note: if you are using both `save-excursion' and `save-restriction',•use `save-excursion' outermost:•    (save-excursion (save-restriction ...))",
"save-some-buffers":"save-some-buffers is an interactive compiled Lisp function in•`files.el'.••(save-some-buffers &amp;optional ARG PRED)••Save some modified file-visiting buffers.  Asks user about each one.•You can answer `y' to save, `n' not to save, `C-r' to look at the•buffer in question with `view-buffer' before deciding or `d' to•view the differences using `diff-buffer-with-file'.••This command first saves any buffers where `buffer-save-without-query' is•non-nil, without asking.••Optional argument (the prefix) non-nil means save all with no questions.•Optional second argument PRED determines which buffers are considered:•If PRED is nil, all the file-visiting buffers are considered.•If PRED is t, then certain non-file buffers will also be considered.•If PRED is a zero-argument function, it indicates for each buffer whether•to consider it or not when called with that buffer current.••See `save-some-buffers-action-alist' if you want to•change the additional actions you can take on files.",
"scroll-down":"scroll-down is an interactive built-in function in `C source code'.••(scroll-down &amp;optional ARG)••Scroll text of selected window down ARG lines.•If ARG is omitted or nil, scroll down by a near full screen.•A near full screen is `next-screen-context-lines' less than a full screen.•Negative ARG means scroll upward.•If ARG is the atom `-', scroll upward by nearly full screen.•When calling from a program, supply as argument a number, nil, or `-'.••This subr is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `scroll-down'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-scroll-down-keymap'.",
"scroll-lock-mode":"scroll-lock-mode is an interactive autoloaded Lisp function in•`scroll-lock.el'.••(scroll-lock-mode &amp;optional ARG)••Buffer-local minor mode for pager-like scrolling.•With a prefix argument ARG, enable the mode if ARG is positive,•and disable it otherwise.  If called from Lisp, enable the mode•if ARG is omitted or nil.  When enabled, keys that normally move•point by line or paragraph will scroll the buffer by the•respective amount of lines instead and point will be kept•vertically fixed relative to window boundaries during scrolling.",
"scroll-up":"scroll-up is an interactive built-in function in `C source code'.••(scroll-up &amp;optional ARG)••Scroll text of selected window upward ARG lines.•If ARG is omitted or nil, scroll upward by a near full screen.•A near full screen is `next-screen-context-lines' less than a full screen.•Negative ARG means scroll downward.•If ARG is the atom `-', scroll downward by nearly full screen.•When calling from a program, supply as argument a number, nil, or `-'.••This subr is advised.••Around-advice `ergoemacs-movement-advice':•Ergoemacs advice for command for `scroll-up'.•May install a fast repeat key based on `ergoemacs-repeat-movement-commands',  `ergoemacs-full-fast-keys-keymap' and `ergoemacs-fast-scroll-up-keymap'.",
"scroll-up-command":"scroll-up-command is an interactive compiled Lisp function in•`window.el'.••(scroll-up-command &amp;optional ARG)••Scroll text of selected window upward ARG lines; or near full screen if no ARG.•If `scroll-error-top-bottom' is non-nil and `scroll-up' cannot•scroll window further, move cursor to the bottom line.•When point is already on that position, then signal an error.•A near full screen is `next-screen-context-lines' less than a full screen.•Negative ARG means scroll downward.•If ARG is the atom `-', scroll downward by nearly full screen.",
"scroll-up-line":"scroll-up-line is an interactive compiled Lisp function in•`window.el'.••(scroll-up-line &amp;optional ARG)••Scroll text of selected window upward ARG lines; or one line if no ARG.•If ARG is omitted or nil, scroll upward by one line.•This is different from `scroll-up-command' that scrolls a full screen.",
"search-backward":"search-backward is an interactive built-in function in `C source•code'.••(search-backward STRING &amp;optional BOUND NOERROR COUNT)••Search backward from point for STRING.•Set point to the beginning of the occurrence found, and return point.•An optional second argument bounds the search; it is a buffer position.•The match found must not extend before that position.•Optional third argument, if t, means if fail just return nil (no error).• If not nil and not t, position at limit of search and return nil.•Optional fourth argument COUNT, if non-nil, means to search for COUNT• successive occurrences.  If COUNT is negative, search forward,• instead of backward, for -COUNT occurrences.••Search case-sensitivity is determined by the value of the variable•`case-fold-search', which see.••See also the functions `match-beginning', `match-end' and `replace-match'.",
"search-backward-regexp":"search-backward-regexp is an interactive built-in function in•`subr.el'.••(search-backward-regexp REGEXP &amp;optional BOUND NOERROR COUNT)••Search backward from point for match for regular expression REGEXP.•Set point to the beginning of the match, and return point.•The match found is the one starting last in the buffer•and yet ending before the origin of the search.•An optional second argument bounds the search; it is a buffer position.•The match found must start at or after that position.•Optional third argument, if t, means if fail just return nil (no error).•  If not nil and not t, move to limit of search and return nil.•Optional fourth argument is repeat count--search for successive occurrences.••Search case-sensitivity is determined by the value of the variable•`case-fold-search', which see.••See also the functions `match-beginning', `match-end', `match-string',•and `replace-match'.",
"search-forward":"search-forward is an interactive built-in function in `C source code'.••(search-forward STRING &amp;optional BOUND NOERROR COUNT)••Search forward from point for STRING.•Set point to the end of the occurrence found, and return point.•An optional second argument bounds the search; it is a buffer position.•The match found must not extend after that position.  A value of nil is•  equivalent to (point-max).•Optional third argument, if t, means if fail just return nil (no error).•  If not nil and not t, move to limit of search and return nil.•Optional fourth argument COUNT, if non-nil, means to search for COUNT• successive occurrences.  If COUNT is negative, search backward,• instead of forward, for -COUNT occurrences.••Search case-sensitivity is determined by the value of the variable•`case-fold-search', which see.••See also the functions `match-beginning', `match-end' and `replace-match'.",
"search-forward-regexp":"search-forward-regexp is an interactive built-in function in•`subr.el'.••(search-forward-regexp REGEXP &amp;optional BOUND NOERROR COUNT)••Search forward from point for regular expression REGEXP.•Set point to the end of the occurrence found, and return point.•An optional second argument bounds the search; it is a buffer position.•The match found must not extend after that position.•Optional third argument, if t, means if fail just return nil (no error).•  If not nil and not t, move to limit of search and return nil.•Optional fourth argument is repeat count--search for successive occurrences.••Search case-sensitivity is determined by the value of the variable•`case-fold-search', which see.••See also the functions `match-beginning', `match-end', `match-string',•and `replace-match'.",
"self-insert-command":"self-insert-command is an interactive built-in function in `C source•code'.••(self-insert-command N)••Insert the character you type.•Whichever character you type to run this command is inserted.•Before insertion, `expand-abbrev' is executed if the inserted character does•not have word syntax and the previous character in the buffer does.•After insertion, the value of `auto-fill-function' is called if the•`auto-fill-chars' table has a non-nil value for the inserted character.•At the end, it runs `post-self-insert-hook'.",
"server-start":"server-start is an interactive autoloaded compiled Lisp function in•`server.el'.••(server-start &amp;optional LEAVE-DEAD INHIBIT-PROMPT)••Allow this Emacs process to be a server for client processes.•This starts a server communications subprocess through which client•⧷&quoteeditors⧷&quote can send your editing commands to this Emacs job.•To use the server, set up the program `emacsclient' in the Emacs•distribution as your standard ⧷&quoteeditor⧷&quote.••Optional argument LEAVE-DEAD (interactively, a prefix arg) means just•kill any existing server communications subprocess.••If a server is already running, restart it.  If clients are•running, ask the user for confirmation first, unless optional•argument INHIBIT-PROMPT is non-nil.••To force-start a server, do M-x server-force-delete and then•M-x server-start.",
"set-background-color":"set-background-color is an interactive compiled Lisp function in•`frame.el'.••(set-background-color COLOR-NAME)••Set the background color of the selected frame to COLOR-NAME.•When called interactively, prompt for the name of the color to use.•To get the frame's current background color, use `frame-parameters'.",
"set-buffer":"set-buffer is a built-in function in `C source code'.••(set-buffer BUFFER-OR-NAME)••Make buffer BUFFER-OR-NAME current for editing operations.•BUFFER-OR-NAME may be a buffer or the name of an existing buffer.  See•also `with-current-buffer' when you want to make a buffer current•temporarily.  This function does not display the buffer, so its effect•ends when the current command terminates.  Use `switch-to-buffer' or•`pop-to-buffer' to switch buffers permanently.",
"set-buffer-file-coding-system":"set-buffer-file-coding-system is an interactive compiled Lisp function•in `mule.el'.••(set-buffer-file-coding-system CODING-SYSTEM &amp;optional FORCE NOMODIFY)••Set the file coding-system of the current buffer to CODING-SYSTEM.•This means that when you save the buffer, it will be converted•according to CODING-SYSTEM.  For a list of possible values of•CODING-SYSTEM, use M-x list-coding-systems.••If CODING-SYSTEM leaves the text conversion unspecified, or if it leaves•the end-of-line conversion unspecified, FORCE controls what to do.•If FORCE is nil, get the unspecified aspect (or aspects) from the buffer's•previous `buffer-file-coding-system' value (if it is specified there).•Otherwise, leave it unspecified.••This marks the buffer modified so that the succeeding C-s•surely saves the buffer with CODING-SYSTEM.  From a program, if you•don't want to mark the buffer modified, specify t for NOMODIFY.•If you know exactly what coding system you want to use,•just set the variable `buffer-file-coding-system' directly.",
"set-file-modes":"set-file-modes is an interactive built-in function in `C source code'.••(set-file-modes FILENAME MODE)••Set mode bits of file named FILENAME to MODE (an integer).•Only the 12 low bits of MODE are used.••Interactively, mode bits are read by `read-file-modes', which accepts•symbolic notation, like the `chmod' command from GNU Coreutils.",
"set-frame-parameter":"set-frame-parameter is a compiled Lisp function in `frame.el'.••(set-frame-parameter FRAME PARAMETER VALUE)••Set frame parameter PARAMETER to VALUE on FRAME.•If FRAME is nil, it defaults to the selected frame.•See `modify-frame-parameters'.",
"set-input-method":"set-input-method is an interactive compiled Lisp function in•`mule-cmds.el'.••(set-input-method INPUT-METHOD &amp;optional INTERACTIVE)••Select and activate input method INPUT-METHOD for the current buffer.•This also sets the default input method to the one you specify.•If INPUT-METHOD is nil, this function turns off the input method, and•also causes you to be prompted for a name of an input method the next•time you invoke C-⧷.•When called interactively, the optional arg INTERACTIVE is non-nil,•which marks the variable `default-input-method' as set for Custom buffers.••To deactivate the input method interactively, use C-⧷.•To deactivate it programmatically, use `deactivate-input-method'.",
"set-mark":"set-mark is a compiled Lisp function in `simple.el'.••(set-mark POS)••Set this buffer's mark to POS.  Don't use this function!•That is to say, don't use this function unless you want•the user to see that the mark has moved, and you want the previous•mark position to be lost.••Normally, when a new mark is set, the old one should go on the stack.•This is why most applications should use `push-mark', not `set-mark'.••Novice Emacs Lisp programmers often try to use the mark for the wrong•purposes.  The mark saves a location for the user's convenience.•Most editing commands should not alter the mark.•To remember a location for internal use in the Lisp program,•store it in a Lisp variable.  Example:••   (let ((beg (point))) (forward-line 1) (delete-region beg (point))).",
"set-mark-command":"set-mark-command is an interactive compiled Lisp function in•`simple.el'.••(set-mark-command ARG)••Set the mark where point is, or jump to the mark.•Setting the mark also alters the region, which is the text•between point and mark; this is the closest equivalent in•Emacs to what some editors call the ⧷&quoteselection⧷&quote.••With no prefix argument, set the mark at point, and push the•old mark position on local mark ring.  Also push the old mark on•global mark ring, if the previous mark was set in another buffer.••When Transient Mark Mode is off, immediately repeating this•command activates `transient-mark-mode' temporarily.••With prefix argument (e.g., C-u M-SPC), jump to the mark, and set the mark from•position popped off the local mark ring (this does not affect the global•mark ring).  Use C-x C-@ to jump to a mark popped off the global•mark ring (see `pop-global-mark').••If `set-mark-command-repeat-pop' is non-nil, repeating•the M-SPC command with no prefix argument pops the next position•off the local (or global) mark ring and jumps there.••With C-u C-u as prefix•argument, unconditionally set mark where point is, even if•`set-mark-command-repeat-pop' is non-nil.••Novice Emacs Lisp programmers often try to use the mark for the wrong•purposes.  See the documentation of `set-mark' for more information.",
"setq":"setq is a special form in `C source code'.••(setq [SYM VAL]...)••Set each SYM to the value of its VAL.•The symbols SYM are variables; they are literal (not evaluated).•The values VAL are expressions; they are evaluated.•Thus, (setq x (1+ y)) sets `x' to the value of `(1+ y)'.•The second VAL is not computed until after the first SYM is set, and so on;•each VAL can use the new value of variables set earlier in the `setq'.•The return value of the `setq' form is the value of the last VAL.",
"setq-default":"setq-default is a special form in `C source code'.••(setq-default [VAR VALUE]...)••Set the default value of variable VAR to VALUE.•VAR, the variable name, is literal (not evaluated);•VALUE is an expression: it is evaluated and its value returned.•The default value of a variable is seen in buffers•that do not have their own values for the variable.••More generally, you can use multiple variables and values, as in•  (setq-default VAR VALUE VAR VALUE...)•This sets each VAR's default value to the corresponding VALUE.•The VALUE for the Nth VAR can refer to the new default values•of previous VARs.",
"set-variable":"set-variable is an interactive compiled Lisp function in `simple.el'.••(set-variable VARIABLE VALUE &amp;optional MAKE-LOCAL)••Set VARIABLE to VALUE.  VALUE is a Lisp object.•VARIABLE should be a user option variable name, a Lisp variable•meant to be customized by users.  You should enter VALUE in Lisp syntax,•so if you want VALUE to be a string, you must surround it with doublequotes.•VALUE is used literally, not evaluated.••If VARIABLE has a `variable-interactive' property, that is used as if•it were the arg to `interactive' (which see) to interactively read VALUE.••If VARIABLE has been defined with `defcustom', then the type information•in the definition is used to check that VALUE is valid.••With a prefix argument, set VARIABLE to VALUE buffer-locally.",
"sgml-delete-tag":"sgml-delete-tag is an interactive compiled Lisp function in•`sgml-mode.el'.••(sgml-delete-tag ARG)••Delete tag on or after cursor, and matching closing or opening tag.•With prefix argument ARG, repeat this ARG times.",
"sgml-mode":"sgml-mode is an interactive autoloaded compiled Lisp function in•`sgml-mode.el'.••(sgml-mode)••Parent mode: `text-mode'.••Major mode for editing SGML documents.•Makes &gt; match &lt;.•Keys &lt;, &amp;, SPC within &lt;&gt;, ⧷&quote, / and ' can be electric depending on•`sgml-quick-keys'.••An argument of N to a tag-inserting command means to wrap it around•the next N words.  In Transient Mark mode, when the mark is active,•N defaults to -1, which means to wrap it around the current region.••If you like upcased tags, put (setq sgml-transformation-function 'upcase)•in your init file.••Use M-x sgml-validate to validate your document with an SGML parser.••Do C-h 2 sgml- SPC to see available variables.•Do C-h 3 on the following bindings to discover what they do.•key             binding•---             -------•• .. ÿ       sgml-maybe-name-self••C-c             Prefix Command•ESC             Prefix Command•/               sgml-slash••C-c C-a         sgml-attributes•C-c C-b         sgml-skip-tag-backward•C-c C-d         sgml-delete-tag•C-c C-e         sgml-close-tag•C-c C-f         sgml-skip-tag-forward•C-c TAB         sgml-tags-invisible•C-c C-n         sgml-name-char•C-c C-o         sgml-tag•C-c C-t         sgml-tag•C-c C-v         sgml-validate•C-c /           sgml-close-tag•C-c 8           sgml-name-8bit-mode•C-c ?           sgml-tag-help•C-c ]           sgml-close-tag•C-c DEL         sgml-delete-tag•C-c &lt;left&gt;      sgml-skip-tag-backward•C-c &lt;right&gt;     sgml-skip-tag-forward••C-M-i           ispell-complete-word••••In addition to any hooks its parent mode `text-mode' might have run,•this mode runs the hook `sgml-mode-hook', as the final step•during initialization.",
"sgml-skip-tag-backward":"sgml-skip-tag-backward is an interactive compiled Lisp function in•`sgml-mode.el'.••(sgml-skip-tag-backward ARG)••Skip to beginning of tag or matching opening tag if present.•With prefix argument ARG, repeat this ARG times.•Return non-nil if we skipped over matched tags.",
"sgml-skip-tag-forward":"sgml-skip-tag-forward is an interactive compiled Lisp function in•`sgml-mode.el'.••(sgml-skip-tag-forward ARG)••Skip to end of tag or matching closing tag if present.•With prefix argument ARG, repeat this ARG times.•Return t if after a closing tag.",
"sgml-tags-invisible":"sgml-tags-invisible is an interactive compiled Lisp function in•`sgml-mode.el'.••(sgml-tags-invisible ARG)••Toggle visibility of existing tags.",
"shell":"shell is an interactive autoloaded compiled Lisp function in•`shell.el'.••(shell &amp;optional BUFFER)••Run an inferior shell, with I/O through BUFFER (which defaults to `*shell*').•Interactively, a prefix arg means to prompt for BUFFER.•If `default-directory' is a remote file name, it is also prompted•to change if called with a prefix arg.••If BUFFER exists but shell process is not running, make new shell.•If BUFFER exists and shell process is running, just switch to BUFFER.•Program used comes from variable `explicit-shell-file-name',• or (if that is nil) from the ESHELL environment variable,• or (if that is nil) from `shell-file-name'.•If a file `~/.emacs_SHELLNAME' exists, or `~/.emacs.d/init_SHELLNAME.sh',•it is given as initial input (but this may be lost, due to a timing•error, if the shell discards input when it starts up).•The buffer is put in Shell mode, giving commands for sending input•and controlling the subjobs of the shell.  See `shell-mode'.•See also the variable `shell-prompt-pattern'.••To specify a coding system for converting non-ASCII characters•in the input and output to the shell, use C-x RET c•before &lt;menu&gt; &lt;f12&gt;.  You can also specify this with C-x RET p•in the shell buffer, after you start the shell.•The default comes from `process-coding-system-alist' and•`default-process-coding-system'.••The shell file name (sans directories) is used to make a symbol name•such as `explicit-csh-args'.  If that symbol is a variable,•its value is used as a list of arguments when invoking the shell.•Otherwise, one argument `-i' is passed to the shell.••(Type M-x describe-mode in the shell buffer for a list of commands.)",
"shell-command":"shell-command is an interactive compiled Lisp function in `simple.el'.••(shell-command COMMAND &amp;optional OUTPUT-BUFFER ERROR-BUFFER)••Execute string COMMAND in inferior shell; display output, if any.•With prefix argument, insert the COMMAND's output at point.••If COMMAND ends in `&amp;', execute it asynchronously.•The output appears in the buffer `*Async Shell Command*'.•That buffer is in shell mode.  You can also use•`async-shell-command' that automatically adds `&amp;'.••Otherwise, COMMAND is executed synchronously.  The output appears in•the buffer `*Shell Command Output*'.  If the output is short enough to•display in the echo area (which is determined by the variables•`resize-mini-windows' and `max-mini-window-height'), it is shown•there, but it is nonetheless available in buffer `*Shell Command•Output*' even though that buffer is not automatically displayed.••To specify a coding system for converting non-ASCII characters•in the shell command output, use C-x RET c before this command.••Noninteractive callers can specify coding systems by binding•`coding-system-for-read' and `coding-system-for-write'.••The optional second argument OUTPUT-BUFFER, if non-nil,•says to put the output in some other buffer.•If OUTPUT-BUFFER is a buffer or buffer name, put the output there.•If OUTPUT-BUFFER is not a buffer and not nil,•insert output in current buffer.  (This cannot be done asynchronously.)•In either case, the buffer is first erased, and the output is•inserted after point (leaving mark after it).••If the command terminates without error, but generates output,•and you did not specify ⧷&quoteinsert it in the current buffer⧷&quote,•the output can be displayed in the echo area or in its buffer.•If the output is short enough to display in the echo area•(determined by the variable `max-mini-window-height' if•`resize-mini-windows' is non-nil), it is shown there.•Otherwise,the buffer containing the output is displayed.••If there is output and an error, and you did not specify ⧷&quoteinsert it•in the current buffer⧷&quote, a message about the error goes at the end•of the output.••If there is no output, or if output is inserted in the current buffer,•then `*Shell Command Output*' is deleted.••If the optional third argument ERROR-BUFFER is non-nil, it is a buffer•or buffer name to which to direct the command's standard error output.•If it is nil, error output is mingled with regular output.•In an interactive call, the variable `shell-command-default-error-buffer'•specifies the value of ERROR-BUFFER.••In Elisp, you will often be better served by calling `call-process' or•`start-process' directly, since it offers more control and does not impose•the use of a shell (with its need to quote arguments).",
"shell-command-on-region":"shell-command-on-region is an interactive compiled Lisp function in•`simple.el'.••(shell-command-on-region START END COMMAND &amp;optional OUTPUT-BUFFER•REPLACE ERROR-BUFFER DISPLAY-ERROR-BUFFER)••Execute string COMMAND in inferior shell with region as input.•Normally display output (if any) in temp buffer `*Shell Command Output*';•Prefix arg means replace the region with it.  Return the exit code of•COMMAND.••To specify a coding system for converting non-ASCII characters•in the input and output to the shell command, use C-x RET c•before this command.  By default, the input (from the current buffer)•is encoded using coding-system specified by `process-coding-system-alist',•falling back to `default-process-coding-system' if no match for COMMAND•is found in `process-coding-system-alist'.••Noninteractive callers can specify coding systems by binding•`coding-system-for-read' and `coding-system-for-write'.••If the command generates output, the output may be displayed•in the echo area or in a buffer.•If the output is short enough to display in the echo area•(determined by the variable `max-mini-window-height' if•`resize-mini-windows' is non-nil), it is shown there.•Otherwise it is displayed in the buffer `*Shell Command Output*'.•The output is available in that buffer in both cases.••If there is output and an error, a message about the error•appears at the end of the output.  If there is no output, or if•output is inserted in the current buffer, the buffer `*Shell•Command Output*' is deleted.••Optional fourth arg OUTPUT-BUFFER specifies where to put the•command's output.  If the value is a buffer or buffer name, put•the output there.  Any other value, including nil, means to•insert the output in the current buffer.  In either case, the•output is inserted after point (leaving mark after it).••Optional fifth arg REPLACE, if non-nil, means to insert the•output in place of text from START to END, putting point and mark•around it.••Optional sixth arg ERROR-BUFFER, if non-nil, specifies a buffer•or buffer name to which to direct the command's standard error•output.  If nil, error output is mingled with regular output.•When called interactively, `shell-command-default-error-buffer'•is used for ERROR-BUFFER.••Optional seventh arg DISPLAY-ERROR-BUFFER, if non-nil, means to•display the error buffer if there were any errors.  When called•interactively, this is t.",
"shell-command-to-string":"shell-command-to-string is a compiled Lisp function in `simple.el'.••(shell-command-to-string COMMAND)••Execute shell command COMMAND and return its output as a string.",
"show-paren-mode":"show-paren-mode is an interactive autoloaded compiled Lisp function in•`paren.el'.••(show-paren-mode &amp;optional ARG)••Toggle visualization of matching parens (Show Paren mode).•With a prefix argument ARG, enable Show Paren mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••Show Paren mode is a global minor mode.  When enabled, any•matching parenthesis is highlighted in `show-paren-style' after•`show-paren-delay' seconds of Emacs idle time.",
"shrink-window":"shrink-window is an interactive compiled Lisp function in `window.el'.••(shrink-window DELTA &amp;optional HORIZONTAL)••Make the selected window DELTA lines smaller.•Interactively, if no argument is given, make the selected window•one line smaller.  If optional argument HORIZONTAL is non-nil,•make selected window narrower by DELTA columns.  If DELTA is•negative, enlarge selected window by -DELTA lines or columns.•Also see the `window-min-height' variable.",
"shrink-window-horizontally":"shrink-window-horizontally is an interactive compiled Lisp function in•`window.el'.••(shrink-window-horizontally DELTA)••Make selected window DELTA columns narrower.•Interactively, if no argument is given, make selected window one•column narrower.",
"shrink-window-if-larger-than-buffer":"shrink-window-if-larger-than-buffer is an interactive compiled Lisp•function in `window.el'.••(shrink-window-if-larger-than-buffer &amp;optional WINDOW)••Shrink height of WINDOW if its buffer doesn't need so many lines.•More precisely, shrink WINDOW vertically to be as small as•possible, while still showing the full contents of its buffer.•WINDOW must be a live window and defaults to the selected one.••Do not shrink WINDOW to less than `window-min-height' lines.  Do•nothing if the buffer contains more lines than the present window•height, or if some of the window's contents are scrolled out of•view, or if shrinking this window would also shrink another•window, or if the window is the only window of its frame.••Return non-nil if the window was shrunk, nil otherwise.",
"skip-chars-backward":"skip-chars-backward is a built-in function in `C source code'.••(skip-chars-backward STRING &amp;optional LIM)••Move point backward, stopping after a char not in STRING, or at pos LIM.•See `skip-chars-forward' for details.•Returns the distance traveled, either zero or negative.",
"skip-chars-forward":"skip-chars-forward is a built-in function in `C source code'.••(skip-chars-forward STRING &amp;optional LIM)••Move point forward, stopping before a char not in STRING, or at pos LIM.•STRING is like the inside of a `[...]' in a regular expression•except that `]' is never special and `⧷' quotes `^', `-' or `⧷'• (but not at the end of a range; quoting is never needed there).•Thus, with arg ⧷&quotea-zA-Z⧷&quote, this skips letters stopping before first nonletter.•With arg ⧷&quote^a-zA-Z⧷&quote, skips nonletters stopping before first letter.•Char classes, e.g. `[:alpha:]', are supported.••Returns the distance traveled, either zero or positive.",
"sleep-for":"sleep-for is a built-in function in `C source code'.••(sleep-for SECONDS &amp;optional MILLISECONDS)••Pause, without updating display, for SECONDS seconds.•SECONDS may be a floating-point value, meaning that you can wait for a•fraction of a second.  Optional second arg MILLISECONDS specifies an•additional wait period, in milliseconds; this is for backwards compatibility.•(Not all operating systems support waiting for a fraction of a second.)",
"smex":"smex is an interactive Lisp function in `smex.el'.••(smex)••Not documented.",
"snippet-mode":"snippet-mode is an interactive Lisp function in `yasnippet.el'.••(snippet-mode)••Parent mode: `text-mode'.••A mode for editing yasnippets••In addition to any hooks its parent mode `text-mode' might have run,•this mode runs the hook `snippet-mode-hook', as the final step•during initialization.••key             binding•---             -------••C-c             Prefix Command••C-c C-c         yas/load-snippet-buffer•C-c C-t         yas/tryout-snippet••",
"soft-wrap-lines":"soft-wrap-lines is an interactive Lisp function in•`init_functions.el'.••(soft-wrap-lines)••Make lines wrap at window edge and on word boundary,•in current buffer.",
"sort":"sort is a built-in function in `C source code'.••(sort LIST PREDICATE)••Sort LIST, stably, comparing elements using PREDICATE.•Returns the sorted list.  LIST is modified by side effects.•PREDICATE is called with two elements of LIST, and should return non-nil•if the first element should sort before the second.",
"sort-columns":"sort-columns is an interactive autoloaded compiled Lisp function in•`sort.el'.••(sort-columns REVERSE &amp;optional BEG END)••Sort lines in region alphabetically by a certain range of columns.•For the purpose of this command, the region BEG...END includes•the entire line that point is in and the entire line the mark is in.•The column positions of point and mark bound the range of columns to sort on.•A prefix argument means sort into REVERSE order.•The variable `sort-fold-case' determines whether alphabetic case affects•the sort order.••Note that `sort-columns' rejects text that contains tabs,•because tabs could be split across the specified columns•and it doesn't know how to handle that.  Also, when possible,•it uses the `sort' utility program, which doesn't understand tabs.•Use M-x untabify to convert tabs to spaces before sorting.",
"sort-fields":"sort-fields is an interactive autoloaded compiled Lisp function in•`sort.el'.••(sort-fields FIELD BEG END)••Sort lines in region lexicographically by the ARGth field of each line.•Fields are separated by whitespace and numbered from 1 up.•With a negative arg, sorts by the ARGth field counted from the right.•Called from a program, there are three arguments:•FIELD, BEG and END.  BEG and END specify region to sort.•The variable `sort-fold-case' determines whether alphabetic case affects•the sort order.",
"sort-lines":"sort-lines is an interactive autoloaded compiled Lisp function in•`sort.el'.••(sort-lines REVERSE BEG END)••Sort lines in region alphabetically; argument means descending order.•Called from a program, there are three arguments:•REVERSE (non-nil means reverse order), BEG and END (region to sort).•The variable `sort-fold-case' determines whether alphabetic case affects•the sort order.",
"sort-numeric-fields":"sort-numeric-fields is an interactive autoloaded compiled Lisp•function in `sort.el'.••(sort-numeric-fields FIELD BEG END)••Sort lines in region numerically by the ARGth field of each line.•Fields are separated by whitespace and numbered from 1 up.•Specified field must contain a number in each line of the region,•which may begin with ⧷&quote0x⧷&quote or ⧷&quote0⧷&quote for hexadecimal and octal values.•Otherwise, the number is interpreted according to sort-numeric-base.•With a negative arg, sorts by the ARGth field counted from the right.•Called from a program, there are three arguments:•FIELD, BEG and END.  BEG and END specify region to sort.",
"sort-pages":"sort-pages is an interactive autoloaded compiled Lisp function in•`sort.el'.••(sort-pages REVERSE BEG END)••Sort pages in region alphabetically; argument means descending order.•Called from a program, there are three arguments:•REVERSE (non-nil means reverse order), BEG and END (region to sort).•The variable `sort-fold-case' determines whether alphabetic case affects•the sort order.",
"sort-paragraphs":"sort-paragraphs is an interactive autoloaded compiled Lisp function in•`sort.el'.••(sort-paragraphs REVERSE BEG END)••Sort paragraphs in region alphabetically; argument means descending order.•Called from a program, there are three arguments:•REVERSE (non-nil means reverse order), BEG and END (region to sort).•The variable `sort-fold-case' determines whether alphabetic case affects•the sort order.",
"sort-regexp-fields":"sort-regexp-fields is an interactive autoloaded compiled Lisp function•in `sort.el'.••(sort-regexp-fields REVERSE RECORD-REGEXP KEY-REGEXP BEG END)••Sort the text in the region region lexicographically.•If called interactively, prompt for two regular expressions,•RECORD-REGEXP and KEY-REGEXP.••RECORD-REGEXP specifies the textual units to be sorted.•  For example, to sort lines, RECORD-REGEXP would be ⧷&quote^.*$⧷&quote.••KEY-REGEXP specifies the part of each record (i.e. each match for•  RECORD-REGEXP) to be used for sorting.•  If it is ⧷&quote⧷⧷digit⧷&quote, use the digit'th ⧷&quote⧷⧷(...⧷⧷)⧷&quote•  match field specified by RECORD-REGEXP.•  If it is ⧷&quote⧷⧷&amp;⧷&quote, use the whole record.•  Otherwise, KEY-REGEXP should be a regular expression with which•  to search within the record.  If a match for KEY-REGEXP is not•  found within a record, that record is ignored.••With a negative prefix arg, sort in reverse order.••The variable `sort-fold-case' determines whether alphabetic case affects•the sort order.••For example: to sort lines in the region by the first word on each line• starting with the letter ⧷&quotef⧷&quote,• RECORD-REGEXP would be ⧷&quote^.*$⧷&quote and KEY would be ⧷&quote⧷⧷&lt;f⧷⧷w*⧷⧷&gt;⧷&quote",
"split-string":"split-string is a compiled Lisp function in `subr.el'.••(split-string STRING &amp;optional SEPARATORS OMIT-NULLS)••Split STRING into substrings bounded by matches for SEPARATORS.••The beginning and end of STRING, and each match for SEPARATORS, are•splitting points.  The substrings matching SEPARATORS are removed, and•the substrings between the splitting points are collected as a list,•which is returned.••If SEPARATORS is non-nil, it should be a regular expression matching text•which separates, but is not part of, the substrings.  If nil it defaults to•`split-string-default-separators', normally ⧷&quote[ ⧷f⧷t⧷n⧷r⧷v]+⧷&quote, and•OMIT-NULLS is forced to t.••If OMIT-NULLS is t, zero-length substrings are omitted from the list (so•that for the default value of SEPARATORS leading and trailing whitespace•are effectively trimmed).  If nil, all zero-length substrings are retained,•which correctly parses CSV format, for example.••Note that the effect of `(split-string STRING)' is the same as•`(split-string STRING split-string-default-separators t)'.  In the rare•case that you wish to retain zero-length substrings when splitting on•whitespace, use `(split-string STRING split-string-default-separators)'.••Modifies the match data; use `save-match-data' if necessary.",
"split-window-below":"split-window-below is an interactive compiled Lisp function in•`window.el'.••(split-window-below &amp;optional SIZE)••Split the selected window into two windows, one above the other.•The selected window is above.  The newly split-off window is•below, and displays the same buffer.  Return the new window.••If optional argument SIZE is omitted or nil, both windows get the•same height, or close to it.  If SIZE is positive, the upper•(selected) window gets SIZE lines.  If SIZE is negative, the•lower (new) window gets -SIZE lines.••If the variable `split-window-keep-point' is non-nil, both•windows get the same value of point as the selected window.•Otherwise, the window starts are chosen so as to minimize the•amount of redisplay; this is convenient on slow terminals.",
"split-window-horizontally":"split-window-horizontally is an alias for `split-window-right' in•`window.el'.••(split-window-horizontally &amp;optional SIZE)••Split the selected window into two side-by-side windows.•The selected window is on the left.  The newly split-off window•is on the right, and displays the same buffer.  Return the new•window.••If optional argument SIZE is omitted or nil, both windows get the•same width, or close to it.  If SIZE is positive, the left-hand•(selected) window gets SIZE columns.  If SIZE is negative, the•right-hand (new) window gets -SIZE columns.  Here, SIZE includes•the width of the window's scroll bar; if there are no scroll•bars, it includes the width of the divider column to the window's•right, if any.",
"split-window-right":"split-window-right is an interactive compiled Lisp function in•`window.el'.••(split-window-right &amp;optional SIZE)••Split the selected window into two side-by-side windows.•The selected window is on the left.  The newly split-off window•is on the right, and displays the same buffer.  Return the new•window.••If optional argument SIZE is omitted or nil, both windows get the•same width, or close to it.  If SIZE is positive, the left-hand•(selected) window gets SIZE columns.  If SIZE is negative, the•right-hand (new) window gets -SIZE columns.  Here, SIZE includes•the width of the window's scroll bar; if there are no scroll•bars, it includes the width of the divider column to the window's•right, if any.",
"split-window-vertically":"split-window-vertically is an alias for `split-window-below' in•`window.el'.••(split-window-vertically &amp;optional SIZE)••Split the selected window into two windows, one above the other.•The selected window is above.  The newly split-off window is•below, and displays the same buffer.  Return the new window.••If optional argument SIZE is omitted or nil, both windows get the•same height, or close to it.  If SIZE is positive, the upper•(selected) window gets SIZE lines.  If SIZE is negative, the•lower (new) window gets -SIZE lines.••If the variable `split-window-keep-point' is non-nil, both•windows get the same value of point as the selected window.•Otherwise, the window starts are chosen so as to minimize the•amount of redisplay; this is convenient on slow terminals.",
"start-kbd-macro":"start-kbd-macro is an interactive built-in function in `C source•code'.••(start-kbd-macro APPEND &amp;optional NO-EXEC)••Record subsequent keyboard input, defining a keyboard macro.•The commands are recorded even as they are executed.•Use M-x end-kbd-macro to finish recording and make the macro available.•Use M-x name-last-kbd-macro to give it a permanent name.•Non-nil arg (prefix arg) means append to last macro defined;•this begins by re-executing that macro as if you typed it again.•If optional second arg, NO-EXEC, is non-nil, do not re-execute last•macro before appending to it.",
"start-process":"start-process is a built-in function in `C source code'.••(start-process NAME BUFFER PROGRAM &amp;rest PROGRAM-ARGS)••Start a program in a subprocess.  Return the process object for it.•NAME is name for process.  It is modified if necessary to make it unique.•BUFFER is the buffer (or buffer name) to associate with the process.••Process output (both standard output and standard error streams) goes•at end of BUFFER, unless you specify an output stream or filter•function to handle the output.  BUFFER may also be nil, meaning that•this process is not associated with any buffer.••PROGRAM is the program file name.  It is searched for in `exec-path'•(which see).  If nil, just associate a pty with the buffer.  Remaining•arguments are strings to give program as arguments.••If you want to separate standard output from standard error, invoke•the command through a shell and redirect one of them using the shell•syntax.",
"start-process-shell-command":"start-process-shell-command is a compiled Lisp function in `subr.el'.••(start-process-shell-command NAME BUFFER COMMAND)••Start a program in a subprocess.  Return the process object for it.•NAME is name for process.  It is modified if necessary to make it unique.•BUFFER is the buffer (or buffer name) to associate with the process.• Process output goes at end of that buffer, unless you specify• an output stream or filter function to handle the output.• BUFFER may be also nil, meaning that this process is not associated• with any buffer•COMMAND is the shell command to run.••An old calling convention accepted any number of arguments after COMMAND,•which were just concatenated to COMMAND.  This is still supported but strongly•discouraged.",
"string":"string is a built-in function in `C source code'.••(string &amp;rest CHARACTERS)••Concatenate all the argument characters and make the result a string.",
"string=":"string= is an alias for `string-equal' in `subr.el'.••(string= S1 S2)••Return t if two strings have identical contents.•Case is significant, but text properties are ignored.•Symbols are also allowed; their print names are used instead.",
"string-equal":"string-equal is a built-in function in `C source code'.••(string-equal S1 S2)••Return t if two strings have identical contents.•Case is significant, but text properties are ignored.•Symbols are also allowed; their print names are used instead.",
"string-insert-rectangle":"string-insert-rectangle is an interactive autoloaded compiled Lisp•function in `rect.el'.••(string-insert-rectangle START END STRING)••Insert STRING on each line of region-rectangle, shifting text right.••When called from a program, the rectangle's corners are START and END.•The left edge of the rectangle specifies the column for insertion.•This command does not delete or overwrite any existing text.",
"string-match":"string-match is a built-in function in `C source code'.••(string-match REGEXP STRING &amp;optional START)••Return index of start of first match for REGEXP in STRING, or nil.•Matching ignores case if `case-fold-search' is non-nil.•If third arg START is non-nil, start search at that index in STRING.•For index of first char beyond the match, do (match-end 0).•`match-end' and `match-beginning' also give indices of substrings•matched by parenthesis constructs in the pattern.••You can use the function `match-string' to extract the substrings•matched by the parenthesis constructions in REGEXP.",
"string-match-p":"string-match-p is a compiled Lisp function in `subr.el'.••(string-match-p REGEXP STRING &amp;optional START)••Same as `string-match' except this function does not change the match data.",
"string-rectangle":"string-rectangle is an interactive autoloaded compiled Lisp function•in `rect.el'.••(string-rectangle START END STRING)••Replace rectangle contents with STRING on each line.•The length of STRING need not be the same as the rectangle width.••Called from a program, takes three args; START, END and STRING.",
"string-to-number":"string-to-number is a built-in function in `C source code'.••(string-to-number STRING &amp;optional BASE)••Parse STRING as a decimal number and return the number.•This parses both integers and floating point numbers.•It ignores leading spaces and tabs, and all trailing chars.••If BASE, interpret STRING as a number in that base.  If BASE isn't•present, base 10 is used.  BASE must be between 2 and 16 (inclusive).•If the base used is not 10, STRING is always parsed as integer.",
"subrp":"subrp is a built-in function in `C source code'.••(subrp OBJECT)••Return t if OBJECT is a built-in function.",
"substring":"substring is a built-in function in `C source code'.••(substring STRING FROM &amp;optional TO)••Return a new string whose contents are a substring of STRING.•The returned string consists of the characters between index FROM•(inclusive) and index TO (exclusive) of STRING.  FROM and TO are•zero-indexed: 0 means the first character of STRING.  Negative values•are counted from the end of STRING.  If TO is nil, the substring runs•to the end of STRING.••The STRING argument may also be a vector.  In that case, the return•value is a new vector that contains the elements between index FROM•(inclusive) and index TO (exclusive) of that vector argument.",
"substring-no-properties":"substring-no-properties is a built-in function in `C source code'.••(substring-no-properties STRING &amp;optional FROM TO)••Return a substring of STRING, without text properties.•It starts at index FROM and ends before TO.•TO may be nil or omitted; then the substring runs to the end of STRING.•If FROM is nil or omitted, the substring starts at the beginning of STRING.•If FROM or TO is negative, it counts from the end.••With one argument, just copy STRING without its properties.",
"switch-to-buffer":"switch-to-buffer is an interactive compiled Lisp function in•`window.el'.••(switch-to-buffer BUFFER-OR-NAME &amp;optional NORECORD FORCE-SAME-WINDOW)••Display buffer BUFFER-OR-NAME in the selected window.••WARNING: This is NOT the way to work on another buffer temporarily•within a Lisp program!  Use `set-buffer' instead.  That avoids•messing with the window-buffer correspondences.••If the selected window cannot display the specified•buffer (e.g. if it is a minibuffer window or strongly dedicated•to another buffer), call `pop-to-buffer' to select the buffer in•another window.••If called interactively, read the buffer name using the•minibuffer.  The variable `confirm-nonexistent-file-or-buffer'•determines whether to request confirmation before creating a new•buffer.••BUFFER-OR-NAME may be a buffer, a string (a buffer name), or nil.•If BUFFER-OR-NAME is a string that does not identify an existing•buffer, create a buffer with that name.  If BUFFER-OR-NAME is•nil, switch to the buffer returned by `other-buffer'.••If optional argument NORECORD is non-nil, do not put the buffer•at the front of the buffer list, and do not make the window•displaying it the most recently selected one.••If optional argument FORCE-SAME-WINDOW is non-nil, the buffer•must be displayed in the selected window; if that is impossible,•signal an error rather than calling `pop-to-buffer'.••The option `switch-to-buffer-preserve-window-point' can be used•to make the buffer appear at its last position in the selected•window.••Return the buffer switched to.",
"symbol-function":"symbol-function is a built-in function in `C source code'.••(symbol-function SYMBOL)••Return SYMBOL's function definition.  Error if that is void.",
"symbol-name":"symbol-name is a built-in function in `C source code'.••(symbol-name SYMBOL)••Return SYMBOL's name, a string.",
"symbolp":"symbolp is a built-in function in `C source code'.••(symbolp OBJECT)••Return t if OBJECT is a symbol.",
"symbol-plist":"symbol-plist is a built-in function in `C source code'.••(symbol-plist SYMBOL)••Return SYMBOL's property list.",
"symbol-value":"symbol-value is a built-in function in `C source code'.••(symbol-value SYMBOL)••Return SYMBOL's value.  Error if that is void.•Note that if `lexical-binding' is in effect, this returns the•global value outside of any lexical scope.",
"tabify":"tabify is an interactive autoloaded compiled Lisp function in•`tabify.el'.••(tabify START END)••Convert multiple spaces in region to tabs when possible.•A group of spaces is partially replaced by tabs•when this can be done without changing the column they end at.•Called non-interactively, the region is specified by arguments•START and END, rather than by the position of point and mark.•The variable `tab-width' controls the spacing of tab stops.",
"table-capture":"table-capture is an interactive autoloaded compiled Lisp function in•`table.el'.••(table-capture BEG END &amp;optional COL-DELIM-REGEXP ROW-DELIM-REGEXP•JUSTIFY MIN-CELL-WIDTH COLUMNS)••Convert plain text into a table by capturing the text in the region.•Create a table with the text in region as cell contents.  BEG and END•specify the region.  The text in the region is replaced with a table.•The removed text is inserted in the table.  When optional•COL-DELIM-REGEXP and ROW-DELIM-REGEXP are provided the region contents•is parsed and separated into individual cell contents by using the•delimiter regular expressions.  This parsing determines the number of•columns and rows of the table automatically.  If COL-DELIM-REGEXP and•ROW-DELIM-REGEXP are omitted the result table has only one cell and•the entire region contents is placed in that cell.  Optional JUSTIFY•is one of 'left, 'center or 'right, which specifies the cell•justification.  Optional MIN-CELL-WIDTH specifies the minimum cell•width.  Optional COLUMNS specify the number of columns when•ROW-DELIM-REGEXP is not specified.•••Example 1:••1, 2, 3, 4•5, 6, 7, 8•, 9, 10••Running `table-capture' on above 3 line region with COL-DELIM-REGEXP•⧷&quote,⧷&quote and ROW-DELIM-REGEXP ⧷&quote⧷n⧷&quote creates the following table.  In•this example the cells are centered and minimum cell width is•specified as 5.••+-----+-----+-----+-----+•|  1  |  2  |  3  |  4  |•+-----+-----+-----+-----+•|  5  |  6  |  7  |  8  |•+-----+-----+-----+-----+•|     |  9  | 10  |     |•+-----+-----+-----+-----+••Note:••In case the function is called interactively user must use C-q `quoted-insert'•in order to enter ⧷&quote⧷n⧷&quote successfully.  COL-DELIM-REGEXP at the end•of each row is optional.•••Example 2:••This example shows how a table can be used for text layout editing.•Let `table-capture' capture the following region starting from•-!- and ending at -*-, that contains three paragraphs and two item•name headers.  This time specify empty string for both•COL-DELIM-REGEXP and ROW-DELIM-REGEXP.••-!-`table-capture' is a powerful command however mastering its power•requires some practice.  Here is a list of items what it can do.••Parse Cell Items      By using column delimiter regular•		      expression and raw delimiter regular•		      expression, it parses the specified text•		      area and extracts cell items from•		      non-table text and then forms a table out•		      of them.••Capture Text Area     When no delimiters are specified it•		      creates a single cell table.  The text in•		      the specified region is placed in that•		      cell.-*-••Now the entire content is captured in a cell which is itself a table•like this.••+-----------------------------------------------------------------+•|`table-capture' is a powerful command however mastering its power|•|requires some practice.  Here is a list of items what it can do. |•|                                                                 |•|Parse Cell Items      By using column delimiter regular          |•|                      expression and raw delimiter regular       |•|                      expression, it parses the specified text   |•|                      area and extracts cell items from          |•|                      non-table text and then forms a table out  |•|                      of them.                                   |•|                                                                 |•|Capture Text Area     When no delimiters are specified it        |•|                      creates a single cell table.  The text in  |•|                      the specified region is placed in that     |•|                      cell.                                      |•+-----------------------------------------------------------------+••By splitting the cell appropriately we now have a table consisting of•paragraphs occupying its own cell.  Each cell can now be edited•independently.••+-----------------------------------------------------------------+•|`table-capture' is a powerful command however mastering its power|•|requires some practice.  Here is a list of items what it can do. |•+---------------------+-------------------------------------------+•|Parse Cell Items     |By using column delimiter regular          |•|                     |expression and raw delimiter regular       |•|                     |expression, it parses the specified text   |•|                     |area and extracts cell items from          |•|                     |non-table text and then forms a table out  |•|                     |of them.                                   |•+---------------------+-------------------------------------------+•|Capture Text Area    |When no delimiters are specified it        |•|                     |creates a single cell table.  The text in  |•|                     |the specified region is placed in that     |•|                     |cell.                                      |•+---------------------+-------------------------------------------+••By applying `table-release', which does the opposite process, the•contents become once again plain text.  `table-release' works as•companion command to `table-capture' this way.",
"table-delete-column":"table-delete-column is an interactive autoloaded compiled Lisp•function in `table.el'.••(table-delete-column N)••Delete N column(s) of cells.•Delete N columns of cells from current column.  The current column is•the column contains the current cell where point is located.  Each•column must consists from cells of same width.",
"table-delete-row":"table-delete-row is an interactive autoloaded compiled Lisp function•in `table.el'.••(table-delete-row N)••Delete N row(s) of cells.•Delete N rows of cells from current row.  The current row is the row•contains the current cell where point is located.  Each row must•consists from cells of same height.",
"table-generate-source":"table-generate-source is an interactive autoloaded compiled Lisp•function in `table.el'.••(table-generate-source LANGUAGE &amp;optional DEST-BUFFER CAPTION)••Generate source of the current table in the specified language.•LANGUAGE is a symbol that specifies the language to describe the•structure of the table.  It must be either 'html, 'latex or 'cals.•The resulted source text is inserted into DEST-BUFFER and the buffer•object is returned.  When DEST-BUFFER is omitted or nil the default•buffer specified in `table-dest-buffer-name' is used.  In this case•the content of the default buffer is erased prior to the generation.•When DEST-BUFFER is non-nil it is expected to be either a destination•buffer or a name of the destination buffer.  In this case the•generated result is inserted at the current point in the destination•buffer and the previously existing contents in the buffer are•untouched.••References used for this implementation:••HTML:•        URL `http://www.w3.org'••LaTeX:•        URL `http://www.maths.tcd.ie/~dwilkins/LaTeXPrimer/Tables.html'••CALS (DocBook DTD):•        URL `http://www.oasis-open.org/html/a502.htm'•        URL `http://www.oreilly.com/catalog/docbook/chapter/book/table.html#AEN114751'",
"table-insert":"table-insert is an interactive autoloaded compiled Lisp function in•`table.el'.••(table-insert COLUMNS ROWS &amp;optional CELL-WIDTH CELL-HEIGHT)••Insert an editable text table.•Insert a table of specified number of COLUMNS and ROWS.  Optional•parameter CELL-WIDTH and CELL-HEIGHT can specify the size of each•cell.  The cell size is uniform across the table if the specified size•is a number.  They can be a list of numbers to specify different size•for each cell.  When called interactively, the list of number is•entered by simply listing all the numbers with space characters•delimiting them.••Examples:••M-x table-insert inserts a table at the current point location.••Suppose we have the following situation where `-!-' indicates the•location of point.••    -!-••Type M-x table-insert and hit ENTER key.  As it asks table•specification, provide 3 for number of columns, 1 for number of rows,•5 for cell width and 1 for cell height.  Now you shall see the next•table and the point is automatically moved to the beginning of the•first cell.••    +-----+-----+-----+•    |-!-  |     |     |•    +-----+-----+-----+••Inside a table cell, there are special key bindings. •Uses keymap `table-cell-map', which is not currently defined.•••M-9 M-x table-widen-cell (or C-u 9 M-x table-widen-cell) widens the first cell by 9 character•width, which results as••    +--------------+-----+-----+•    |-!-           |     |     |•    +--------------+-----+-----+••Type TAB M-x table-widen-cell then type TAB M-2 M-7 M-x table-widen-cell (or C-u 2 7 M-x table-widen-cell).  Typing•TAB moves the point forward by a cell. The result now looks like this:••    +--------------+------+--------------------------------+•    |              |      |-!-                             |•    +--------------+------+--------------------------------+••If you knew each width of the columns prior to the table creation,•what you could have done better was to have had given the complete•width information to `table-insert'.••Cell width(s): 14 6 32••instead of••Cell width(s): 5••This would have eliminated the previously mentioned width adjustment•work all together.••If the point is in the last cell type S-TAB S-TAB to move it to the•first cell.  Now type M-x table-heighten-cell which heighten the row by a line.••    +--------------+------+--------------------------------+•    |-!-           |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+••Type M-x table-insert-row-column and tell it to insert a row.••    +--------------+------+--------------------------------+•    |-!-           |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+•    |              |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+••Move the point under the table as shown below.••    +--------------+------+--------------------------------+•    |              |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+•    |              |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+•    -!-••Type M-x table-insert-row instead of M-x table-insert-row-column.  M-x table-insert-row-column does not work•when the point is outside of the table.  This insertion at•outside of the table effectively appends a row at the end.••    +--------------+------+--------------------------------+•    |              |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+•    |              |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+•    |-!-           |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+••Text editing inside the table cell produces reasonably expected•results.••    +--------------+------+--------------------------------+•    |              |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+•    |              |      |Text editing inside the table   |•    |              |      |cell produces reasonably        |•    |              |      |expected results.-!-            |•    +--------------+------+--------------------------------+•    |              |      |                                |•    |              |      |                                |•    +--------------+------+--------------------------------+••Inside a table cell has a special keymap.•••Uses keymap `table-cell-map', which is not currently defined.•",
"table-insert-column":"table-insert-column is an interactive autoloaded compiled Lisp•function in `table.el'.••(table-insert-column N)••Insert N table column(s).•When point is in a table the newly inserted column(s) are placed left•of the current column.  When point is outside of the table it must be•right side of the table within the table height range, then the newly•created column(s) are appended at the right of the table.",
"table-insert-row":"table-insert-row is an interactive autoloaded compiled Lisp function•in `table.el'.••(table-insert-row N)••Insert N table row(s).•When point is in a table the newly inserted row(s) are placed above•the current row.  When point is outside of the table it must be below•the table within the table width range, then the newly created row(s)•are appended at the bottom of the table.",
"table-release":"table-release is an interactive autoloaded compiled Lisp function in•`table.el'.••(table-release)••Convert a table into plain text by removing the frame from a table.•Remove the frame from a table and deactivate the table.  This command•converts a table into plain text without frames.  It is a companion to•`table-capture' which does the opposite process.",
"tab-to-tab-stop":"tab-to-tab-stop is an interactive compiled Lisp function in•`indent.el'.••(tab-to-tab-stop)••Insert spaces or tabs to next defined tab-stop column.•The variable `tab-stop-list' is a list of columns at which there are tab stops.•Use M-x edit-tab-stops to edit them interactively.",
"tags-loop-continue":"tags-loop-continue is an interactive autoloaded compiled Lisp function•in `etags.el'.••(tags-loop-continue &amp;optional FIRST-TIME)••Continue last M-x tags-search or M-x tags-query-replace command.•Used noninteractively with non-nil argument to begin such a command (the•argument is passed to `next-file', which see).••Two variables control the processing we do on each file: the value of•`tags-loop-scan' is a form to be executed on each file to see if it is•interesting (it returns non-nil if so) and `tags-loop-operate' is a form to•evaluate to operate on an interesting file.  If the latter evaluates to•nil, we exit; otherwise we scan the next file.",
"tags-query-replace":"tags-query-replace is an interactive autoloaded compiled Lisp function•in `etags.el'.••(tags-query-replace FROM TO &amp;optional DELIMITED FILE-LIST-FORM)••Do `query-replace-regexp' of FROM with TO on all files listed in tags table.•Third arg DELIMITED (prefix arg) means replace only word-delimited matches.•If you exit (C-g, RET or q), you can resume the query replace•with the command &lt;C-kp-0&gt;.•Fourth arg FILE-LIST-FORM non-nil means initialize the replacement loop.•Fifth and sixth arguments START and END are accepted, for compatibility•with `query-replace-regexp', and ignored.••If FILE-LIST-FORM is non-nil, it is a form to evaluate to•produce the list of files to search.••See also the documentation of the variable `tags-file-name'.",
"term":"term is an interactive autoloaded compiled Lisp function in `term.el'.••(term PROGRAM)••Start a terminal-emulator in a new buffer.•The buffer is in Term mode; see `term-mode' for the•commands to use in that buffer.••Type C-c b to switch to another buffer.",
"text-mode":"text-mode is an interactive compiled Lisp function in `text-mode.el'.••(text-mode)••Major mode for editing text written for humans to read.•In this mode, paragraphs are delimited only by blank or white lines.•You can thus get the full benefit of adaptive filling• (see the variable `adaptive-fill-mode').•key             binding•---             -------••ESC             Prefix Command••C-M-i           ispell-complete-word•••Turning on Text mode runs the normal hook `text-mode-hook'.",
"thing-at-point":"thing-at-point is an autoloaded compiled Lisp function in•`thingatpt.el'.••(thing-at-point THING)••Return the THING at point.•THING should be a symbol specifying a type of syntactic entity.•Possibilities include `symbol', `list', `sexp', `defun',•`filename', `url', `email', `word', `sentence', `whitespace',•`line', `number', and `page'.••See the file `thingatpt.el' for documentation on how to define•a symbol as a valid THING.",
"throw":"throw is a built-in function in `C source code'.••(throw TAG VALUE)••Throw to the catch for TAG and return VALUE from it.•Both TAG and VALUE are evalled.",
"tmm-menubar":"tmm-menubar is an interactive autoloaded Lisp function in `tmm.el'.••(tmm-menubar &amp;optional X-POSITION)••Text-mode emulation of looking and choosing from a menubar.•See the documentation for `tmm-prompt'.•X-POSITION, if non-nil, specifies a horizontal position within the menu bar;•we make that menu bar item (the one at that position) the default choice.",
"toggle-case-fold-search":"toggle-case-fold-search is an interactive compiled Lisp function in•`menu-bar.el'.••(toggle-case-fold-search &amp;optional INTERACTIVELY)••Toggle whether to ignore letter-case in search commands.•In an interactive call, record this option as a candidate for saving•by ⧷&quoteSave Options⧷&quote in Custom buffers.",
"toggle-debug-on-error":"toggle-debug-on-error is an interactive compiled Lisp function in•`menu-bar.el'.••(toggle-debug-on-error &amp;optional INTERACTIVELY)••Toggle whether to enter Lisp debugger when an error is signaled.•In an interactive call, record this option as a candidate for saving•by ⧷&quoteSave Options⧷&quote in Custom buffers.",
"toggle-input-method":"toggle-input-method is an interactive compiled Lisp function in•`mule-cmds.el'.••(toggle-input-method &amp;optional ARG INTERACTIVE)••Enable or disable multilingual text input method for the current buffer.•Only one input method can be enabled at any time in a given buffer.••The normal action is to enable an input method if none was enabled,•and disable the current one otherwise.  Which input method to enable•can be determined in various ways--either the one most recently used,•or the one specified by `default-input-method', or as a last resort•by reading the name of an input method in the minibuffer.••With a prefix argument ARG, read an input method name with the minibuffer•and enable that one.  The default is the most recent input method specified•(not including the currently active input method, if any).••When called interactively, the optional argument INTERACTIVE is non-nil,•which marks the variable `default-input-method' as set for Custom buffers.",
"toggle-line-spacing":"toggle-line-spacing is an interactive compiled Lisp function in•`xah_emacs_font.el'.••(toggle-line-spacing)••Toggle line spacing between no extra space to extra half line height.",
"toggle-read-only":"toggle-read-only is an interactive compiled Lisp function in•`files.el'.••(toggle-read-only &amp;optional ARG INTERACTIVE)••This function is obsolete since 24.3;•use `read-only-mode' instead.••Not documented.",
"toggle-text-mode-auto-fill":"toggle-text-mode-auto-fill is an interactive compiled Lisp function in•`text-mode.el'.••(toggle-text-mode-auto-fill)••Toggle whether to use Auto Fill in Text mode and related modes.•This command affects all buffers that use modes related to Text mode,•both existing buffers and buffers that you subsequently create.",
"toggle-truncate-lines":"toggle-truncate-lines is an interactive compiled Lisp function in•`simple.el'.••(toggle-truncate-lines &amp;optional ARG)••Toggle truncating of long lines for the current buffer.•When truncating is off, long lines are folded.•With prefix argument ARG, truncate long lines if ARG is positive,•otherwise fold them.  Note that in side-by-side windows, this•command has no effect if `truncate-partial-width-windows' is•non-nil.",
"toggle-word-wrap":"toggle-word-wrap is an interactive compiled Lisp function in•`simple.el'.••(toggle-word-wrap &amp;optional ARG)••Toggle whether to use word-wrapping for continuation lines.•With prefix argument ARG, wrap continuation lines at word boundaries•if ARG is positive, otherwise wrap them at the right screen edge.•This command toggles the value of `word-wrap'.  It has no effect•if long lines are truncated.",
"transient-mark-mode":"transient-mark-mode is an interactive compiled Lisp function in•`simple.el'.••(transient-mark-mode &amp;optional ARG)••Toggle Transient Mark mode.•With a prefix argument ARG, enable Transient Mark mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•Transient Mark mode if ARG is omitted or nil.••Transient Mark mode is a global minor mode.  When enabled, the•region is highlighted whenever the mark is active.  The mark is•⧷&quotedeactivated⧷&quote by changing the buffer, and after certain other•operations that set the mark but whose main purpose is something•else--for example, incremental search, M-b, and M-B.••You can also deactivate the mark by typing C-g or•M-ESC ESC.••Many commands change their behavior when Transient Mark mode is•in effect and the mark is active, by acting on the region instead•of their usual default part of the buffer's text.  Examples of•such commands include M--, M-x flush-lines, M-x keep-lines,•M-5, M-%, M-x ispell, and C-x u.•To see the documentation of commands which are sensitive to the•Transient Mark mode, invoke C-h d and type ⧷&quotetransient⧷&quote•or ⧷&quotemark.*active⧷&quote at the prompt.",
"transpose-chars":"transpose-chars is an interactive compiled Lisp function in•`simple.el'.••(transpose-chars ARG)••Interchange characters around point, moving forward one character.•With prefix arg ARG, effect is to take character before point•and drag it forward past ARG other characters (backward if ARG negative).•If no argument and at end of line, the previous two chars are exchanged.",
"transpose-lines":"transpose-lines is an interactive compiled Lisp function in•`simple.el'.••(transpose-lines ARG)••Exchange current line and previous line, leaving point after both.•With argument ARG, takes previous line and moves it past ARG lines.•With argument 0, interchanges line point is in with line mark is in.",
"transpose-words":"transpose-words is an interactive compiled Lisp function in•`simple.el'.••(transpose-words ARG)••Interchange words around point, leaving point at end of them.•With prefix arg ARG, effect is to take word before or around point•and drag it forward past ARG other words (backward if ARG negative).•If ARG is zero, the words around or after point and around or after mark•are interchanged.",
"try-completion":"try-completion is a built-in function in `C source code'.••(try-completion STRING COLLECTION &amp;optional PREDICATE)••Return common substring of all completions of STRING in COLLECTION.•Test each possible completion specified by COLLECTION•to see if it begins with STRING.  The possible completions may be•strings or symbols.  Symbols are converted to strings before testing,•see `symbol-name'.•All that match STRING are compared together; the longest initial sequence•common to all these matches is the return value.•If there is no match at all, the return value is nil.•For a unique match which is exact, the return value is t.••If COLLECTION is an alist, the keys (cars of elements) are the•possible completions.  If an element is not a cons cell, then the•element itself is the possible completion.•If COLLECTION is a hash-table, all the keys that are strings or symbols•are the possible completions.•If COLLECTION is an obarray, the names of all symbols in the obarray•are the possible completions.••COLLECTION can also be a function to do the completion itself.•It receives three arguments: the values STRING, PREDICATE and nil.•Whatever it returns becomes the value of `try-completion'.••If optional third argument PREDICATE is non-nil,•it is used to test each possible match.•The match is a candidate only if PREDICATE returns non-nil.•The argument given to PREDICATE is the alist element•or the symbol from the obarray.  If COLLECTION is a hash-table,•predicate is called with two arguments: the key and the value.•Additionally to this predicate, `completion-regexp-list'•is used to further constrain the set of candidates.",
"tumme":"tumme is an alias for `image-dired-show-all-from-dir' in•`image-dired.el'.••(tumme DIR)••Make a preview buffer for all images in DIR and display it.•If the number of files in DIR matching `image-file-name-regexp'•exceeds `image-dired-show-all-from-dir-max-files', a warning will be•displayed.",
"ucs-insert":"ucs-insert is an alias for `insert-char' in `mule-cmds.el'.••(ucs-insert CHARACTER &amp;optional COUNT INHERIT)••This function is obsolete since 24.3;•use `insert-char' instead.••Insert COUNT copies of CHARACTER.•Interactively, prompt for CHARACTER.  You can specify CHARACTER in one•of these ways:•• - As its Unicode character name, e.g. ⧷&quoteLATIN SMALL LETTER A⧷&quote.•   Completion is available; if you type a substring of the name•   preceded by an asterisk `*', Emacs shows all names which include•   that substring, not necessarily at the beginning of the name.•• - As a hexadecimal code point, e.g. 263A.  Note that code points in•   Emacs are equivalent to Unicode up to 10FFFF (which is the limit of•   the Unicode code space).•• - As a code point with a radix specified with #, e.g. #o21430•   (octal), #x2318 (hex), or #10r8984 (decimal).••If called interactively, COUNT is given by the prefix argument.  If•omitted or nil, it defaults to 1.••Inserting the character(s) relocates point and before-insertion•markers in the same ways as the function `insert'.••The optional third argument INHERIT, if non-nil, says to inherit text•properties from adjoining text, if those properties are sticky.  If•called interactively, INHERIT is t.",
"undo":"undo is an interactive compiled Lisp function in `simple.el'.••(undo &amp;optional ARG)••Undo some previous changes.•Repeat this command to undo more changes.•A numeric ARG serves as a repeat count.••In Transient Mark mode when the mark is active, only undo changes within•the current region.  Similarly, when not in Transient Mark mode, just C-u•as an argument limits undo to changes within the current region.",
"undo-tree-mode":"undo-tree-mode is an interactive Lisp function in `undo-tree.el'.••(undo-tree-mode &amp;optional ARG)••Toggle undo-tree mode.•With no argument, this command toggles the mode.•A positive prefix argument turns the mode on.•A negative prefix argument turns it off.••Undo-tree-mode replaces Emacs' standard undo feature with a more•powerful yet easier to use version, that treats the undo history•as what it is: a tree.••The following keys are available in `undo-tree-mode':••  key             binding•---             -------••C-x             Prefix Command•ESC             Prefix Command•C-_             undo-tree-undo•C-/             undo-tree-undo•C-?             undo-tree-redo•&lt;remap&gt;         Prefix Command••C-x r           Prefix Command•C-x u           undo-tree-visualize••M-_             undo-tree-redo••&lt;remap&gt; &lt;redo&gt;  undo-tree-redo•&lt;remap&gt; &lt;undo&gt;  undo-tree-undo•&lt;remap&gt; &lt;undo-only&gt;             undo-tree-undo••C-x r U         undo-tree-restore-state-from-register•C-x r u         undo-tree-save-state-to-register••••Within the undo-tree visualizer, the following keys are available:••  key             binding•---             -------••C-b             undo-tree-visualize-switch-branch-left•C-f             undo-tree-visualize-switch-branch-right•C-n             undo-tree-visualize-redo•C-p             undo-tree-visualize-undo•C-q             undo-tree-visualizer-quit•,               undo-tree-visualizer-scroll-left•.               undo-tree-visualizer-scroll-right•&lt;               undo-tree-visualizer-scroll-left•&gt;               undo-tree-visualizer-scroll-right•b               undo-tree-visualize-switch-branch-left•f               undo-tree-visualize-switch-branch-right•n               undo-tree-visualize-redo•p               undo-tree-visualize-undo•q               undo-tree-visualizer-quit•s               undo-tree-visualizer-selection-mode•t               undo-tree-visualizer-toggle-timestamps•&lt;down&gt;          undo-tree-visualize-redo•&lt;left&gt;          undo-tree-visualize-switch-branch-left•&lt;mouse-1&gt;       undo-tree-visualizer-mouse-set•&lt;next&gt;          scroll-up•&lt;prior&gt;         scroll-down•&lt;remap&gt;         Prefix Command•&lt;right&gt;         undo-tree-visualize-switch-branch-right•&lt;up&gt;            undo-tree-visualize-undo••&lt;remap&gt; &lt;backward-char&gt;         undo-tree-visualize-switch-branch-left•&lt;remap&gt; &lt;forward-char&gt;          undo-tree-visualize-switch-branch-right•&lt;remap&gt; &lt;next-line&gt;             undo-tree-visualize-redo•&lt;remap&gt; &lt;previous-line&gt;         undo-tree-visualize-undo••",
"unit-at-cursor":"unit-at-cursor is a Lisp function in `xeu_elisp_util.el'.••(unit-at-cursor UNIT)••Return the string and boundary of UNIT under cursor.••Returns a vector [text a b], where text is the string and a and b are its boundary.••UNIT can be:••• 'word — sequence of 0 to 9, A to Z, a to z, and hyphen.••• 'glyphs — sequence of visible glyphs. Useful for file name, URL, …, anything doesn't have white spaces in it.••• 'line — delimited by “⧷n”. (captured text does not include a ending “⧷n”.)••• 'block — delimited by empty lines or beginning/end of buffer. Lines with just spaces or tabs are also considered empty line. (captured text does not include a ending “⧷n”.)••• 'buffer — whole buffer. (respects `narrow-to-region')••• 'filepath — delimited by chars that's USUALLY not part of filepath.••• 'url — delimited by chars that's USUALLY not part of URL.••• a vector [beginRegex endRegex] — The elements are regex strings used to determine the beginning/end of boundary chars. They are passed to `skip-chars-backward' and `skip-chars-forward'. For example, if you want paren as delimiter, use [⧷&quote^(⧷&quote ⧷&quote^)⧷&quote]••Example usage:• (setq bds (unit-at-cursor 'line))• (setq inputstr (elt bds 0) p1 (elt bds 1) p2 (elt bds 2)  )••This function is similar to `thing-at-point' and `bounds-of-thing-at-point'.•The main differences are:••• This function returns the text and the 2 boundaries as a vector in one shot.••• 'line always returns the line without end of line character, avoiding inconsistency when the line is at end of buffer.••• This function's behavior does not depend on syntax table. e.g. for units 「'word」, 「'block」, etc.",
"universal-argument":"universal-argument is an interactive compiled Lisp function in•`simple.el'.••(universal-argument)••Begin a numeric argument for the following command.•Digits or minus sign following C-u make up the numeric argument.•C-u following the digits or minus sign ends the argument.•C-u without digits or minus sign provides 4 as argument.•Repeating C-u without digits or minus sign• multiplies the argument by 4 each time.•For some commands, just C-u by itself serves as a flag•which is different in effect from any particular numeric argument.•These commands include M-SPC and M-x start-kbd-macro.",
"unless":"unless is a Lisp macro in `subr.el'.••(unless COND BODY...)••If COND yields nil, do BODY, else return nil.•When COND yields nil, eval BODY forms sequentially and return•value of last one, or nil if there are none.",
"untabify":"untabify is an interactive autoloaded compiled Lisp function in•`tabify.el'.••(untabify START END)••Convert all tabs in region to multiple spaces, preserving columns.•Called non-interactively, the region is specified by arguments•START and END, rather than by the position of point and mark.•The variable `tab-width' controls the spacing of tab stops.",
"upcase":"upcase is a built-in function in `C source code'.••(upcase OBJ)••Convert argument to upper case and return that.•The argument may be a character or string.  The result has the same type.•The argument object is not altered--the value is a copy.•See also `capitalize', `downcase' and `upcase-initials'.",
"upcase-initials":"upcase-initials is a built-in function in `C source code'.••(upcase-initials OBJ)••Convert the initial of each word in the argument to upper case.•Do not change the other letters of each word.•The argument may be a character or string.  The result has the same type.•The argument object is not altered--the value is a copy.",
"upcase-initials-region":"upcase-initials-region is an interactive built-in function in `C•source code'.••(upcase-initials-region BEG END)••Upcase the initial of each word in the region.•Subsequent letters of each word are not changed.•In programs, give two arguments, the starting and ending•character positions to operate on.",
"upcase-region":"upcase-region is an interactive built-in function in `C source code'.••(upcase-region BEG END)••Convert the region to upper case.  In programs, wants two arguments.•These arguments specify the starting and ending character numbers of•the region to operate on.  When used as a command, the text between•point and the mark is operated on.•See also `capitalize-region'.",
"upcase-word":"upcase-word is an interactive built-in function in `C source code'.••(upcase-word ARG)••Convert following word (or ARG words) to upper case, moving over.•With negative argument, convert previous words but do not move.•See also `capitalize-word'.",
"url-retrieve-synchronously":"url-retrieve-synchronously is an autoloaded Lisp function in `url.el'.••(url-retrieve-synchronously URL)••Retrieve URL synchronously.•Return the buffer containing the data, or nil if there are no data•associated with it (the case for dired, info, or mailto URLs that need•no further processing).  URL is either a string or a parsed URL.",
"url-unhex-string":"url-unhex-string is an autoloaded Lisp function in `url-util.el'.••(url-unhex-string STR &amp;optional ALLOW-NEWLINES)••Remove %XX embedded spaces, etc in a URL.•If optional second argument ALLOW-NEWLINES is non-nil, then allow the•decoding of carriage returns and line feeds in the string, which is normally•forbidden in URL encoding.",
"use-local-map":"use-local-map is a built-in function in `C source code'.••(use-local-map KEYMAP)••Select KEYMAP as the local keymap.•If KEYMAP is nil, that means no local keymap.",
"variable-pitch-mode":"variable-pitch-mode is an interactive autoloaded Lisp function in•`face-remap.el'.••(variable-pitch-mode &amp;optional ARG)••Variable-pitch default-face mode.•An interface to `buffer-face-mode' which uses the `variable-pitch' face.•Besides the choice of face, it is the same as `buffer-face-mode'.",
"vc-annotate":"vc-annotate is an interactive autoloaded Lisp function in•`vc-annotate.el'.••(vc-annotate FILE REV &amp;optional DISPLAY-MODE BUF MOVE-POINT-TO VC-BK)••Display the edit history of the current FILE using colors.••This command creates a buffer that shows, for each line of the current•file, when it was last edited and by whom.  Additionally, colors are•used to show the age of each line--blue means oldest, red means•youngest, and intermediate colors indicate intermediate ages.  By•default, the time scale stretches back one year into the past;•everything that is older than that is shown in blue.••With a prefix argument, this command asks two questions in the•minibuffer.  First, you may enter a revision number REV; then the buffer•displays and annotates that revision instead of the working revision•(type RET in the minibuffer to leave that default unchanged).  Then,•you are prompted for the time span in days which the color range•should cover.  For example, a time span of 20 days means that changes•over the past 20 days are shown in red to blue, according to their•age, and everything that is older than that is shown in blue.••If MOVE-POINT-TO is given, move the point to that line.••If VC-BK is given used that VC backend.••Customization variables:••`vc-annotate-menu-elements' customizes the menu elements of the•mode-specific menu.  `vc-annotate-color-map' and•`vc-annotate-very-old-color' define the mapping of time to colors.•`vc-annotate-background' specifies the background color.",
"vconcat":"vconcat is a built-in function in `C source code'.••(vconcat &amp;rest SEQUENCES)••Concatenate all the arguments and make the result a vector.•The result is a vector whose elements are the elements of all the arguments.•Each argument may be a list, vector or string.",
"vector":"vector is a built-in function in `C source code'.••(vector &amp;rest OBJECTS)••Return a newly created vector with specified arguments as elements.•Any number of arguments, even zero arguments, are allowed.",
"vectorp":"vectorp is a built-in function in `C source code'.••(vectorp OBJECT)••Return t if OBJECT is a vector.",
"video-search-linkify":"video-search-linkify is an interactive compiled Lisp function in•`xah_emacs_linkify.el'.••(video-search-linkify)••Make the current line into a Google video search link.•If there's a text selection, use that.•For example, if the cursor is on the line:••White Rabbit, Jefferson Airplane••Then it'll become••&lt;a class=⧷&quotegvidsr⧷&quote href=⧷&quotehttp://www.google.com/search?tbs=vid%3A1&amp;q=White+Rabbit%2C+Jefferson+Airplane⧷&quote&gt;White Rabbit, Jefferson Airplane&lt;/a&gt;••Warning: the line must end in a line return char else the result is wrong.••This command calls `video-search-string'",
"view-echo-area-messages":"view-echo-area-messages is an interactive compiled Lisp function in•`help.el'.••(view-echo-area-messages)••View the log of recent echo-area messages: the `*Messages*' buffer.•The number of messages retained in that buffer•is specified by the variable `message-log-max'.",
"view-emacs-news":"view-emacs-news is an interactive compiled Lisp function in `help.el'.••(view-emacs-news &amp;optional VERSION)••Display info on recent changes to Emacs.•With argument, display info only for the selected version.",
"view-mode":"view-mode is an interactive autoloaded compiled Lisp function in•`view.el'.••(view-mode &amp;optional ARG)••Toggle View mode, a minor mode for viewing text but not editing it.•With a prefix argument ARG, enable View mode if ARG is positive,•and disable it otherwise.  If called from Lisp, enable View mode•if ARG is omitted or nil.••When View mode is enabled, commands that do not change the buffer•contents are available as usual.  Kill commands insert text in•kill buffers but do not delete.  Most other commands beep and•tell the user that the buffer is read-only.••••The following additional commands are provided.  Most commands•take prefix arguments.  Page commands default to ⧷&quotepage size⧷&quote•lines which is almost a whole window, or number of lines set by•z or w.•Half page commands default to and set ⧷&quotehalf page size⧷&quote lines•which initially is half a window full.  Search commands default•to a repeat count of one.••H, h, ?	 This message.•Digits	provide prefix arguments.•-	negative prefix argument.•&lt;	move to the beginning of buffer.•&gt;	move to the end of buffer.•o	scroll so that buffer end is at last line of window.•SPC	scroll forward ⧷&quotepage size⧷&quote lines.•	  With prefix scroll forward prefix lines.•DEL	scroll backward ⧷&quotepage size⧷&quote lines.•	  With prefix scroll backward prefix lines.•z	like  SPC  but with prefix sets ⧷&quotepage size⧷&quote to prefix.•w	like  DEL  but with prefix sets ⧷&quotepage size⧷&quote to prefix.•d	scroll forward ⧷&quotehalf page size⧷&quote lines.  With prefix, sets•	  ⧷&quotehalf page size⧷&quote to prefix lines and scrolls forward that much.•u	scroll backward ⧷&quotehalf page size⧷&quote lines.  With prefix, sets•	  ⧷&quotehalf page size⧷&quote to prefix lines and scrolls backward that much.•RET, LFD  scroll forward one line.  With prefix scroll forward prefix line(s).•y	scroll backward one line.  With prefix scroll backward prefix line(s).•F	revert-buffer if necessary and scroll forward.•	  Use this to view a changing file.•=	prints the current line number.•%	goes prefix argument (default 100) percent into buffer.•g	goes to line given by prefix argument (default first line).•.	set the mark.•x	exchanges point and mark.•@	return to mark and pops mark ring.•	  Mark ring is pushed at start of every successful search and when•	  jump to line occurs.  The mark is set on jump to buffer start or end.•m	save current position in character register.•'	go to position saved in character register.•s	do forward incremental search.•r	do reverse incremental search.•/	searches forward for regular expression, starting after current page.•	  ! and @ have a special meaning at the beginning of the regexp.•	  ! means search for a line with no match for regexp.  @ means start•	  search at beginning (end for backward search) of buffer.•⧷	searches backward for regular expression, starting before current page.•n	searches forward for last regular expression.•p	searches backward for last regular expression.•q	quit View mode, restoring this window and buffer to previous state.•	  q is the normal way to leave view mode.•e	exit View mode but stay in current buffer.  Use this if you started•	  viewing a buffer (file) and find out you want to edit it.•	  This command restores the previous read-only status of the buffer.•E	exit View mode, and make the current buffer editable•	  even if it was not editable before entry to View mode.•Q	quit View mode, restoring all windows to previous state.•c	quit View mode and maybe switch buffers, but don't kill this buffer.•C	quit View mode, kill current buffer and go back to other buffer.••The effect of c, q and C depends on how view-mode was entered.  If it was•entered by view-file, view-file-other-window, view-file-other-frame, or•M-x dired-view-file (M-x view-file, M-x view-file-other-window,•M-x view-file-other-frame, or the Dired mode v command),•then q will try to kill the current buffer.•If view-mode was entered from another buffer, by M-x view-buffer,•M-x view-buffer-other-window, M-x view-buffer-other frame, M-x view-file,•M-x view-file-other-window, or M-x view-file-other-frame,•then c, q and C will return to that buffer.••Entry to view-mode runs the normal hook `view-mode-hook'.",
"visual-line-mode":"visual-line-mode is an interactive compiled Lisp function in•`simple.el'.••(visual-line-mode &amp;optional ARG)••Toggle visual line based editing (Visual Line mode).•With a prefix argument ARG, enable Visual Line mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••When Visual Line mode is enabled, `word-wrap' is turned on in•this buffer, and simple editing commands are redefined to act on•visual lines, not logical lines.  See Info node `Visual Line•Mode' for details.",
"wdired-abort-changes":"wdired-abort-changes is an interactive compiled Lisp function in•`wdired.el'.••(wdired-abort-changes)••Abort changes and return to dired mode.",
"wdired-change-to-wdired-mode":"wdired-change-to-wdired-mode is an interactive autoloaded compiled•Lisp function in `wdired.el'.••(wdired-change-to-wdired-mode)••Put a Dired buffer in Writable Dired (WDired) mode.••In WDired mode, you can edit the names of the files in the•buffer, the target of the links, and the permission bits of the•files.  After typing C-c C-c, Emacs modifies the files and•directories to reflect your edits.••See `wdired-mode'.",
"wdired-finish-edit":"wdired-finish-edit is an interactive compiled Lisp function in•`wdired.el'.••(wdired-finish-edit)••Actually rename files based on your editing in the Dired buffer.",
"when":"when is a Lisp macro in `subr.el'.••(when COND BODY...)••If COND yields non-nil, do BODY, else return nil.•When COND yields non-nil, eval BODY forms sequentially and return•value of last one, or nil if there are none.",
"while":"while is a special form in `C source code'.••(while TEST BODY...)••If TEST yields non-nil, eval BODY... and repeat.•The order of execution is thus TEST, BODY, TEST, BODY and so on•until TEST returns nil.",
"whitespace-cleanup":"whitespace-cleanup is an interactive autoloaded compiled Lisp function•in `whitespace.el'.••(whitespace-cleanup)••Cleanup some blank problems in all buffer or at region.••It usually applies to the whole buffer, but in transient mark•mode when the mark is active, it applies to the region.  It also•applies to the region when it is not in transient mark mode, the•mark is active and C-u was pressed just before•calling `whitespace-cleanup' interactively.••See also `whitespace-cleanup-region'.••The problems cleaned up are:••1. empty lines at beginning of buffer.•2. empty lines at end of buffer.•   If `whitespace-style' includes the value `empty', remove all•   empty lines at beginning and/or end of buffer.••3. 8 or more SPACEs at beginning of line.•   If `whitespace-style' includes the value `indentation':•   replace 8 or more SPACEs at beginning of line by TABs, if•   `indent-tabs-mode' is non-nil; otherwise, replace TABs by•   SPACEs.•   If `whitespace-style' includes the value `indentation::tab',•   replace 8 or more SPACEs at beginning of line by TABs.•   If `whitespace-style' includes the value `indentation::space',•   replace TABs by SPACEs.••4. SPACEs before TAB.•   If `whitespace-style' includes the value `space-before-tab':•   replace SPACEs by TABs, if `indent-tabs-mode' is non-nil;•   otherwise, replace TABs by SPACEs.•   If `whitespace-style' includes the value•   `space-before-tab::tab', replace SPACEs by TABs.•   If `whitespace-style' includes the value•   `space-before-tab::space', replace TABs by SPACEs.••5. SPACEs or TABs at end of line.•   If `whitespace-style' includes the value `trailing', remove•   all SPACEs or TABs at end of line.••6. 8 or more SPACEs after TAB.•   If `whitespace-style' includes the value `space-after-tab':•   replace SPACEs by TABs, if `indent-tabs-mode' is non-nil;•   otherwise, replace TABs by SPACEs.•   If `whitespace-style' includes the value•   `space-after-tab::tab', replace SPACEs by TABs.•   If `whitespace-style' includes the value•   `space-after-tab::space', replace TABs by SPACEs.••See `whitespace-style', `indent-tabs-mode' and `tab-width' for•documentation.",
"whitespace-mode":"whitespace-mode is an interactive autoloaded compiled Lisp function in•`whitespace.el'.••(whitespace-mode &amp;optional ARG)••Toggle whitespace visualization (Whitespace mode).•With a prefix argument ARG, enable Whitespace mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil.••See also `whitespace-style', `whitespace-newline' and•`whitespace-display-mappings'.",
"whitespace-newline-mode":"whitespace-newline-mode is an interactive autoloaded compiled Lisp•function in `whitespace.el'.••(whitespace-newline-mode &amp;optional ARG)••Toggle newline visualization (Whitespace Newline mode).•With a prefix argument ARG, enable Whitespace Newline mode if ARG•is positive, and disable it otherwise.  If called from Lisp,•enable the mode if ARG is omitted or nil.••Use `whitespace-newline-mode' only for NEWLINE visualization•exclusively.  For other visualizations, including NEWLINE•visualization together with (HARD) SPACEs and/or TABs, please,•use `whitespace-mode'.••See also `whitespace-newline' and `whitespace-display-mappings'.",
"widen":"widen is an interactive built-in function in `C source code'.••(widen)••Remove restrictions (narrowing) from current buffer.•This allows the buffer's full text to be seen and edited.",
"window-configuration-to-register":"window-configuration-to-register is an interactive compiled Lisp•function in `register.el'.••(window-configuration-to-register REGISTER &amp;optional ARG)••Store the window configuration of the selected frame in register REGISTER.•Use C-x r j to restore the configuration.•Argument is a character, naming the register.",
"winner-mode":"winner-mode is an interactive autoloaded compiled Lisp function in•`winner.el'.••(winner-mode &amp;optional ARG)••Toggle Winner mode on or off.•With a prefix argument ARG, enable Winner mode if ARG is•positive, and disable it otherwise.  If called from Lisp, enable•the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.•key             binding•---             -------••C-c             Prefix Command••C-c &lt;left&gt;      winner-undo•C-c &lt;right&gt;     winner-redo••",
"winner-redo":"winner-redo is an interactive compiled Lisp function in `winner.el'.••(winner-redo)••Restore a more recent window configuration saved by Winner mode.",
"winner-undo":"winner-undo is an interactive compiled Lisp function in `winner.el'.••(winner-undo)••Switch back to an earlier window configuration saved by Winner mode.•In other words, ⧷&quoteundo⧷&quote changes in window configuration.",
"with-current-buffer":"with-current-buffer is a Lisp macro in `subr.el'.••(with-current-buffer BUFFER-OR-NAME &amp;rest BODY)••Execute the forms in BODY with BUFFER-OR-NAME temporarily current.•BUFFER-OR-NAME must be a buffer or the name of an existing buffer.•The value returned is the value of the last form in BODY.  See•also `with-temp-buffer'.",
"with-output-to-temp-buffer":"with-output-to-temp-buffer is a Lisp macro in `subr.el'.••(with-output-to-temp-buffer BUFNAME &amp;rest BODY)••Bind `standard-output' to buffer BUFNAME, eval BODY, then show that buffer.••This construct makes buffer BUFNAME empty before running BODY.•It does not make the buffer current for BODY.•Instead it binds `standard-output' to that buffer, so that output•generated with `prin1' and similar functions in BODY goes into•the buffer.••At the end of BODY, this marks buffer BUFNAME unmodified and displays•it in a window, but does not select it.  The normal way to do this is•by calling `display-buffer', then running `temp-buffer-show-hook'.•However, if `temp-buffer-show-function' is non-nil, it calls that•function instead (and does not run `temp-buffer-show-hook').  The•function gets one argument, the buffer to display.••The return value of `with-output-to-temp-buffer' is the value of the•last form in BODY.  If BODY does not finish normally, the buffer•BUFNAME is not displayed.••This runs the hook `temp-buffer-setup-hook' before BODY,•with the buffer BUFNAME temporarily current.  It runs the hook•`temp-buffer-show-hook' after displaying buffer BUFNAME, with that•buffer temporarily current, and the window that was used to display it•temporarily selected.  But it doesn't run `temp-buffer-show-hook'•if it uses `temp-buffer-show-function'.••See the related form `with-temp-buffer-window'.",
"with-temp-buffer":"with-temp-buffer is a Lisp macro in `subr.el'.••(with-temp-buffer &amp;rest BODY)••Create a temporary buffer, and evaluate BODY there like `progn'.•See also `with-temp-file' and `with-output-to-string'.",
"with-temp-file":"with-temp-file is a Lisp macro in `subr.el'.••(with-temp-file FILE &amp;rest BODY)••Create a new buffer, evaluate BODY there, and write the buffer to FILE.•The value returned is the value of the last form in BODY.•See also `with-temp-buffer'.",
"woman":"woman is an interactive autoloaded Lisp function in `woman.el'.••(woman &amp;optional TOPIC RE-CACHE)••Browse UN*X man page for TOPIC (Without using external Man program).•The major browsing mode used is essentially the standard Man mode.•Choose the filename for the man page using completion, based on the•topic selected from the directories specified in `woman-manpath' and•`woman-path'.  The directory expansions and topics are cached for•speed, but a non-nil interactive argument forces the caches to be•updated (e.g. to re-interpret the current directory).••Used non-interactively, arguments are optional: if given then TOPIC•should be a topic string and non-nil RE-CACHE forces re-caching.",
"write-file":"write-file is an interactive compiled Lisp function in `files.el'.••(write-file FILENAME &amp;optional CONFIRM)••Write current buffer into file FILENAME.•This makes the buffer visit that file, and marks it as not modified.••If you specify just a directory name as FILENAME, that means to use•the default file name but in that directory.  You can also yank•the default file name into the minibuffer to edit it, using M-n.••If the buffer is not already visiting a file, the default file name•for the output file is the buffer name.••If optional second arg CONFIRM is non-nil, this function•asks for confirmation before overwriting an existing file.•Interactively, confirmation is required unless you supply a prefix argument.",
"write-region":"write-region is an interactive built-in function in `C source code'.••(write-region START END FILENAME &amp;optional APPEND VISIT LOCKNAME•MUSTBENEW)••Write current region into specified file.•When called from a program, requires three arguments:•START, END and FILENAME.  START and END are normally buffer positions•specifying the part of the buffer to write.•If START is nil, that means to use the entire buffer contents.•If START is a string, then output that string to the file•instead of any buffer contents; END is ignored.••Optional fourth argument APPEND if non-nil means•  append to existing file contents (if any).  If it is an integer,•  seek to that offset in the file before writing.•Optional fifth argument VISIT, if t or a string, means•  set the last-save-file-modtime of buffer to this file's modtime•  and mark buffer not modified.•If VISIT is a string, it is a second file name;•  the output goes to FILENAME, but the buffer is marked as visiting VISIT.•  VISIT is also the file name to lock and unlock for clash detection.•If VISIT is neither t nor nil nor a string,•  that means do not display the ⧷&quoteWrote file⧷&quote message.•The optional sixth arg LOCKNAME, if non-nil, specifies the name to•  use for locking and unlocking, overriding FILENAME and VISIT.•The optional seventh arg MUSTBENEW, if non-nil, insists on a check•  for an existing file with the same name.  If MUSTBENEW is `excl',•  that means to get an error if the file already exists; never overwrite.•  If MUSTBENEW is neither nil nor `excl', that means ask for•  confirmation before overwriting, but do go ahead and overwrite the file•  if the user confirms.••This does code conversion according to the value of•`coding-system-for-write', `buffer-file-coding-system', or•`file-coding-system-alist', and sets the variable•`last-coding-system-used' to the coding system actually used.••This calls `write-region-annotate-functions' at the start, and•`write-region-post-annotation-function' at the end.",
"xahsite-filepath-to-href-value":"xahsite-filepath-to-href-value is a compiled Lisp function in•`xah_emacs_xahsite_path_lisp_util.el'.••(xahsite-filepath-to-href-value LINKFILEPATH CURRENTFILEPATHORDIR)••Return a URL or relative path.•All arguments should all be full paths.•If the two paths are in different domain, then return a URL (string starts with “http://”).•Else, return a relative path.••For reverse, see `xahsite-href-value-to-filepath'.•",
"xesam-search":"xesam-search is an interactive autoloaded Lisp function in `xesam.el'.••(xesam-search ENGINE QUERY)••Perform an interactive search.•ENGINE is the Xesam search engine to be applied, it must be one of the•entries of `xesam-search-engines'.  QUERY is the search string in the•Xesam user query language.  If the search engine does not support•the Xesam user query language, a Xesam fulltext search is applied.••The default search engine is the first entry in `xesam-search-engines'.•Example:••  (xesam-search (car (xesam-search-engines)) ⧷&quoteemacs⧷&quote)",
"xml-mode":"xml-mode is an alias for `nxml-mode' in `nxml-mode.el'.••(xml-mode)••Major mode for editing XML.••M-x nxml-finish-element finishes the current element by inserting an end-tag.•C-c C-i closes a start-tag with `&gt;' and then inserts a balancing end-tag•leaving point between the start-tag and end-tag.•M-x nxml-balanced-close-start-tag-block is similar but for block rather than inline elements:•the start-tag, point, and end-tag are all left on separate lines.•If `nxml-slash-auto-complete-flag' is non-nil, then inserting a `&lt;/'•automatically inserts the rest of the end-tag.••M-x completion-at-point performs completion on the symbol preceding point.••M-x nxml-dynamic-markup-word uses the contents of the current buffer•to choose a tag to put around the word preceding point.••Sections of the document can be displayed in outline form.  The•variable `nxml-section-element-name-regexp' controls when an element•is recognized as a section.  The same key sequences that change•visibility in outline mode are used except that they start with C-c C-o•instead of C-c.••Validation is provided by the related minor-mode `rng-validate-mode'.•This also makes completion schema- and context- sensitive.  Element•names, attribute names, attribute values and namespace URIs can all be•completed. By default, `rng-validate-mode' is automatically enabled.•You can toggle it using M-x rng-validate-mode or change the default by•customizing `rng-nxml-auto-validate-flag'.••TAB indents the current line appropriately.•This can be customized using the variable `nxml-child-indent'•and the variable `nxml-attribute-indent'.••M-x nxml-insert-named-char inserts a character reference using•the character's name (by default, the Unicode name).•C-u M-x nxml-insert-named-char inserts the character directly.••The Emacs commands that normally operate on balanced expressions will•operate on XML markup items.  Thus C-M-f will move forward•across one markup item; C-M-b will move backward across•one markup item; C-M-k will kill the following markup item;•C-M-@ will mark the following markup item.  By default, each•tag each treated as a single markup item; to make the complete element•be treated as a single markup item, set the variable•`nxml-sexp-element-flag' to t.  For more details, see the function•`nxml-forward-balanced-item'.••M-x nxml-backward-up-element and M-x nxml-down-element move up and down the element structure.••Many aspects this mode can be customized using•M-x customize-group nxml RET.••In addition to any hooks its parent mode `text-mode' might have run,•this mode runs the hook `nxml-mode-hook', as the final step•during initialization.",
"xmsi-list-math-symbols":"xmsi-list-math-symbols is an interactive Lisp function in•`xmsi-math-symbols-input.el'.••(xmsi-list-math-symbols)••Print a list of math symbols and their input abbreviations.•See `xmsi-mode'.",
"xmsi-mode":"xmsi-mode is an interactive autoloaded Lisp function in•`xmsi-math-symbols-input.el'.••(xmsi-mode &amp;optional ARG)••Toggle math symbol input (minor) mode.••A mode for inputting a few math and other Unicode symbols.••Type “inf”, then press 【Shift+Space】, then it becomes “∞”.•Other examples:• a ⇒ α• p ⇒ π• != ⇒ ≠• &gt;= ⇒ ≥• =&gt; ⇒ ⇒• -&gt; ⇒ →• and ⇒ ∧•etc.••If you have a text selection, then selected word will be taken as•input. For example, type 「sin(a)」, select the “a”, then press• 【Shift+Space】, then it becomse 「sin(α)」.••For the complete list of abbrevs, call `xmsi-list-math-symbols'.•All XML char entity abbrevs are supported. For example, 「copy」 ⇒ 「©」.••Decimal and hexadecimal can also be used. Example:•• 945     ← decimal• #945    ← decimal with prefix #• &amp;#945;  ← XML entity syntax•• x3b1    ← hexadimal with prefix x• #x3b1   ← hexadimal with prefix #x• &amp;#x3b1; ← XML entity syntax••Full Unicode name can also be used, e.g. 「greek small letter alpha」.••If you wish to enter a symbor by full unicode name but do not•know the full name, call `ucs-insert'. Asterisk “*” can be used•as a wildcard to find the char. For example, call•“ucs-insert”, then type 「*arrow」 then Tab, then emacs will list•all unicode char names that has “arrow” in it. (this feature is•part of Emacs 23)••Without argument, toggles the minor mode.•If optional argument is 1, turn it on.•If optional argument is 0, turn it off.••Home page at: URL `http://ergoemacs.org/emacs/xmsi-math-symbols-input.html'",
"yank":"yank is an interactive compiled Lisp function in `simple.el'.••(yank &amp;optional ARG)••Reinsert (⧷&quotepaste⧷&quote) the last stretch of killed text.•More precisely, reinsert the most recent kill, which is the•stretch of killed text most recently killed OR yanked.  Put point•at the end, and set mark at the beginning without activating it.•With just C-u as argument, put point at beginning, and mark at end.•With argument N, reinsert the Nth most recent kill.••When this command inserts text into the buffer, it honors the•`yank-handled-properties' and `yank-excluded-properties'•variables, and the `yank-handler' text property.  See•`insert-for-yank-1' for details.••See also the command `yank-pop' (M-K).",
"yank-pop":"yank-pop is an interactive compiled Lisp function in `simple.el'.••(yank-pop &amp;optional ARG)••Replace just-yanked stretch of killed text with a different stretch.•This command is allowed only immediately after a `yank' or a `yank-pop'.•At such a time, the region contains a stretch of reinserted•previously-killed text.  `yank-pop' deletes that text and inserts in its•place a different stretch of killed text.••With no argument, the previous kill is inserted.•With argument N, insert the Nth previous kill.•If N is negative, this is a more recent kill.••The sequence of kills wraps around, so that after the oldest one•comes the newest one.••When this command inserts killed text into the buffer, it honors•`yank-excluded-properties' and `yank-handler' as described in the•doc string for `insert-for-yank-1', which see.",
"yank-rectangle":"yank-rectangle is an interactive autoloaded compiled Lisp function in•`rect.el'.••(yank-rectangle)••Yank the last killed rectangle with upper left corner at point.",
"yas/reload-all":"yas/reload-all is an interactive Lisp function in `yasnippet.el'.••(yas/reload-all &amp;optional RESET-ROOT-DIRECTORY)••Reload all snippets and rebuild the YASnippet menu. ",
"yes-or-no-p":"yes-or-no-p is an alias for `y-or-n-p' in `init_aliases.el'.••(yes-or-no-p PROMPT)••Ask user a ⧷&quotey or n⧷&quote question.  Return t if answer is ⧷&quotey⧷&quote.•PROMPT is the string to display to ask the question.  It should•end in a space; `y-or-n-p' adds ⧷&quote(y or n) ⧷&quote to it.••No confirmation of the answer is requested; a single character is•enough.  SPC also means yes, and DEL means no.••To be precise, this function translates user input into responses•by consulting the bindings in `query-replace-map'; see the•documentation of that variable for more information.  In this•case, the useful bindings are `act', `skip', `recenter',•`scroll-up', `scroll-down', and `quit'.•An `act' response means yes, and a `skip' response means no.•A `quit' response means to invoke `keyboard-quit'.•If the user enters `recenter', `scroll-up', or `scroll-down'•responses, perform the requested window recentering or scrolling•and ask again.••Under a windowing system a dialog box will be used if `last-nonmenu-event'•is nil and `use-dialog-box' is non-nil.",
"y-or-n-p":"y-or-n-p is a compiled Lisp function in `subr.el'.••(y-or-n-p PROMPT)••Ask user a ⧷&quotey or n⧷&quote question.  Return t if answer is ⧷&quotey⧷&quote.•PROMPT is the string to display to ask the question.  It should•end in a space; `y-or-n-p' adds ⧷&quote(y or n) ⧷&quote to it.••No confirmation of the answer is requested; a single character is•enough.  SPC also means yes, and DEL means no.••To be precise, this function translates user input into responses•by consulting the bindings in `query-replace-map'; see the•documentation of that variable for more information.  In this•case, the useful bindings are `act', `skip', `recenter',•`scroll-up', `scroll-down', and `quit'.•An `act' response means yes, and a `skip' response means no.•A `quit' response means to invoke `keyboard-quit'.•If the user enters `recenter', `scroll-up', or `scroll-down'•responses, perform the requested window recentering or scrolling•and ask again.••Under a windowing system a dialog box will be used if `last-nonmenu-event'•is nil and `use-dialog-box' is non-nil.",
"youtube-linkify":"youtube-linkify is an interactive compiled Lisp function in•`xah_emacs_vid_linkify.el'.••(youtube-linkify)••Make the current line into a embeded HTML video object.•The line can be a youtube ID or full URL.•Examples of lines:••bFSS826ETlk•http://www.youtube.com/watch?v=bFSS826ETlk••url with more parameters usually will work too.••The current line is the line the cursor is on, that is enclosed by “•”.••Here's a example result:••&lt;iframe title=⧷&quoteYouTube video player⧷&quote class=⧷&quoteyoutube-player⧷&quote width=⧷&quote480⧷&quote height=⧷&quote390⧷&quote src=⧷&quotehttp://www.youtube.com/embed/Skan0yO-qU8?rel=0⧷&quote&gt;&lt;/iframe&gt;••here's old version output•&lt;object type=⧷&quoteapplication/x-shockwave-flash⧷&quote data=⧷&quotehttp://www.youtube.com/v/bFSS826ETlk⧷&quote width=⧷&quote480⧷&quote height=⧷&quote385⧷&quote&gt;&lt;param name=⧷&quotemovie⧷&quote value=⧷&quotehttp://www.youtube.com/v/bFSS826ETlk⧷&quote&gt;&lt;/object&gt;•",
"yow":"yow is an interactive autoloaded Lisp function in `yow.el'.••(yow &amp;optional INSERT DISPLAY)••Return or display a random Zippy quotation.  With prefix arg, insert it.",
"zap-to-char":"zap-to-char is an interactive compiled Lisp function in `simple.el'.••(zap-to-char ARG CHAR)••Kill up to and including ARGth occurrence of CHAR.•Case is ignored if `case-fold-search' is non-nil in the current buffer.•Goes backward if ARG is negative; error if CHAR not found."
};

function trim(str){
  return str.replace(/(^\s*)|(\s*$)/g, "");
}
// activate tooltip
function popupActivate (evt) {

    var boundBox = evt.target.getBoundingClientRect();
    var coordX = boundBox.left;
    var coordY = boundBox.top;
    balloon.style.position="fixed";
    balloon.style.left= (coordX + 40).toString() + "px";
    balloon.style.top= (coordY + 40).toString() + "px";

    var langWord = evt.target.firstChild.nodeValue;
    langWord = trim(langWord);  //trim whitespace
    var docStr = unicodedata[langWord];
    if (! !!docStr) {
    	console.log(langWord);
    	return;
    }
    docStr = docStr.replace(/••/g, "<br /><br />");
    docStr = docStr.replace(/•/g, " ");

    balloon.innerHTML = docStr;
    balloon.style.visibility="visible";

}

function popupOff(evt) {
    balloon.style.visibility="hidden";
}

function init () {

    // create balloon element, insert as first child of refNode
    function createBalloon (refNode) {
        // create balloon element to display info
        balloon = document.createElement("div");
        balloon.style.visibility="hidden";
        balloon.style.position="fixed";
        balloon.style.top=".5ex";
        balloon.style.left=".5ex";
        balloon.style.padding=".5ex";
        balloon.style.textAlign="left";
        balloon.style.border="solid thin red";
        balloon.style.borderRadius="1ex";
        balloon.style.backgroundColor="hsl(0,0%,70%)";
        balloon.style.boxShadow="3px 3px 8px black";
        balloon.style.zIndex="341";
        balloon.appendChild(document.createTextNode("nothing"));
        // insert into DOM
        refNode.insertBefore(balloon, refNode.firstChild);
    }

    // var myList = document.getElementsByClassName("unicode");

var myList = document.querySelectorAll("code,code.elisp-f,span.keyword,span.function-name");

    // assign handler to hot hoover elements
    if ( myList.length > 0 ) {
        for (var ii = 0; ii < myList.length; ii++) {
            var myNode = myList[ii];
            myNode.addEventListener("mouseover", popupActivate , false);
            myNode.addEventListener("mouseout", popupOff , false);
        }
    }

    createBalloon(document.body);
}

var balloon;

init();
