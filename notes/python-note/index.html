

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu Yang">
  <meta name="keywords" content="">
  
    <meta name="description" content="python的编码规范 用4个空格缩进 每一行不超过80个字符,当一行超过80个字符时,可以用,当对一个二元操作符断行时,应该将操作符留在 上一行,对于函数定义以及调用,那么根据括号来对齐. 模块内容的顺序： 模块说明和docstring import __all_(optional) globals and constants 其他定义   一行只导入一个模块(不推荐 import sys, o">
<meta property="og:type" content="article">
<meta property="og:title" content="python笔记">
<meta property="og:url" content="https://yuyang0.github.io/notes/python-note/index.html">
<meta property="og:site_name" content="yuyang&#39;s blog">
<meta property="og:description" content="python的编码规范 用4个空格缩进 每一行不超过80个字符,当一行超过80个字符时,可以用,当对一个二元操作符断行时,应该将操作符留在 上一行,对于函数定义以及调用,那么根据括号来对齐. 模块内容的顺序： 模块说明和docstring import __all_(optional) globals and constants 其他定义   一行只导入一个模块(不推荐 import sys, o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuyang0.github.io/static/img/attribute-search-tree.png">
<meta property="og:image" content="https://yuyang0.github.io/static/img/diamond-pattern.png">
<meta property="article:published_time" content="2014-02-12T03:54:17.000Z">
<meta property="article:modified_time" content="2022-05-08T15:40:30.006Z">
<meta property="article:author" content="Yu Yang">
<meta property="article:tag" content="python">
<meta property="article:tag" content="lang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://yuyang0.github.io/static/img/attribute-search-tree.png">
  
  
  <title>python笔记 - yuyang&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yuyang0.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0,"placement":"right"},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"LyT8mpSI2Jq9CRhOtNOgBXkE-9Nh9j0Va","app_key":"fUOlkXhD9wcmxOTed9NdlqPH","server_url":"https://lyt8mpsi.lc-cn-e1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>yuyang&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://rmt.dogedoge.com/fetch/fluid/storage/bg/dojm2h.png?w=1920&q=100&fmt=webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="python笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2014-02-12 11:54" pubdate>
        2014年2月12日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      24k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      204 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">python笔记</h1>
            
            <div class="markdown-body">
              <h1 id="python的编码规范"><a href="#python的编码规范" class="headerlink" title="python的编码规范"></a>python的编码规范</h1><ol>
<li>用4个空格缩进</li>
<li>每一行不超过80个字符,当一行超过80个字符时,可以用,当对一个二元操作符断行时,应该将操作符留在 上一行,<br>对于函数定义以及调用,那么根据括号来对齐.</li>
<li>模块内容的顺序：<ul>
<li>模块说明和docstring</li>
<li>import</li>
<li>__all_<sub>(optional)</sub></li>
<li>globals and constants</li>
<li>其他定义</li>
</ul>
</li>
<li>一行只导入一个模块(不推荐 import sys, os)</li>
<li>模块导入顺序: 标准库, 第三方库, 自己编写的库. 三者之间用空行分割, 而且三者应该紧挨着模块字符串的后面</li>
<li>模块级别的函数定义, 类定义用2个空行分割, 类方法用一个空行分割</li>
<li>空格的添加:<ul>
<li><p>二元操作的两边各放一个空格, 但是对于有多个操作符的情况,可以只在低优先级 的操作符两边放空格</p>
<figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs python">i = i + <span class="hljs-number">1</span><br>submitted += <span class="hljs-number">1</span><br>x = x*<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>hypot2 = x*x + y*y<br>c = (a+b) * (a-b)<br></code></pre></td></tr></table></figure>
</li>
<li><p>标点符号的后面放空格,前面不要放空格,在(, {, [之后以及), }, ]之前不要放空格,函数调用时函数名与左括号之间<br>不要放空格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs example">Yes: spam(ham[1], &#123;eggs: 2&#125;)<br>No:  spam( ham[ 1 ], &#123; eggs: 2 &#125; )<br>No:  spam (ham[1], &#123;eggs:2&#125;)<br><br>Yes: if x == 4: print x, y; x, y = y, x<br>No:  if x == 4 : print x , y ; x , y = y , x<br><br>Yes: spam(1)<br>No:  spam (1)<br><br>Yes: dict[&#x27;key&#x27;] = list[index]<br>No:  dict [&#x27;key&#x27;] = list [index]<br></code></pre></td></tr></table></figure>
</li>
<li><p>不要在用于指定关键字参数 (keyword argument) 或默认参数值的 ‘&#x3D;’ 号周围使用空格。</p>
</li>
</ul>
</li>
<li>命名<ul>
<li>模块名与包名: 全部用小写字母, 模块名可以添加下划线来增加可读性, 包名不建议添加下划线,名字尽量短一点,因<br>为有些文件系统对文件长度有要求</li>
<li>类名: 使用驼峰命名法,如果是内部类,则在前面加一个下划线</li>
<li>异常名: 异常是类, 所以使用驼峰命名法,但是必须有Error后缀</li>
<li>函数名: 必须是小写字母, 用下划线去增加可读性</li>
<li>类方法: 和函数名相同, 对于non-public函数, 可以在前面加一个下划线, 前面加两个下划线主要是避免与子类命名<br>冲突(一般用户命名变量不推荐使用)</li>
<li>常量名: 全部大写, 用下划线分割增加可读性</li>
</ul>
</li>
</ol>
<h1 id="python-文件处理"><a href="#python-文件处理" class="headerlink" title="python 文件处理"></a>python 文件处理</h1><p>open打开文件时的选项：</p>
<ul>
<li><p>w, w+: 如果文件已存在，那么二者都会将文件内容清除</p>
</li>
<li><p>r+: 如果写文件，那么会从当前位置覆盖写，而不是插入，当用该模式打开文件，读 入文件内容，然后用覆盖该文件时应使用如下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;r+&#x27;</span>) <span class="hljs-keyword">as</span>  f:<br>    content = f.read()<br>    new_content = do_something()<br>    f.seek(<span class="hljs-number">0</span>)<br>    f.write(new_content)<br>    f.truncate()                <span class="hljs-comment"># 删除当前读写位置到文件末尾的内容</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>b: 在python2中，linux指定与不指定问题不大，但是建议对于二进制文件比如图片还<br>是指定该选项比较好，避免移植到windows出现问题，在python3中，对于文本文件，<br>如果不指定该选项，那么会返回unicode string， 而如果指定该选项则返回byte string,<br>所以对于二进制文件,你必须指定b</p>
</li>
</ul>
<p>遍历一个文件夹的所有文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path<br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> os.path <span class="hljs-keyword">import</span> join, getsize<br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(<span class="hljs-string">&#x27;python/Lib/email&#x27;</span>):<br>    <span class="hljs-keyword">for</span> afile <span class="hljs-keyword">in</span> files:<br>        full_name = os.path.join(root, afile)<br>        do_something(full_name)<br></code></pre></td></tr></table></figure>

<h1 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h1><ol>
<li>if, for, while等不会创建新的作用域, 也就是说它们不同于c中block structure.</li>
<li>每一个模块会创建一个模块作用域</li>
<li>每一个函数(包括嵌套定义的函数) 都创建一个函数作用域</li>
<li>在一个作用域内第一次赋值会创建一个新的 <strong>绑定</strong>, 以后对该变量的赋值都是对该 绑定的 <strong>修改</strong>.</li>
<li>在内层作用域可以引用外层作用域的变量, 但是你不能修改外层作用域的变量, 因为<br>你在在内层作用域一旦对该变量使用赋值,那么就是创建一个新的绑定,<br>所以为了改 变模块作用域中的变量你必须使用global来申明, 但是你永远也不能在内层函数中改<br>变外层函数的变量(当然你可以通过subscript或者attribute來修改可变对象的值,<br>只是这是引用的关系, 和作用域关系不大),这是python设计的不够好的地方.</li>
</ol>
<h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><ul>
<li>X&#x2F;Y: python2中的行为和C语言类似，3&#x2F;2&#x3D;1, 3&#x2F;2.0&#x3D;1.5;<br>在python3中，这是真除法，也就是会一直保留小数位,3&#x2F;2<br>&#x3D; 1.5</li>
<li>X&#x2F;<em>Y: 在python2以及3中都是floor除法，也就是取整数区间的左边边界，5&#x2F;&#x2F;2 &#x3D; 2, 5&#x2F;</em>-2 &#x3D; -3</li>
</ul>
<h2 id="一些内置函数的解释"><a href="#一些内置函数的解释" class="headerlink" title="一些内置函数的解释"></a>一些内置函数的解释</h2><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>获得对象的所有属性,也就是顶层的那些names</p>
<h2 id="globals-And-lolcals"><a href="#globals-And-lolcals" class="headerlink" title="globals And lolcals"></a>globals And lolcals</h2><ol>
<li><code>globals()</code>: 返回一个字典,字典包括当前模块(也就是调用 <code>globals()</code> 的模块) 的所有模块级属性, 同时还包括<br><code>__builtins__</code> 属性, 还包括几个特殊变量 <code>__file__, __package__, __doc__</code>.</li>
<li>locals(): 这个只返回局部空间(比如函数的局部变量)的变量与值的字典,注意这个字典不能修改,如果强行修改会引发<br>严重后果,比如解释器崩溃</li>
</ol>
<h2 id="getattr-getattr-getattribute"><a href="#getattr-getattr-getattribute" class="headerlink" title="getattr,__getattr__,__getattribute__"></a>getattr,__getattr__,__getattribute__</h2><ol>
<li><p><code>__getattr__</code> 只有在属性不存在时才调用,该方法用的多</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, obj</span>):<br>        self.obj = obj<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-keyword">if</span> name.startswith(<span class="hljs-string">&quot;__&quot;</span>) <span class="hljs-keyword">and</span> name.endswith(<span class="hljs-string">&quot;__&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(ClassName, self).__getattr__(name)<br>        dosomething()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(ClassName, self).__getattr__(name)<br></code></pre></td></tr></table></figure>

<p><strong>在该函数中不要使用不存在的属性，因为这会导致循环递归</strong>, 该函数实现不正确很<br>容易导致copy，pickle之类的模块出现循环递归。因为copy，pickle之类的模块在创<br>建新对象的过程大体时这样的：</p>
<ol>
<li>调用 <code>__new__</code> 创建一个新对象</li>
<li>调用 <code>__setstate_</code> 来设置对象状态</li>
</ol>
<p>第一步并没有调用 <code>__init__</code>, 所以很多属性(比如obj)是不存在的，一旦你在 <code>__getattr__</code> 使用了<br><code>__init__</code> 中创建的属性，并且你又没有定义 <code>__setstate__</code> 的话，那么第二步就会导致循环递归。 避免循环递归的<br>方式有以下几种：</p>
<ol>
<li><p>是过滤掉 <code>__xxx__</code> 这样的属性,就像示例中那样。这样 <code>__setstate__</code> 之类的属性就被过滤掉了</p>
</li>
<li><p>定义 <code>__setstate__</code>, 这样第二步就不会进去 <code>__getattr__</code></p>
</li>
<li><p>在 <code>__getattr__</code> 的开头过滤掉你所使用的属性。 比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):<br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;obj&quot;</span>:<br>        <span class="hljs-keyword">raise</span> AttributeError()<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>__getattribute__是每一次obj.attr时都会调用,所以它可以拦截所有的属性查询, 用的很少</p>
</li>
<li><p>getattr: 原型getattr(object, name[, default]), getattr(x,<br>‘foobar’)等价于x.foobar优势就在于getattr可以<br>使用字符串,注意如果是获得类实例的方法,那么self参数就可以忽略了,只需要传入除self之外的其它参数就好</p>
</li>
</ol>
<h2 id="import-接字符串而不是name"><a href="#import-接字符串而不是name" class="headerlink" title="__import_(接字符串而不是name)"></a>__import_<sub>(接字符串而不是name)</sub></h2><p>原型： __import_<sub>(name[, globals[, locals[, fromlist[,<br>level]]]])</sub></p>
<ul>
<li>fromlist： 指定需要从name中导入的属性名，一般而言也就是from module1 import attr1,<br>attr2…中的 attr1,attr2… <strong>这个参数一般需要指定</strong></li>
<li>level: 指定使用绝对导入还是相对导入，-1是默认会同时尝试二者，0是绝对导入，正数是相当于加几个. ,比如如果<br>为1,那就是加一个.也就是当前目录，如果是2,那就是加两个点，在当前模块的父目录中导入，和import中的相<br>对导入语法类似</li>
</ul>
<!-- end list -->

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># snippet 1</span><br><span class="hljs-keyword">from</span> spam.ham <span class="hljs-keyword">import</span> eggs, sausage <span class="hljs-keyword">as</span> saus<br><br><span class="hljs-comment"># snippet 2</span><br>_temp = <span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;spam.ham&#x27;</span>, <span class="hljs-built_in">globals</span>(), <span class="hljs-built_in">locals</span>(), [<span class="hljs-string">&#x27;eggs&#x27;</span>, <span class="hljs-string">&#x27;sausage&#x27;</span>], -<span class="hljs-number">1</span>)<br>eggs = _temp.eggs<br>saus = _temp.sausage<br></code></pre></td></tr></table></figure>

<p>两段代码等价, __import__接的是字符串</p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器的基本形式"><a href="#装饰器的基本形式" class="headerlink" title="装饰器的基本形式"></a>装饰器的基本形式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_deco</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> _deco<br><br><span class="hljs-meta">@deco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>上面的@deco 等价于 myfunc &#x3D; deco(myfunc), 这就是装饰器的本质所在,<br>注意_deco必须与myfunc有相同的参数,因为 装饰后调用myfunc实际是调用_deco,<br>当然_deco可以使用*args, **kargs这样的可变参数</p>
<h2 id="使用类作为装饰器-推荐的做法"><a href="#使用类作为装饰器-推荐的做法" class="headerlink" title="使用类作为装饰器(推荐的做法)"></a>使用类作为装饰器(推荐的做法)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">deco</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br><br><span class="hljs-meta">@deco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>myfunc &#x3D; deco(myfunc) 所以myfunc就是一个deco类的实例，然后myfunc(*args,<br>**kwargs),实际就是调用类实例 的__call__方法</p>
<h2 id="使用类作为装饰器装饰类方法"><a href="#使用类作为装饰器装饰类方法" class="headerlink" title="使用类作为装饰器装饰类方法"></a>使用类作为装饰器装饰类方法</h2><p>下面的代码也可以装饰非类方法,也就是装饰普通函数,也就意味着下面的代码可以替代2,因为如果装饰的是普通函数,<br>那么会直接调用该函数,所以不会触发descriptor的__get__方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">deco</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>        self.func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, obj, objtype</span>):<br>        <span class="hljs-keyword">import</span> functools<br>        <span class="hljs-keyword">return</span> functools.partial(self.__call__, obj)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">    @deco</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<p>这与2最大的区别就是使用了descriptor，也就是__get__, 之所以这么写是因为，如果像2一样，那么就没有给myfunc<br>传递self参数，所以python会报缺少参数的错误，下面解释一下代码运行的流程，deco装饰后，myfunc变成一个deco的<br>类实例，注意deco定义了__get__,<br>所以myfunc就变成了一个descriptor对象，当你使用test_obj.myfunc(*args,<br>**kwargs)调用的时候，也就触发了test_obj.myfunc的属性搜索，那么根据descriptor的规则，就变成了<br>myfunc.__get_<sub>(test_obj)</sub>,该函数返回已将test_obj绑定到myfunc.<span class="underline"><span class="underline">call</span>_的第一个参数的partial<br>函数，接着这个 函数在接受*args,<br>**kwargs参数，总之就是通过descriptor将test_obj传递给了__call_</span>,从而消除了缺少self的问题</p>
<h2 id="给装饰器添加参数"><a href="#给装饰器添加参数" class="headerlink" title="给装饰器添加参数"></a>给装饰器添加参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">arg</span>):<br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">_deco</span>(<span class="hljs-params">func</span>):<br>         <span class="hljs-keyword">def</span> <span class="hljs-title function_">__deco</span>():<br>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before %s called [%s].&quot;</span> % (func.__name__, arg))<br>             func()<br>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after %s called [%s].&quot;</span> % (func.__name__, arg))<br>         <span class="hljs-keyword">return</span> __deco<br>     <span class="hljs-keyword">return</span> _deco<br><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-string">&quot;mymodule&quot;</span></span>)</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-string">&quot;module2&quot;</span></span>)</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc2</span>():<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc2() called.&quot;</span>)<br>myfunc()<br> myfunc2()<br></code></pre></td></tr></table></figure>

<p>需要给装饰器加参数.那么就给多添加一个嵌套函数, 这个参数可以是类以及其它对象</p>
<h2 id="functools模块"><a href="#functools模块" class="headerlink" title="functools模块"></a>functools模块</h2><ul>
<li><p>wraps: 这个装饰器可以确保函数在装饰后属性的一致,比如上面的例子 myfunc&#x3D;deco(myfunc), 那么此时<br>myfunc的__name__,<br>__doc__等属性都不在是原myfunc的值了,而是_deco的值,每一次装饰之后这些函数对象的元信<br>息都丢失的话,那么这显然是一个大问题,而wraps可以用来应付这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">     @functools.wraps(<span class="hljs-params">func</span>)</span><br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">_deco</span>():<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before myfunc() called.&quot;</span>)<br>         func()<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  after myfunc() called.&quot;</span>)<br>    <span class="hljs-keyword">return</span> _deco<br><span class="hljs-meta">@deco</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; myfunc() called.&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>@functools.wraps(func)这行代码可以保证,通过装饰器调用后,函数__name__,<br>__doc__仍然和原来的函数一致</p>
</li>
<li><p>partial: 有时候你知道一个函数的一部分参数,这个时候你可以先绑定这些参数,绑<br>定这些参数之后会返回一个partial对象,你可以当这个对象就是一个以绑定了一些参<br>数的函数,就是函数式语言中的curry,partial大体上等于以下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">func, *args, **keywords</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">newfunc</span>(<span class="hljs-params">*fargs, **fkeywords</span>):<br>        newkeywords = keywords.copy()<br>        newkeywords.update(fkeywords)<br>        <span class="hljs-keyword">return</span> func(*(args + fargs), **newkeywords)<br>    newfunc.func = func<br>    newfunc.args = args<br>    newfunc.keywords = keywords<br>    <span class="hljs-keyword">return</span> newfunc<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="迭代器的基本知识"><a href="#迭代器的基本知识" class="headerlink" title="迭代器的基本知识"></a>迭代器的基本知识</h2><p>迭代器对象是序列对象的一般化,每一个迭代器对象都有一个next方法,该方法每调用一次都会返回下一个元素,当没有元素<br>可返回时要触发StopIteration异常,这就是迭代对象的实质了</p>
<h2 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h2><p>从大多数方面看生成器函数和普通函数一致,它们二者最大的不同时,普通函数是直接通过return返回一个值,而生成器函<br>数是通过yield返回一个迭代器对象,所以每一个生成器函数调用后都是返回一个迭代器对象,这是本质的区别</p>
<h2 id="for循环的迭代过程"><a href="#for循环的迭代过程" class="headerlink" title="for循环的迭代过程"></a>for循环的迭代过程</h2><p>for item in obj语句的执行过程其实是这样</p>
<ol>
<li>先运行iter(obj) 获得迭代器对象 iter_obj</li>
<li>重复的调用iter_obj.next() 直到出现StopIteration异常</li>
<li>如果上述两步已成功,那么for循环就结束了,如果上述两步没成功,这意味着obj不支持迭代协议,那么for就会尝试使用<br>下标来遍历那么会使用下标来遍历,也就是从0开始每一轮循环都对下标加一,而且每一轮循环都使用obj[i]<br>来访问元 素,直到触发异常</li>
</ol>
<h1 id="with"><a href="#with" class="headerlink" title="with"></a>with</h1><p>基本模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">with exp as name:<br>    body<br></code></pre></td></tr></table></figure>

<p>先对exp求值得到val，然后调用val的__enter__ 方法，最后将val绑定到name，接着运<br>行body，在要退出body时运行val的__exit__方法。File对象已经自带了这两个特殊方法，<br>所以打开文件时，with用的很多。</p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>模块的_X与__all__: 当调用from XX import * 时, 如果指定了__all__, 那么就只导<br>入__all__中的名字,如果没指定__all__,那么导入所有除了以下划线开头的全部模块级 名字, 也就是说不会导入<br>_X 这样的名字</p>
<h2 id="absolute-import"><a href="#absolute-import" class="headerlink" title="absolute import"></a>absolute import</h2><p>只导入 <code>sys.path</code> 指定的路径下的模块，一般来说sys.path的第一项就是 <strong>作为入口 被执行的脚本的所在的目录</strong>,<br>比如你在命令行执行 <code>python aa.py</code> 那么第一项就是 <code>aa.py</code> 所在的目录. 绝对导入的语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> foo<br><span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">import</span> aaa <span class="hljs-comment"># xxx 不能以 . 开头</span><br></code></pre></td></tr></table></figure>

<p>上面的这种语法在Py2,py3中是不同的：</p>
<ul>
<li>py3： 是绝对导入，也就是说只搜索sys.path</li>
<li>py2: 行为比较混淆，它会同时搜索当前文件(包含import语句的文件，不是入口执行<br>文件)所在目录的模块，同时也会搜索sys.path,这很容易造成包内部的模块覆盖掉<br>sys.path的模块</li>
</ul>
<p><strong>为了兼容性，建议使用 from<br><span class="underline"><span class="underline">future</span></span><br>import absolute_import</strong> 来统一该语法的 行为。</p>
<h2 id="relative-import"><a href="#relative-import" class="headerlink" title="relative import"></a>relative import</h2><p>相对导入必须使用from xxx import yyy 的形式, 而且xxx必须以点号开头, import xxx 的形式都是绝对导入,<br>相对导入需要以下的语法:对于如下的一个目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs example">package/<br> __init__.py<br> subpackage1/<br>     __init__.py<br>     moduleX.py<br>     moduleY.py<br> subpackage2/<br>     __init__.py<br>     moduleZ.py<br> moduleA.py<br><br></code></pre></td></tr></table></figure>

<p>假设在moduleX.py or subpackage1&#x2F;__init__.py中，那么下列的相对导入是合法的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .moduleY <span class="hljs-keyword">import</span> spam<br><span class="hljs-keyword">from</span> .moduleY <span class="hljs-keyword">import</span> spam <span class="hljs-keyword">as</span> ham<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> moduleY<br><span class="hljs-keyword">from</span> ..subpackage1 <span class="hljs-keyword">import</span> moduleY<br><span class="hljs-keyword">from</span> ..subpackage2.moduleZ <span class="hljs-keyword">import</span> eggs<br><span class="hljs-keyword">from</span> ..moduleA <span class="hljs-keyword">import</span> foo<br><span class="hljs-keyword">from</span> ...package <span class="hljs-keyword">import</span> bar<br><span class="hljs-keyword">from</span> ...sys <span class="hljs-keyword">import</span> path<br></code></pre></td></tr></table></figure>

<p>一个点代表当前文件所在的目录，两个点代表当前文件所在目录的父目录，以此类推，<br>注意相对导入使用__name__属性实现的，所以对于执行模块必须小心，因为他的__name__属<br>性是__main__, 所以这些模块中不能使用相对导入</p>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="基本OOP代码示例"><a href="#基本OOP代码示例" class="headerlink" title="基本OOP代码示例"></a>基本OOP代码示例</h2><p>类,类的实例和模块都只是一个命名空间,命名空间的属性都可以修改,所以非常灵活,对于基于类的对象而言,可以使用dir内 置函数来查看命名空间,<br><strong>类与类的实例都是对象,二者都是使用字典对象实现的命名空间,二者的__dict__属性基本就是命名空间 字典</strong>, 看如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    a Test Class</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    val1 = <span class="hljs-number">1</span><br>    val2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, arg1, arg2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.arg1 = arg1<br>        self.arg2 = arg2<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span> self.arg1, self.arg2<br><br>obj1 = Test(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">dir</span>(Test)<br><span class="hljs-built_in">print</span><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">dir</span>(obj1)<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__doc__&#x27;, &#x27;__format__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__module__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;display&#x27;, &#x27;val1&#x27;, &#x27;val2&#x27;]<br></code></pre></td></tr></table></figure>

<p>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs example">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__doc__&#x27;, &#x27;__format__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__module__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;arg1&#x27;, &#x27;arg2&#x27;, &#x27;display&#x27;, &#x27;val1&#x27;, &#x27;val2&#x27;]<br></code></pre></td></tr></table></figure>

<p>val1, val2,<br><span class="underline"><span class="underline">init</span></span>,<br>display都是类Test本身的属性, 而arg1, arg2就是类实例(obj1)的属性,实际上self产生的就是 类实例对象的属性,<br>当然类的实例也会继承 类的属性</p>
<h2 id="属性搜索树"><a href="#属性搜索树" class="headerlink" title="属性搜索树"></a>属性搜索树</h2><p>当调用obj.attr时,python有一个属性的搜索过程,比如下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D2</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D3</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span>(D1, D2):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span>(<span class="hljs-title class_ inherited__">D3</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(C1, C2):<br>    <span class="hljs-keyword">pass</span><br><br>a1 = B()<br>a2 = B()<br></code></pre></td></tr></table></figure>

<p>上面的代码会构成一颗属性搜索树:</p>
<p><img src="/static/img/attribute-search-tree.png" srcset="/img/loading.gif" lazyload></p>
<p>因为类本身也是对象,所以类本身也有属性,类的属性就是类的方法,以及类的变量, 比如当调用a1.x时,那么搜索的过程就 是这样的: a1, B,<br>C1, D1, D2, C2, D3注意这是深度优先搜索,python的经典类与新式类都是这种搜索模式，但是新式类 有一个diamond<br>pattern，也就是钻石模式，这种模式下有一个以上的超类会通往相同的更高层次的超类，这时候会使用<br>广度优先搜索(只是有相同超类的那一部分)，举个例子：</p>
<p><img src="/static/img/diamond-pattern.png" srcset="/img/loading.gif" lazyload></p>
<p>如上图所示，如果C2有个w属性，D2也有个w属性，那么当使用a1.w进行属性搜索时，如果使用深度优先搜索，那么会得到 D2.w，<br>但是C2是D2的子类，并且重载了w属性，这种情况下应该用子类的属性也就是C2的w属性，钻石继承就是为这种情<br>况准备的，在这种情况下，在C1,D2, C2会使用广度优先算法搜索，这样就可以先得到C2.w<br>.这个特例需要注意</p>
<h2 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h2><h3 id="is-a"><a href="#is-a" class="headerlink" title="is a"></a>is a</h3><p>如何现实中两个事物是is a的关系，那么就应该用继承，比如teacher is a person，那么Teacher就应该继承Person</p>
<h3 id="has-a"><a href="#has-a" class="headerlink" title="has a"></a>has a</h3><p>比如一个商店有商品，有营业员，有顾客，那么商店与商品，营业员，顾客就是has a的关系，这时候应该使用组合，也<br>就是说商店是一个容器，在该容器对象的构造函数中创建营业员对象，创建商品对象，创建顾客对象，具体到python就<br>是在__init__中创建这些对象</p>
<h2 id="常见的运算符重载"><a href="#常见的运算符重载" class="headerlink" title="常见的运算符重载"></a>常见的运算符重载</h2><ol>
<li><span class="underline"><span class="underline">getattr</span></span><br><span class="underline"><span class="underline">setattr</span>__使用obj.attr时如果该属性obj中没有attr属性，这时会调用__getattr_</span>,<br>__setattr___会 拦截所有的属性赋值，也就是obj.attr &#x3D;<br>val这样的语句都等价于obj.__setattr__<sub>(‘attr’,<br>val)</sub>，这是 和__getattr__不同的地方，要特别注意</li>
<li><span class="underline"><span class="underline">getitem</span></span><br><span class="underline"><span class="underline">setitem</span>_</span><br>当出现x[i], x[i] &#x3D; val, 会分别调用上述方法， 当使用for 迭代时会先尝试__iter__,<br>如果行不通，那么就使用索 引，也就是用不断递增的索引调用__getitem__,<br>直到出现IndexError</li>
<li><span class="underline"><span class="underline">iter</span></span><br>必须返回一个迭代器对象，一个拥有next方法的对象就是迭代器对象，如果使用for 在该对象上迭代，它会先使用<br>iter内置函数来调用__iter__<br>方法获得迭代器对象，然后重复的调用该迭代器对象的next方法，直到该next方法产生<br>StopIteration异常。</li>
<li><span class="underline"><span class="underline">call</span></span><br>将类实例作为函数调用时就是使用的该方法，比如obj是一个类实例，那么obj(‘a’, ‘b’)等价于<br>obj.__call_<sub>(‘a’,’b’)</sub>,这是一个很常用的方法</li>
</ol>
<h2 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h2><p>任何对象只要定义了__get__,<br><span class="underline"><span class="underline">set</span></span>,<br>__del__三者之一，那么就是descriptor，这<br>是一份不错的<a target="_blank" rel="noopener" href="http://docs.python.org/2/howto/descriptor.html">tutorial</a>，<br>示例代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RevealAccess</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;A data descriptor that sets and returns values</span><br><span class="hljs-string">       normally and prints a message logging their access.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initval=<span class="hljs-literal">None</span>, name=<span class="hljs-string">&#x27;var&#x27;</span></span>):<br>        self.val = initval<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, obj, objtype</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Retrieving&#x27;</span>, self.name<br>        <span class="hljs-keyword">return</span> self.val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, obj, val</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Updating&#x27;</span> , self.name<br>        self.val = val<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    x = RevealAccess(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;var &quot;x&quot;&#x27;</span>)<br>    y = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs example">&gt;&gt;&gt; m = MyClass()<br>&gt;&gt;&gt; m.x<br>Retrieving var &quot;x&quot;<br>10<br>&gt;&gt;&gt; m.x = 20<br>Updating var &quot;x&quot;<br>&gt;&gt;&gt; m.x<br>Retrieving var &quot;x&quot;<br>20<br>&gt;&gt;&gt; m.y<br>5<br></code></pre></td></tr></table></figure>

<p>上例中 m.x<br>是一个descriptor，因为它是RevealAccess的类实例，而该类定义了__get__与__set__,所以<br>m.x 实际上等价 于 x.__get_<sub>(m)</sub></p>
<h1 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h1><p>在python中类也是对象，生成instance的叫class，生成class的就叫metaclass。type就是<br>python中内建的一个metaclass</p>
<h1 id="python异常"><a href="#python异常" class="headerlink" title="python异常"></a>python异常</h1><p>只说明基于类的异常, 老版的python中基于字符串的异常不考虑</p>
<h2 id="try-…-except语句"><a href="#try-…-except语句" class="headerlink" title="try … except语句"></a>try … except语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs example">try:<br>    main-block<br>except class1:<br>    handler1<br>except class2, instance:<br>    handler2<br>except (class3, class4):<br>    handler3<br>except (class5, class6), instance:<br>    handler4<br>except:<br>    handler5<br>else:<br>    else-block finally: finally-block<br></code></pre></td></tr></table></figure>

<p>python2.5以后版本才可以else,finally混在一起,执行try 中语句块时如果没有出现异常,那么就执行else 语句块,如果出<br>现了异常,那么就从上到下的匹配ecxept子句,最后执行第一个匹配的except 语句块, finally是无论是否发生异常,以及无<br>论是否捕捉了异常都会执行的</p>
<h2 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h2><p>raise语句的几种形式</p>
<ol>
<li>raise : 重新触发上一次产生的异常</li>
<li>raise instance : 触发为name的异常</li>
<li>raise class, instance : 和2类似,只是data是额外数据</li>
</ol>
<p><strong>上述的instance应该是一个异常类的实例</strong>,目前第二种最常用,为了兼容raise instance还有以下的几种衍生形式</p>
<ul>
<li>raise class : 等同于 raise class()</li>
<li>raise class, arg :等同于raise class(arg)</li>
<li>raise class, (arg1, arg2,…) : 等同于raise class(arg1, arg2,…)</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常都是类, exceptions must be old-style classes or derived from<br>BaseException.也就是说,要么是老式类,要么<br>是BaseException的子类,实践中用户自定义的类最好继承于Exception,并且必须以Error结尾,<br><strong>注意except语句是基于超 类匹配的</strong></p>
<h1 id="python中文处理"><a href="#python中文处理" class="headerlink" title="python中文处理"></a>python中文处理</h1><p>中文处理一直是一个比较棘手的问题,各种乱码一直让程序员苦不堪言,这里主要介绍 python中文处理的一般原则,<br>先介绍几个基本概念(强烈建议看看这篇<a target="_blank" rel="noopener" href="http://nedbatchelder.com/text/unipain.html">文章</a>):</p>
<ol>
<li>unicode: 简单点说你可以将unicode看成一种映射,地球上的每一个符号都在unicode 中有一个数(准确的说叫code<br>point)与之对应</li>
<li>utf8, utf16: 刚刚说了地球上的每一个符号在unicode中有一个数与之对应,那么这 个数如何存储在计算机上呢?utf8,<br>utf16, utf32就是存储策略</li>
<li>big5, gb2312等: 这些都是各个地区自行发明的双字节码,也就是两个字节代表一个 符号</li>
</ol>
<p>python字符处理的基本概念:</p>
<ol>
<li>byte string: 字节流, utf8,utf16, gb2312等编码后得到的string都是字节流,通过<br>decode方法可以得到unicode string</li>
<li>unicode string: unicode字符串的每一个字符都是一个code point, 它可以通过<br>encode方法转换为各种byte string</li>
</ol>
<p>因此python中文处理的实质就是在byte string与unicode string之间来回转换, 因为<br>python解释器在解释python源文件时,也是需要编码信息的,所以在文件的前两行必须指<br>定编码信息(coding:utf8), <strong>指定的编码必须与python源文件保存时的编码一致</strong></p>
<p>python2与python3的区别:</p>
<ol>
<li><p>python2中字面字符串是byte string, 而3中是unicode string</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ss = <span class="hljs-string">&#x27;你好&#x27;</span>                     <span class="hljs-comment"># python2为byte string, python3为unicode string</span><br>ss = <span class="hljs-string">u&#x27;你好&#x27;</span>                    <span class="hljs-comment"># python2得到unicode string</span><br>ss = <span class="hljs-string">b&#x27;你好&#x27;</span>                    <span class="hljs-comment"># python3得到byte string</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>对二者名称不同</p>
<table>
<thead>
<tr>
<th>category</th>
<th>python2</th>
<th>python3</th>
</tr>
</thead>
<tbody><tr>
<td>byte string</td>
<td>str</td>
<td>bytes</td>
</tr>
<tr>
<td>unicode string</td>
<td>unicode</td>
<td>str</td>
</tr>
</tbody></table>
</li>
<li><p>读取文件时,python2得到byte string, 而python3调用open时如果指定了b则得到 byte string,<br>如果没有指定b, 那么就会使用local.getpreferredencoding()返回的<br>编码方式来decode,然后得到unicode string.<br>python3中调用open时有一个可选参数 来指定解码方式..</p>
</li>
<li><p>混合时的处理方式不同,如一个byte string与一个unicode string相加,那么python2<br>会使用sys.getdefaultencoding()返回的编码方式来decode那个byte string, 然后<br>与unicode string相加得到一个unicode string,但是python3会返回异常因为<br>python3不允许二者混合.</p>
</li>
</ol>
<h1 id="一些很诡异的问题"><a href="#一些很诡异的问题" class="headerlink" title="一些很诡异的问题"></a>一些很诡异的问题</h1><h2 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">gg = <span class="hljs-literal">None</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">aa=&#123;&#125;</span>):<br>    <span class="hljs-built_in">print</span> aa<br>    <span class="hljs-keyword">global</span> gg<br>    gg = aa<br><br>test()<br>gg[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-string">&quot;world&quot;</span><br>test()<br></code></pre></td></tr></table></figure>

<p>第一次调用test, aa是{}, 第二次调用就是{“hello”: “world”}了, 所以默认参数可是 可变对象时,要特别注意,<br>一定要确定是否需要使用copy.</p>
<h1 id="一些标准库的使用说明"><a href="#一些标准库的使用说明" class="headerlink" title="一些标准库的使用说明"></a>一些标准库的使用说明</h1><h2 id="python-正则表达式"><a href="#python-正则表达式" class="headerlink" title="python 正则表达式"></a>python 正则表达式</h2><p>python的正则表达式是通过re这个标准库支持的,这是一篇写的不错的<a target="_blank" rel="noopener" href="https://www.evernote.com/shard/s89/sh/8d66ae55-5f2e-4a68-b11d-c8ae8ad3de56/00bfb7913d34061da0083d8286ff1592">文章</a>,<br>我可耻的用evernote保存下来 了,上面有原文章的连接.</p>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>和log4j类似,先说几个基本概念</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>Logger: 用户程序主要调用的就是该类的实例的方法</li>
<li>Handler:　指定日志应该保存到何处，比如console,file等等.</li>
<li>Filters: 指定过滤条件,他可以确定哪些日志输出</li>
<li>Formatters: 确定日志格式的</li>
</ol>
<h3 id="logger层次关系"><a href="#logger层次关系" class="headerlink" title="logger层次关系"></a>logger层次关系</h3><p>获得logger一般使用 <code>logging.getLogger</code> 这个api, 它会接受一个name参数, name 如果不指定那么获得root<br>logger, 假设如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br>root = logging.getLogger()<br>logger1 = logging.getLogger(<span class="hljs-string">&quot;aa&quot;</span>)<br>logger2 = logging.getLogger(<span class="hljs-string">&quot;aa.bb&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><strong>root是所有logger的父logger</strong>, 所以root是logger1的父logger, logger1又是<br>logger2的父logger, 实际上就是将logger像python的模块那样建立层次结构, 子<br>logger的消息会传递给父logger, 所以你运行这行代码<br><code>logger2.info(&quot;hello..&quot;)</code>, 那么消息也会传递到logger1, root,<br>如果这两个logger的设置允许输出消息,那么该<br>消息可能logger2,logger1,root分别输出</p>
<h3 id="日志输出的过程"><a href="#日志输出的过程" class="headerlink" title="日志输出的过程"></a>日志输出的过程</h3><p>假设你运行 <code>logger.info(&quot;hello&quot;)</code>, 那么这条消息如何输出呢?</p>
<ol>
<li>如果logger的level比info高,那么不输出, 如果有注册的filter返回false那么不 输出.</li>
<li>将消息发送给注册在logger上的所有handler,有handler来局定消息如何处理</li>
<li>对单个handler而言,如果hander的level比info高,那么不输出,有注册的filter返<br>回false那么不输出,否则就输出</li>
</ol>
<p><strong>不管logger是否输出该消息,该消息都会发往父logger.</strong></p>
<h3 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h3><ol>
<li>logging.basicConfig: 用来设置root logger的handler, 如果发现handler已设置,那<br>么什么也不做.</li>
<li>logging.getLogger: 用来创建logger, 如果参数为空,那么返回root logger.</li>
</ol>
<p>logger对象的方法:</p>
<ol>
<li><code>logger.debug(msg, *args, **kwargs)</code>: msg是字符串,其中可以包含%s, %d这样 的格式化信息,<br>args包含提供给msg的字符格式化参数, kwags中有两个key会检查:<ul>
<li>exc_info: 如果为True, 那么logger会调用 <code>sys.exc_info</code> 来获得一个记录异 常信息的三元组,<br>接着就会将三元组记录的异常调用栈记录进日志, 注意 <strong>只在 except语句块中有效</strong>, 因为你必须在处理异常时,<br>sys.exc_info才能获得调用栈. 当然你可以明确的指定一个三元组, 而不是简单的指定True, 这样logger就会使<br>用你指定的三元组的异常信息,而不是调用 <code>sys.exc_info</code> 来获得, 因此也就 不存在只在except块有效的限制.</li>
<li>extra: 指定参数来初始化log record, 可以用它来修改本条日志的一些格式</li>
</ul>
</li>
<li>logger.info</li>
<li>logger.warning</li>
<li>logger.error</li>
<li>logger.critical</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>threading是一个更高层的模块，它使用更加方便，所以一般情况都是使用该模块</p>
<ol>
<li><p>threading.Thread: 要创建一个线程，那么需要先创建threading.Thread的子类，并且重写它的run方法，每一个<br>Thread对象都要调用start方法，该方法启动线程，该线程会运行该对象的run方法 daemon：<br>如果已经没有活动的non-daemon(daemon&#x3D;False)线程的话,<br>整个进程都会退出,所以经常将子线程的daemon 设为True,并且子线程做成一个while<br>True的死循环,这样如果主线程退出,那么整个进程都会退出,那些死循环的子线 程自然也会退出</p>
</li>
<li><p>Queue: 同步队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Queue <span class="hljs-keyword">import</span> Queue<br>q = Queue()<br><span class="hljs-comment"># thread1</span><br>item = q.get()<br>do_something(item)<br>q.task_done()<br><br><span class="hljs-comment"># main thread</span><br>q.join()<br></code></pre></td></tr></table></figure>

<p>实际上task_done就是将内部的计数器减一, 而put会将内部的计数器加1,然后join会测试如果内部的计数器为0就返<br>回,不为0就阻塞</p>
</li>
</ol>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>字典的子类，可以用于统计可迭代对象中重复元素出现的次数,这是<a target="_blank" rel="noopener" href="http://docs.python.org/2/library/collections.html#counter-objects">文档</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>cn_str = Counter(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-built_in">print</span> cn_str<br><br>cn_list = Counter([<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>])<br><span class="hljs-built_in">print</span> cn_list<br><br>cn_dict = Counter(cats=<span class="hljs-number">4</span>, dogs=<span class="hljs-number">8</span>)<br><span class="hljs-built_in">print</span> cn_dict<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">Counter(&#123;&#x27;l&#x27;: 3, &#x27;o&#x27;: 2, &#x27; &#x27;: 1, &#x27;e&#x27;: 1, &#x27;d&#x27;: 1, &#x27;h&#x27;: 1, &#x27;r&#x27;: 1, &#x27;w&#x27;: 1&#125;)<br>Counter(&#123;&#x27;blue&#x27;: 3, &#x27;red&#x27;: 2, &#x27;green&#x27;: 1&#125;)<br>Counter(&#123;&#x27;dogs&#x27;: 8, &#x27;cats&#x27;: 4&#125;)<br></code></pre></td></tr></table></figure>

<p>Counter除了有dict的方法外，还有几个特有的方法</p>
<ol>
<li>elements(): 返回可迭代对象，比如调用cn_list.elements() 就会返回[‘red’, ‘blue’,<br>‘red’, ‘green’, ‘blue’, ‘blue’]</li>
<li>most_common([n]) : 根据字典色value从大到小排出n个item组成一个list</li>
</ol>
<h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h3><p>可以从左边或者右边添加或者删除元素,这是<a target="_blank" rel="noopener" href="http://docs.python.org/2/library/collections.html#deque-objects">文档</a><br>,主要有append,appendleft(单个元素),extend,extendleft(可迭代对 象),pop, popleft等等</p>
<h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>提供了一个default_factory属性,通过初始化defaultdict实例时对该属性赋值,那么以后如果出现key不存在的情况,不<br>会出现KeyError,而是调用这个默认工厂函数,然后返回该工厂函数的返回值,这是<a target="_blank" rel="noopener" href="http://docs.python.org/2/library/collections.html#defaultdict-objects">文档</a><br>,这是几段代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs example"># 以list 作为default_factory<br>&gt;&gt;&gt; s = [(&#x27;yellow&#x27;, 1), (&#x27;blue&#x27;, 2), (&#x27;yellow&#x27;, 3), (&#x27;blue&#x27;, 4), (&#x27;red&#x27;, 1)]<br>&gt;&gt;&gt; d = defaultdict(list)<br>&gt;&gt;&gt; for k, v in s:<br>...     d[k].append(v)<br>...<br>&gt;&gt;&gt; d.items()<br>[(&#x27;blue&#x27;, [2, 4]), (&#x27;red&#x27;, [1]), (&#x27;yellow&#x27;, [1, 3])]<br><br># 以整数作为default_factory<br>&gt;&gt;&gt; s = &#x27;mississippi&#x27;<br>&gt;&gt;&gt; d = defaultdict(int)<br>&gt;&gt;&gt; for k in s:<br>...     d[k] += 1<br>...<br>&gt;&gt;&gt; d.items()<br>[(&#x27;i&#x27;, 4), (&#x27;p&#x27;, 2), (&#x27;s&#x27;, 4), (&#x27;m&#x27;, 1)]<br></code></pre></td></tr></table></figure>

<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>一个tuple的子类,可以给tuple的每一项添加一个名字,以后就可以通过 X.y这样的方式来访问了,看代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Point = namedtuple(<span class="hljs-string">&#x27;Point&#x27;</span>, [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>], verbose=<span class="hljs-literal">False</span>)<br>p = Point(<span class="hljs-number">11</span>, y=<span class="hljs-number">22</span>)<br><span class="hljs-built_in">print</span> p<br><br>s = p[<span class="hljs-number">0</span>] + p[<span class="hljs-number">1</span>]                 <span class="hljs-comment"># like normal tuple</span><br><span class="hljs-built_in">print</span> s<br><br>s = p.x + p.y<br><span class="hljs-built_in">print</span> s<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs example">Point(x=11, y=22)<br>33<br>33<br></code></pre></td></tr></table></figure>

<p>上述代码代表一个点,点有x,y两个值,要访问点的x,可以通过p.x 或者 <code>p[0]</code> (也就是和普通的tuple一样)</p>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>OrderedDict是dict的子类,它会记住key插入的顺序,默认的dict是会排序的, 比如下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br>l = [(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>)]<br>d = <span class="hljs-built_in">dict</span>(l)<br><span class="hljs-built_in">print</span> d<br><br>od = OrderedDict(l)<br><span class="hljs-built_in">print</span> od<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs example">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;f&#x27;: 2&#125;<br>OrderedDict([(&#x27;b&#x27;, 3), (&#x27;f&#x27;, 2), (&#x27;a&#x27;, 1)])<br></code></pre></td></tr></table></figure>

<p>popitem(last&#x3D;True): last为True,那么就是LIFO, 比如上例就是先弹出(a, 1) 然后(f, 2),<br>如果last为False,那么就 是FIFO</p>
<h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><ul>
<li>dump(self, obj, file) 将对象序列化到文件</li>
<li>dumps(self, obj) 会返回序列化的字符串</li>
<li>load(file) 从文件加载对象</li>
<li>loads(str) 从字符串加载对象</li>
</ul>
<!-- end list -->

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br>d = &#123;<span class="hljs-string">&#x27;tag&#x27;</span>:<span class="hljs-string">&#x27;django&#x27;</span>&#125;<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;aa.pickle&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    pickle.dump(d, fp)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;aa.pickle&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    d = pickle.load(fp)<br></code></pre></td></tr></table></figure>

<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>和pickle类似,也是dump,dumps,load,loads这几个接口(以s结尾的就是字符串,否则就<br>是文件),json模块默认只能encode与decode python的内置类型，比如数字，字符串，<br>list，tuple，dict等，如果你要endcode自定义的类，那么你需要扩展，代码示例如下：</p>
<script src="https://gist.github.com/yuyang0/6945963.js"></script>

<p>调用的时候直接使用如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<br>    <span class="hljs-string">&#x27;status&#x27;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&#x27;data&#x27;</span>: <span class="hljs-built_in">list</span>(comments),<br>&#125;<br><br>json.dumps(d, cls=CustomTypeEncoder,<br>           user=request.user)<br></code></pre></td></tr></table></figure>

<p>cls参数指定用来encode的class，后面的user参数用来向自定义的encoder中添加额外<br>的参数，可以在自定义的encoder的init函数中获取，可以参见上面的encoder的代码</p>
<h2 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h2><p>文档中的示例代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> HTMLParser <span class="hljs-keyword">import</span> HTMLParser<br><br><span class="hljs-comment"># create a subclass and override the handler methods</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHTMLParser</span>(<span class="hljs-title class_ inherited__">HTMLParser</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_starttag</span>(<span class="hljs-params">self, tag, attrs</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Encountered a start tag:&quot;</span>, tag<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_endtag</span>(<span class="hljs-params">self, tag</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Encountered an end tag :&quot;</span>, tag<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_data</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Encountered some data  :&quot;</span>, data<br><br><span class="hljs-comment"># instantiate the parser and fed it some HTML</span><br>parser = MyHTMLParser()<br>parser.feed(<span class="hljs-string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&#x27;</span><br>            <span class="hljs-string">&#x27;&lt;body&gt;&lt;h1&gt;Parse me!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>从上面的代码可以看出:该库的使用方法就是在类中处理starttag, endtag, data(标签中间的文本)<br>然后调用feed方法就好,实际是一个流式html解析器</p>
<h1 id="一些第三方库的使用方法"><a href="#一些第三方库的使用方法" class="headerlink" title="一些第三方库的使用方法"></a>一些第三方库的使用方法</h1><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>python的标准库中的urllib,urllib2的接口并不好用,requests的接口更简洁一致,这是官方<a target="_blank" rel="noopener" href="http://docs.python-requests.org/en/latest/">文档</a></p>
<ol>
<li><p>get requests.get(url, **kwargs)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br>r = requests.get(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>, params=payload)<br></code></pre></td></tr></table></figure>
</li>
<li><p>post requests.post(url, data&#x3D;None, **kwargs)</p>
<ul>
<li>data: 是要post的数据</li>
<li>kwargs: 可以使用headers &#x3D; {….}指定http request header</li>
</ul>
<!-- end list -->

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>url = <span class="hljs-string">&#x27;https://api.github.com/some/endpoint&#x27;</span><br>payload = &#123;<span class="hljs-string">&#x27;some&#x27;</span>: <span class="hljs-string">&#x27;data&#x27;</span>&#125;<br>headers = &#123;<span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;<br><br>r = requests.post(url, data=json.dumps(payload), headers=headers)<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>put requests.put(url, **kwargs)</p>
</li>
<li><p>response object</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><span class="hljs-built_in">print</span> r.text<br><span class="hljs-built_in">print</span> r.url<br><span class="hljs-built_in">print</span> r.encoding<br><span class="hljs-built_in">print</span> r.status_code                    <span class="hljs-comment"># response status code(eg:200)</span><br><span class="hljs-built_in">print</span> r.headers                        <span class="hljs-comment"># a dict</span><br><span class="hljs-built_in">print</span> r.headers[<span class="hljs-string">&#x27;Content-Type&#x27;</span>]        <span class="hljs-comment"># response headers</span><br><span class="hljs-built_in">print</span> r.cookies[<span class="hljs-string">&#x27;example_cookie_name&#x27;</span>] <span class="hljs-comment"># cookies</span><br><span class="hljs-built_in">print</span> r.json()                         <span class="hljs-comment">#  built-in json function</span><br><br><span class="hljs-built_in">print</span> r.request.headers         <span class="hljs-comment"># http request headers</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>从github安装包 pip install git+<a href="git://github.com/yourname/package.git">git://github.com/yourname/package.git</a> 或者pip<br>install git+<a target="_blank" rel="noopener" href="https://github.com/yourname/package.git">https://github.com/yourname/package.git</a></p>
<h2 id="pyquery"><a href="#pyquery" class="headerlink" title="pyquery"></a>pyquery</h2><p>一个使用jquery语法的html解析器,非常方便,比BeautifulSoup好用,这是它的<a target="_blank" rel="noopener" href="http://pythonhosted.org/pyquery/index.html">文档</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">form pyquery <span class="hljs-keyword">import</span> PyQuery<br>html = <span class="hljs-string">&#x27;&lt;html&gt;&lt;title&gt;hello world&lt;/title&gt;&lt;/html&gt;&#x27;</span><br>d = PyQuery(html, parser = <span class="hljs-string">&#x27;html&#x27;</span>)<br>d(<span class="hljs-string">&#x27;title&#x27;</span>).text()<br></code></pre></td></tr></table></figure>

<p>在调用PyQuery时尽量指定parser, 因为默认判断有时会出错,比如用xml的parser去解析html会得到不正确的结果.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">d = PyQuery(html, parser = <span class="hljs-string">&#x27;html&#x27;</span>)<br><span class="hljs-comment"># selector</span><br>d(<span class="hljs-string">&#x27;body&#x27;</span>)<br>d(<span class="hljs-string">&#x27;div#header&#x27;</span>)<br>d(<span class="hljs-string">&#x27;div.class ul&#x27;</span>)<br>d(<span class="hljs-string">&#x27;meta[name=keywords]&#x27;</span>) <span class="hljs-comment">#attribute</span><br><br>links = d(<span class="hljs-string">&#x27;div.links a&#x27;</span>)<br><span class="hljs-comment"># 该处应使用下标,而不是for link in links</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(links)):<br>    <span class="hljs-built_in">print</span> links.eq(i).attr(<span class="hljs-string">&#x27;href&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="watchdog"><a href="#watchdog" class="headerlink" title="watchdog"></a>watchdog</h2><p>看门狗,用来监控文件系统改变,这是<a target="_blank" rel="noopener" href="http://pythonhosted.org/watchdog/">文档</a>, 基本使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> watchdog.observers <span class="hljs-keyword">import</span> Observer<br><span class="hljs-keyword">from</span> watchdog.events <span class="hljs-keyword">import</span> LoggingEventHandler<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    event_handler = LoggingEventHandler()<br>    observer = Observer()<br>    observer.schedule(event_handler, path=<span class="hljs-string">&#x27;.&#x27;</span>, recursive=<span class="hljs-literal">True</span>)<br>    observer.start()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        observer.stop()<br>    observer.join()<br></code></pre></td></tr></table></figure>

<p>关键的部分有两个:</p>
<ol>
<li>recursive&#x3D;True,默认是False,如果不指定那么那么就不会监控子目录</li>
<li>event_handler:这个是文件系统事件的处理对象,可以自己继承watchdog.events.FileSystemEventHandler,<br>然后重载<a target="_blank" rel="noopener" href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_created">on_create</a>d,<br><a target="_blank" rel="noopener" href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_deleted">on_deleted</a>,<br><a target="_blank" rel="noopener" href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_modified">on_modified</a>,<br><a target="_blank" rel="noopener" href="http://pythonhosted.org/watchdog/api.html#watchdog.events.FileSystemEventHandler.on_moved">on_moved</a>,</li>
</ol>
<h2 id="rauth"><a href="#rauth" class="headerlink" title="rauth"></a>rauth</h2><p>一个Oauth库,这是<a target="_blank" rel="noopener" href="https://rauth.readthedocs.org/en/latest/">文档</a>, 这是一份示例<br><a target="_blank" rel="noopener" href="https://gist.github.com/yuyang0/5949932">代码</a>, 基本上照着流程走就OK了</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>流行的就是pytest了，tox可以测试代码在不同环境下(py2.7, py3.5, flake8 etc..)是否 能通过,<br>它可以自动测试这些环境，很方便, 这些工具的配置比较乱</p>
<ul>
<li>tox: 配置文件: <code>tox.ini</code></li>
<li>pytest: 配置文件: <code>pytest.ini</code>, <code>tox.ini</code>, <code>setup.cfg</code></li>
<li>pytest-cov: 配置文件 <code>setup.cfg</code></li>
<li>pep8: 配置文件　&#x3D;tox.ini&#x3D;, <code>setup.cfg</code></li>
<li>flake8: 配置文件　&#x3D;tox.ini&#x3D;, <code>setup.cfg</code></li>
</ul>
<p><strong>我的建议是tox的配置放在tox.ini中，其它的都放在setup.cfg中</strong></p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>tox.ini</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs example">[tox]<br>envlist = py27, py35, pypy, flake8<br><br>[testenv]<br>commands = &#123;envpython&#125; setup.py test<br>deps = -rrequirements.txt<br><br>[testenv:flake8]<br>basepython=python<br>deps=flake8<br>commands=flake8 setup.py tests<br><br>[testenv:pypy]<br>basepython=pypy<br></code></pre></td></tr></table></figure>

<p>setup.cfg</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs example">[metadata]<br>description-file = readme.md<br><br>[aliases]<br>test=pytest<br><br># pytest-cov configuration<br>[coverage:run]<br>omit =<br>    gmesos/api.py<br>    gmesos/deployment.py<br><br># pytest configuration (pytest&gt;3.0)<br>[tool:pytest]<br>testpaths = tests<br>addopts = --cov=gmesos --cov-report term-missing<br><br># pep8 configuration<br>[pep8]<br>exclude = gmesos/interface.py<br>max-line-length = 160<br><br># flake8 configuration<br>[flake8]<br>exclude = gmesos/interface.py,venv/<br>max-line-length = 160<br>ignore= F401<br></code></pre></td></tr></table></figure>

<h1 id="常用工具的使用方法"><a href="#常用工具的使用方法" class="headerlink" title="常用工具的使用方法"></a>常用工具的使用方法</h1><h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><p>这是一份不错的<a target="_blank" rel="noopener" href="http://docs.python-guide.org/en/latest/dev/virtualenvs.html">tutorial</a></p>
<ol>
<li>virtualenv venv</li>
<li>source venv&#x2F;bin&#x2F;activate</li>
<li>deactivate</li>
</ol>
<p>virtualenvwrapper可以对virtualenv进行一定的增强</p>
<ol>
<li><p>install</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs example"><br>sudo pip install virtualenvwrapper<br>export WORKON_HOME=~/envs<br>source /usr/local/bin/virtualenvwrapper.sh<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>mkvirtualenv my_env 在WORKON_HOME中创建一个名为my_env虚拟环境</p>
</li>
<li><p>workon my_env 切换到my_env环境</p>
</li>
<li><p>deactivate</p>
</li>
<li><p>lssitepackages</p>
</li>
<li><p>lsvirtualenv</p>
</li>
<li><p>rmvirtualenv my_env</p>
</li>
</ol>
<p>和zsh的整合： 安装virtualenvwrapper插件，然后在每一个仓库中放一个.venv文件，文件的内容 是你创建的env的名字</p>
<h2 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a>ipython</h2><p>ipython是一个增强的python interpreter,有许多有趣的功能</p>
<ol>
<li>magic function 以 % 或者 %% 开头的都是magic function,其中<ul>
<li>以%开头会将本行余下的部分作为一个参数传递给该命令,如果%automagic为on(默认), 那么可以省略前面的 %, 可以<br>使用 %lsmagic 来列出有多少这种命令.</li>
<li>以%%开头的命令不仅会将本行余下的部分作为参数,本行下面独立的行也会作为参数</li>
</ul>
</li>
<li>TAB补全, 可以补全内置的函数,模块以及变量文件名等等</li>
<li>%run命令: 该命令可以用来运行脚本(实际是把所有的属性导入当前的namespace,和import功能类似),测试脚本时用该<br>命令,而不是import,因为该命令可以让改动立即生效,有以下几个选项:<ul>
<li>t: 可以用来获得脚本的运行时间</li>
<li>p: 性能分析,会列出程序中每个函数调用的时间, %prun命令与该选项功能相似,但是它是对一条python命令或者一个函数调<br>用进行性能测试</li>
<li>d: 调试,激活pdb,并在开始处暂停,和gdb类似</li>
</ul>
</li>
<li>剖析对象,给定一个对象,观察这个对象的文档,函数定义以及源代码,有以下命令<ul>
<li>%pdoc: print doc string</li>
<li>%pdef: print definition of function</li>
<li>%psource: print source code</li>
<li>%pfile: get file of this object</li>
</ul>
</li>
<li>调试: %pdb命令会打开或关闭在任何未捕捉的异常点调用pdb调试器的功能, 如果该功能打开了,那么遇到任何未捕捉的<br>异常,会自动调用调试器,这样就可以打印异常点的变量值,执行代码了</li>
<li>运行shell命令: !开头,比如 !ping <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> ,可以将shell命令的输出赋给python变量, 比如<br>output &#x3D; !ping www..baidu.com, 那么output就会是ping的输出</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/notes/">notes</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/python/">python</a>
                    
                      <a class="hover-with-bg" href="/tags/lang/">lang</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/notes/cpp/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">cpp笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/notes/golang/">
                        <span class="hidden-mobile">golang笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://yuyang0.github.io/notes/python-note/';
          this.page.identifier = '/notes/python-note/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'yuyang' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>














  
<script src="/js/custom.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
